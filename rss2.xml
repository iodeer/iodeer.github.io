<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>小丁的小屋</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>最美的相遇，不言过往；最好的离别，不问归期。</description>
    <pubDate>Sat, 21 Aug 2021 12:48:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>队列</title>
      <link>http://yoursite.com/posts/b6c47025/</link>
      <guid>http://yoursite.com/posts/b6c47025/</guid>
      <pubDate>Sat, 21 Aug 2021 12:45:52 GMT</pubDate>
      <description>
      
        队列、存储结构的基本概念极其应用
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>队列</strong>是<strong><font color='orange'>只允许在一端进行插入，在另一端删除</font></strong>的<font color='red'>线性表</font>。</p><p><strong>特点：先进先出（FIFO）</strong></p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li>队头：允许删除元素的一端</li><li>队尾：允许插入元素的一端</li><li>空队列：</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InitQueue(&amp;Q): 初始化队列，构造一个空队列Q.</span><br><span class="line">DestroyQueue(&amp;Q): 销毁队列。销毁并释放队列Q所占用的内存空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EnQueue(&amp;Q,x): 入队。若队列Q未满，将x加入，⑩之成为新的队尾。</span><br><span class="line">DeQueue(&amp;Q,&amp;x): 出队。若队列Q未满，删除对头元素，并用x返回。</span><br><span class="line"></span><br><span class="line">GetHead(Q,&amp;x): 读队头元素。若队列Q非空，则将队头元素赋值给x。</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>要判断清楚rear指向的是最后一个元素还是最后一个元素的下一个位置</li><li>确定判空的条件<ul><li>牺牲一个存储单元——循环队列</li><li>增加size变量记录队列长度</li><li>增加tag = 0/1用于标记最近的一次操作 出队/入队</li></ul></li></ul><h2 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    <span class="comment">//这里front指向队头元素，rear指向队尾元素的下一个位置 </span></span><br><span class="line">&#125; SqQueue;<span class="comment">//</span></span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，队头、队尾指针指向0；</span></span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判空</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>入队</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队，只能从队尾入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(队列已满)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear] = x;<span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = Q.rear + <span class="number">1</span>;<span class="comment">//队尾指针后移</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查询元素</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得队头元素的值，用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>入队</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入队，只能从队尾入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (Q.rear+<span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear] = x;<span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;<span class="comment">//队尾指针加一取模</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出队</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队（删除一个队头元素，并用x返回）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)<span class="comment">//判断队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data(Q.front);</span><br><span class="line">    Q.front = (Q,front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>队列中元素中的个数：(Q.rear - Q.front + MaxSize ) %MaxSize;</li></ul><h2 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h2><p><strong>后插法</strong></p><h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span><span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front , *rear;<span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p><strong>初始化（带头结点）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化队列(带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判空(带头结点)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>入队(带头结点)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s.next = <span class="literal">NULL</span>;</span><br><span class="line">    s.data = x;</span><br><span class="line">    Q.rear-&gt;next = s;<span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear = s;<span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出队（带头结点）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队，不带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p.data;<span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front-&gt;next = p.next;<span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)<span class="comment">//若此次是最后一个结点出队，则需要修改rear指针</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化(不带头结点)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判空（不带头结点）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空(不带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>入队(不带头结点)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队,不带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == <span class="literal">NULL</span>)&#123;<span class="comment">//不带头结点的队列，第一个元素入队时需要特别处理</span></span><br><span class="line">        Q.front = s;<span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;<span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear = s;<span class="comment">//修改表尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出队(不带头结点)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队头元素出队(不带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front;<span class="comment">//p指向此次出队的结点</span></span><br><span class="line">    x = p-&gt;data;<span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next;<span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)&#123;<span class="comment">//此次是最后一个结点出队，出对后则队列为空队列</span></span><br><span class="line">        Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>允许从<font color='red'>两端插入、两端删除</font>的线性表</strong></p><p><strong>输入受限的双端队列：</strong>只允许从<font color='red'>一端插入、两端删除</font>的线性表。</p><p><strong>输入受限的双端队列：</strong>只允许从<font color='red'>两端插入、一端删除</font>的线性表。</p><p><strong><font color='red'>在栈中合法的输出序列，在双端队列中必定合法</font></strong></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/b6c47025/#disqus_thread</comments>
    </item>
    
    <item>
      <title>图</title>
      <link>http://yoursite.com/posts/ee040603/</link>
      <guid>http://yoursite.com/posts/ee040603/</guid>
      <pubDate>Sat, 21 Aug 2021 12:24:54 GMT</pubDate>
      <description>
      
        图的概念以及存储结构、相对应的操作以及遍历、类别以及关键路径等概念
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><font color='red'>图G</font></strong>由<font color='red'>顶点集V</font>和<font color='red'>边集E</font>组成，记为G = ( V,E),其中V(G)表示图G中顶点的有限非空集；</p><p>E(G)表示图G中顶点之间的关系(边)集合。</p><p>若V = {v1,v2,v2…，vn}, 则用<strong><font color='red'>|V|</font></strong>表示图G中<font color='red'>顶点的个数</font>，也称为<strong><font color='red'>图G的阶</font>。</strong></p><p>E = {( u , v) | <strong><font color='orange'>u∈V，v∈V</font></strong>}，用<strong><font color='red'>|E|</font></strong>表示图G中<strong><font color='red'>边的条数</font></strong>.</p><p><strong>注意：线性表可以是空表，树可以是空树，但图不可以是空，即<font color='orange'>V一定的非空集</font>，但是边集E可以为空</strong></p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="特殊的几种图"><a href="#特殊的几种图" class="headerlink" title="特殊的几种图"></a>特殊的几种图</h4><h5 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h5><p>若E是<font color='red'>无向边</font>(简称<font color='red'>边</font>)的有限集合时，则图G为<font color='red'>无向图</font>。边是顶点的无序对，<font color='red'>记为(v,w)或者(w,v)</font>,因为<strong><font color='orange'>(v,w) = (w,v)</font></strong>，其中v、w是顶点。</p><p>可以说顶点w和顶点v互为邻接点。边(v，w)依附于顶点w和v，或者说边(v,w)和顶点v、w相关联。</p><h5 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h5><p>若E是<font color='red'>有向边</font>(简称<font color='red'>弧</font>)的有限集合时，则图G为<font color='red'>有向图</font>。弧是顶点的有序对，<font color='red'>记为&lt;v,w&gt;</font>，其中v、w是顶点，v称为<font color='red'>弧尾</font>，w称为<font color='red'>弧头</font>，&lt;v,w&gt;称为从顶点v到w的弧，也称v邻接到w，或者w邻接自v。<strong><font color='orange'>&lt;v,w&gt; ≠ &lt;w,v&gt;</font></strong></p><h5 id="简单图"><a href="#简单图" class="headerlink" title="简单图"></a>简单图</h5><ul><li>不存在重复边</li><li>不存在顶点到自身的边</li><li>也分为有向图和无向图</li></ul><h5 id="多重图"><a href="#多重图" class="headerlink" title="多重图"></a>多重图</h5><ul><li>存在某两个结点之间的边数多于一条</li><li>允许顶点通过同一条边和自己关联</li><li>也分为有向图和无向图</li><li>数据结构不考虑这种图。</li></ul><h5 id="无向完全图"><a href="#无向完全图" class="headerlink" title="无向完全图"></a>无向完全图</h5><ul><li>无向图中任意两个顶点之间都存在边</li><li><strong>边数：C(2)(n)</strong></li></ul><h5 id="有向完全图"><a href="#有向完全图" class="headerlink" title="有向完全图"></a>有向完全图</h5><ul><li>有向图中任意两个顶点之间都存在方向相反的两条弧</li><li><strong>边数：2C(2)(n)</strong></li></ul><h4 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h4><ul><li>对于<strong>无向图</strong><ul><li><font color='red'>顶点v的度</font>是指依附于该顶点的边的条数，记为TD(v);<ul><li><font color='red'>sum{TD(v)} = 2|E|</font></li></ul></li></ul></li><li>对于<strong>有向图</strong><ul><li><font color='red'>入度</font>是以顶点v为终点的有向边的数目，记为<font color='red'>ID(v).</font></li><li><font color='red'>出度</font>是以顶点v为起点的有向边的数目，记为<font color='red'>OD(v)</font></li><li><font color='red'>顶点v的度</font>等于其<font color='red'>入度和出度之和</font>，即 <font color='red'>TD(v) = ID(v) + OD(v)</font></li><li><font color='red'>sum{ID(v)} = sum{OD(v)}  = |E|</font></li></ul></li></ul><h4 id="顶点-顶点关系描述"><a href="#顶点-顶点关系描述" class="headerlink" title="顶点-顶点关系描述"></a>顶点-顶点关系描述</h4><ul><li><p><font color='red'>路径</font> ——顶点v 到 顶点 w之间有一条路径是指顶点序列：v ,a ,b ,c ….,m,w.</p></li><li><p><font color='red'>回路</font>—— 第一个顶点和最后一个顶点相同的路径称为<font color='red'>回路或者环</font>。</p></li><li><p><font color='red'>简单路径</font>—— 在路径序列中，<font color='red'>顶点不重复</font>的路径简称为简单路径。</p></li><li><p><font color='red'>简单回路</font>——除第一个顶点和最后一个顶点外，<font color='red'>其余顶点不重复</font>出现的回路称为简单回路。</p></li><li><p><font color='red'>路径长度</font>—— 路径上边的数目。</p></li><li><p>点到点的距离 ——从顶点u出发到顶点v的<strong><font color='orange'>最短路径</font></strong>若存在，则<strong><font color='orange'>此路径的长度称为从u到v的距离。</font></strong></p><p>若从u到v根本<strong><font color='orange'>不存在路径</font></strong>，则<strong><font color='orange'>记该距离为无穷（∞）</font></strong></p></li><li><p><font color='red'>无向图中</font>，若从顶点v到顶点w有路径存在，则称v和w是<font color='red'>连通</font>font&gt;的</p><ul><li>若图G中任意两个顶点都是连通的，则称G为<font color='red'>连通图</font>，否则就是<font color='red'>非连通图</font><ul><li>对于n个顶点的无向图G，要保证G是连通图，则<strong>最少</strong>有 <strong>n-1</strong>条边。</li><li>对于n个顶点的无向图G，要保证G是非连通图，则<strong>最多</strong>可能有 <strong>C(2)(n-1)</strong>条边。</li></ul></li><li>无向图中的极大连通子图称为<font color='red'>连通分量</font><ul><li><strong><font color='red'>极大连通子图：</font></strong>子图必须连续，且包含尽可能多的顶点和边</li></ul></li></ul></li><li><p><font color='red'>有向图中</font>，若从<font color='orange'>顶点v到顶点w</font>和从<font color='orange'>顶点w到顶点v</font>之间都有路径，则称这两个顶点是<font color='red'>强连通</font>的</p><ul><li>若图G中任意一对顶点都是强连通的，则称G为<font color='red'>强连通图</font><ul><li>对于n个顶点的有向图G，要保证G是强连通图，则<strong>最少</strong>有 <strong>n</strong>条边（<strong>形成回路</strong>）。</li></ul></li><li>有向图中的极大强连通子图称为<font color='red'>强连通分量</font><ul><li><strong><font color='red'>极大强连通子图：</font></strong>子图必须连续，且包含尽可能多的顶点和边</li></ul></li></ul></li></ul><h4 id="研究图的局部——子图"><a href="#研究图的局部——子图" class="headerlink" title="研究图的局部——子图"></a>研究图的局部——子图</h4><ul><li>设有两个图G = (V,E) 和 G’ = ( V’,E’),若V‘是V的子集，且E’是E的子集，则称G‘是G的<font color='red'>子图</font>.<ul><li><strong>注意：并未V、E的任何子集都能构成G的子图，因为这样子的子集可能不是图，即E的自己种的某些边关联的顶点可能不在这个V的子集中</strong></li></ul></li><li>若有满足V(G’) = V(G)的子图G’，则称其为G的<font color='red'>生成子图</font></li></ul><h4 id="生成树、生成森林"><a href="#生成树、生成森林" class="headerlink" title="生成树、生成森林"></a>生成树、生成森林</h4><ul><li><strong><font color='orange'>连通图</font></strong>的<font color='red'>生成树</font>是<strong><font color='orange'>包含一个图中全部顶点的一个极小连通子图</font></strong><ul><li>极小连通子图：边尽可能的少，但是要保持连通</li><li>若图中顶点数为n，则它的生成树含有 n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则可能会形成一个回路</li></ul></li><li><strong><font color='orange'>在非连通图</font></strong>中，<strong><font color='orange'>连通分量的生成树</font></strong>构成了非连通图的<font color='red'>生成森林</font>。</li></ul><h4 id="边的权、带权图-网"><a href="#边的权、带权图-网" class="headerlink" title="边的权、带权图/网"></a>边的权、带权图/网</h4><ul><li><font color='red'>边的权</font>——在一个图中，每条边都可以表上带有某种含义的数值，该数值称为该边的<font color='red'>权值</font></li><li><font color='red'>带权图/网</font>——边上带有权值的图称为<font color='red'>带权图</font>，也称<font color='red'>网</font></li><li><font color='red'>带权路径长度</font>——当图是带权图时，一条<font color='orange'>路径上所有边的权值之和</font>，称为该路径的<font color='red'>带权路径长度</font>.</li></ul><h3 id="常见考点"><a href="#常见考点" class="headerlink" title="常见考点"></a>常见考点</h3><h4 id="对于n个顶点的无向图G"><a href="#对于n个顶点的无向图G" class="headerlink" title="对于n个顶点的无向图G"></a>对于n个顶点的无向图G</h4><ul><li><p>所有顶点的度之和 = 2|E|</p></li><li><p>若G是连通图，则最少有n-1条边(数)</p><p>若 |E| &gt; n-1,则一定有回路</p></li><li><p>若G是非连通图，则最多可能有 C(2)(n-1)条边</p></li><li><p>无向完全图共有C(2)(n)条边</p></li></ul><h4 id="对于n个顶点的有向图G"><a href="#对于n个顶点的有向图G" class="headerlink" title="对于n个顶点的有向图G"></a>对于n个顶点的有向图G</h4><ul><li>所有顶点的出度之和 = 入度之和 = |E|</li><li>所有顶点的度之和 = 2|E|</li><li>若G是强连通图，则最少有n条边(形成回路)</li><li>有向完全图共有 2C(2)(n)条边</li></ul><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>指用于一个一位数组存储图中顶点的信息，用一个二维数组存储图中边的信息(即各顶点之间的邻接关系)</li><li>若图G的邻接矩阵是A，则<ul><li>A[i] [j] = 1 ==&gt;(vi,vj)是E(G)中的边</li><li>A[i] [j] = 0 ==&gt;(vi,vj)不是E(G)中的边</li></ul></li></ul><h4 id="求顶点的度、出度、入度"><a href="#求顶点的度、出度、入度" class="headerlink" title="求顶点的度、出度、入度"></a>求顶点的度、出度、入度</h4><ul><li>无向图<ul><li><strong>第i个结点的<font color='red'>度</font> = <font color='red'>第i行(或者第i列)</font>的非零元素个数</strong></li></ul></li><li>有向图<ul><li><strong>第i个结点的<font color='red'>出度</font> = <font color='red'>第i行</font>的非零元素个数</strong></li><li><strong>第i个结点的<font color='red'>入度</font> = <font color='red'>第i列</font>的非零元素个数</strong></li><li><strong>第i个结点的<font color='red'>度</font> = <font color='red'>第i行(或者第i列)</font>的非零元素个数之和</strong></li></ul></li></ul><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;<span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;<span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];<span class="comment">//邻接矩阵 边表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p><font color='red'>无向图</font>的邻接矩阵一定是一个<font color='orange'>对称矩阵</font>(并且<strong>唯一</strong>)。因此，在实际存储邻接矩阵时，只需要存储上(或下)三角矩阵的元素</p></li><li><p>对于<font color='red'>无向图</font>，邻接矩阵的第i行(或者第i列)非零元素(或非∞元素)的个数刚好是顶点i的度。</p></li><li><p>对于<font color='red'>有向图</font>，邻接矩阵的第i行非零元素(或非∞元素)的个数正好是顶点i的出度OD(v)；</p><p>第i列非零元素(或非∞元素)的个数正好是顶点i的入度ID(v)；</p></li><li><p>优点：容易确定任意两点之间是否有边相连</p><p>缺点：确定图中有多少边，时间复杂度较高，O(n²)；空间复杂度O(n²)</p></li><li><p><strong>适合稠密图存储</strong></p></li><li><p>设图G的邻接矩阵为A，则<strong>A∧n的元素A∧n[i] [j] 表示从由顶点i到顶点j的<font color='orange'>长度为n的路径</font>有<font color='red'>多少条</font></strong></p></li></ul><h3 id="邻接表-顺序-链表存储"><a href="#邻接表-顺序-链表存储" class="headerlink" title="邻接表(顺序+链表存储)"></a>邻接表(顺序+链表存储)</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;<span class="comment">//第一条边/弧</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//边、弧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;<span class="comment">//边、弧指向向哪一个结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span><span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;//边权值</span></span><br><span class="line">&#125;ArcNode;</span><br></pre></td></tr></table></figure><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><p>若G为<font color='cornflowerblue'>无向图</font>，则所需要的存储空间为 O(|V| + 2|E|)</p><p>若G为<font color='cornflowerblue'>有向图</font>，则所需要的存储空间为 O(|V| + |E|)    </p></li><li><p>适合于<strong>稀疏图</strong></p></li><li><p>优点：对于给定一顶点，可以快速找到它的所有邻边。</p><p>缺点：确定两顶点直接是否存在边，需要扫描整个链表，时间复杂度高</p></li><li><p>对于<font color='cornflowerblue'>有向图</font>，计算<strong>出度只需要计算邻接表中的结点个数</strong>；</p><p>​                        计算<strong>入度需要扫描整个邻接表，效率低</strong></p></li><li><p>图的邻接表 表示<strong>不唯一</strong></p></li></ul><h3 id="十字链表-存储有向图"><a href="#十字链表-存储有向图" class="headerlink" title="十字链表(存储有向图)"></a>十字链表(存储有向图)</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">弧结点</span><br><span class="line">    * tailvex弧尾顶点编号</span><br><span class="line">    * headvex弧头顶点编号</span><br><span class="line">    * info权值</span><br><span class="line">    * hlink弧头相同的下一条弧</span><br><span class="line">    * tlink 弧尾相同的下一条弧</span><br><span class="line"></span><br><span class="line">顶点结点：用数组顺序存储</span><br><span class="line">    * data数据域</span><br><span class="line">    * firstin该顶点作为弧头的第一条弧</span><br><span class="line">    * firstout该顶点作为弧尾的第一条弧</span><br></pre></td></tr></table></figure><p><strong>图的十字链表表示是不唯一的，但一个十字链表表示一个确定的图</strong></p><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li>空间复杂度：<strong>O(|V| + |E|)</strong></li></ul><h3 id="邻接多重表-存储无向图"><a href="#邻接多重表-存储无向图" class="headerlink" title="邻接多重表(存储无向图)"></a>邻接多重表(存储无向图)</h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">边结点</span><br><span class="line">ivex边的一个顶点编号 i</span><br><span class="line">jvex边的一个顶点编号 j</span><br><span class="line">ilink指向下一条依附于ivex的边</span><br><span class="line">jlink指向下一条依附于jvex的边</span><br><span class="line">info权值</span><br><span class="line"></span><br><span class="line">顶点结点</span><br><span class="line">data数据域</span><br><span class="line">firstedge与该顶点相连的第一条边</span><br></pre></td></tr></table></figure><p><strong>图的邻接多重表表示是不唯一的，但一个邻接多重表表示一个确定的图</strong></p><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li>空间复杂度：<strong>O(|V| + |E|)</strong></li></ul><h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">Adjacent(G,x,y);判断图G是否存在边&lt;x,y&gt;或(x,y)</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)~O(|V|)</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)~O(|V|)</span><br><span class="line">Neighbors(G,x);列出图中G中与结点x邻接的边</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(|V|);</span><br><span class="line">*邻接表：O(1)~O(|V|)</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(|V|);</span><br><span class="line">*邻接表：</span><br><span class="line">出边：O(1)~O(|V|)</span><br><span class="line">入边：O(|E|)</span><br><span class="line">InsertVertex(G,x);在图中G插入顶点x</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)</span><br><span class="line">DeleteVertex(G,x);在图中G删除顶点x</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(|V|);</span><br><span class="line">*邻接表：O(1)~O(|E|)</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(|V|);</span><br><span class="line">*邻接表：</span><br><span class="line">删出边：O(1)~O(|V|)</span><br><span class="line">删入边：O(|E|)</span><br><span class="line">AddEdge(G,x,y);若无向边(x,y)或有向边&lt;x,y&gt;不存在时，则向图G中添加该边。</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)---头插法</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：</span><br><span class="line">增出边：O(1)</span><br><span class="line">增入边：O(1)</span><br><span class="line">RemoveEdge(G,x,y);若无向边(x,y)或有向边&lt;x,y&gt;存在时，则向图G中删除该边。</span><br><span class="line">FirstNeighbor(G,x);求图G中顶点的第一个邻接点，若有则返回顶点好，若x没有邻接点或者图中不存在x，则返回-1</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(1)~O(|V|);</span><br><span class="line">*邻接表：O(1)</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(1)~O(|V|);</span><br><span class="line">*邻接表：</span><br><span class="line">找出边：O(1)</span><br><span class="line">找入边：O(1)~O(|E|)</span><br><span class="line">NextNeightbor(G,x,y);假设图G中顶点y是顶点x的第一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个的邻接点，则返回-1</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(1)~O(|V|);</span><br><span class="line">*邻接表：O(1)</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(1)~O(|V|);</span><br><span class="line">*邻接表：</span><br><span class="line">找出边：O(1)</span><br><span class="line">找入边：O(1)~O(|E|)</span><br><span class="line">Get_edge_value(G,x,y):获取图G中边&lt;x,y&gt;或(x,y)对应的权值</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)~O(|V|)</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)~O(|V|)</span><br><span class="line">Set_edge_value(G,x,y,v):设置图G中边&lt;x,y&gt;或(x,y)对应的权值v</span><br><span class="line">无向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)~O(|V|)</span><br><span class="line">有向图</span><br><span class="line">*邻接矩阵：O(1);</span><br><span class="line">*邻接表：O(1)~O(|V|)</span><br></pre></td></tr></table></figure><h2 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h2><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><h4 id="与树的广度优先遍历之间的联系"><a href="#与树的广度优先遍历之间的联系" class="headerlink" title="与树的广度优先遍历之间的联系"></a>与树的广度优先遍历之间的联系</h4><ul><li>树的广度优先遍历——<strong>层序遍历</strong></li></ul><p><strong>树vs图</strong></p><ul><li>树——<ul><li>不存在回路，在搜寻相邻的结点是，不可能搜到重复的结点</li><li>层须遍历——依靠队列</li></ul></li><li>图——<ul><li>搜索相邻的顶点时，有可能搜到已经访问过的结点了<ul><li>对每一个结点进行标记，访问过的结点进行标记，再次授勋时就跳过去</li></ul></li></ul></li></ul><p><strong>同一个图的<font color='red'>邻接矩阵</font>表示方式<font color='red'>唯一</font>，因此广度优先<font color='red'>遍历序列唯一</font></strong></p><p><strong>同一个图的<font color='red'>邻接表</font>表示方式<font color='red'>不唯一</font>，因此广度优先<font color='red'>遍历序列不唯一</font></strong></p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">步骤</span></span><br><span class="line"><span class="comment">        1. 找到与一个顶点相邻的所有顶点</span></span><br><span class="line"><span class="comment">           1. FirstNeighbor(G,x);</span></span><br><span class="line"><span class="comment">           2. NextNeightbor(G,x,y);</span></span><br><span class="line"><span class="comment">        2. 标记哪些顶点被访问过</span></span><br><span class="line"><span class="comment">        bool visited[MAX_VERTEX_NUM];访问标记数组</span></span><br><span class="line"><span class="comment">        3. 需要一个辅助队列</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组，从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//对v做已访问标记</span></span><br><span class="line">    EnQueue(Q,v);<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isQueue(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G,v); w &gt; <span class="number">0</span>;w = NextNeighbor(Q,v,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                visited(w);<span class="comment">//访问顶点w</span></span><br><span class="line">                visitted[w] = <span class="literal">true</span>;<span class="comment">//对w做以访问标记</span></span><br><span class="line">                EnQueue(Q,w);<span class="comment">//对顶点入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ;i &lt;= G.vexnum;++i)visited[i] = <span class="literal">false</span>;<span class="comment">//访问标记数组进行初始化</span></span><br><span class="line">    InitQueue(Q);<span class="comment">//队列初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;++i)<span class="comment">//从1号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])<span class="comment">//对每一个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于无向图，调用BFS函数的次数 = 连通分量数</span></span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>空间复杂度：<strong>辅助队列为O(|V|)</strong></li><li>时间复杂度：<ul><li>邻接矩阵：<strong>O(|V|²)</strong></li><li>邻接表：<strong>O(|V| + |E|)</strong></li></ul></li></ul><h4 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h4><p>在广度遍历的过程中，我们可以得到一个遍历树，称为<strong>广度优先生成树</strong></p><ul><li><strong>同一个图的<font color='red'>邻接矩阵</font>表示方式<font color='red'>唯一</font>，因此<font color='red'>广度优先生成树唯一</font></strong></li><li><strong>同一个图的<font color='red'>邻接表</font>表示方式<font color='red'>不唯一</font>，因此<font color='red'>广度优先生成树不唯一</font></strong></li></ul><p><strong>遍历非连通图可以得到广度优先生成森林</strong></p><h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><h4 id="与树的深度优先遍历之间的联系"><a href="#与树的深度优先遍历之间的联系" class="headerlink" title="与树的深度优先遍历之间的联系"></a>与树的深度优先遍历之间的联系</h4><ul><li>先根遍历</li><li>后根遍历</li></ul><p><strong>图的深度优先遍历相似于先根遍历</strong></p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">步骤</span></span><br><span class="line"><span class="comment">        1. 找到与一个顶点相邻的所有顶点</span></span><br><span class="line"><span class="comment">           1. FirstNeighbor(G,x);</span></span><br><span class="line"><span class="comment">           2. NextNeightbor(G,x,y);</span></span><br><span class="line"><span class="comment">        2. 标记哪些顶点被访问过</span></span><br><span class="line"><span class="comment">        bool visited[MAX_VERTEX_NUM];访问标记数组</span></span><br><span class="line"><span class="comment">        3. 需要一个辅助队列</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组，从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">   visit(v);<span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//标记以访问的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G,v); w &gt; <span class="number">0</span> ;w = NextNeighbor(G.v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited(w))&#123;<span class="comment">//当w是尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理非连通图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ;i &lt;= G.vexnum;++i)visited[i] = <span class="literal">false</span>;<span class="comment">//访问标记数组进行初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;++i)<span class="comment">//从1号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])<span class="comment">//对每一个连通分量调用一次DFS</span></span><br><span class="line">            DFS(G,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>空间复杂度：<strong>O(|V|)</strong></li><li>时间复杂度：=访问各个结点所需的时间+探索各条边所需时间<ul><li>邻接矩阵：<strong>O(|V|²)</strong></li><li>邻接表：<strong>O(|V| + |E|)</strong></li></ul></li></ul><h4 id="深度优先生成树"><a href="#深度优先生成树" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h4><p>在深度遍历的过程中，我们可以得到一个遍历树，称为<strong>深度优先生成树</strong></p><ul><li><strong>同一个图的<font color='red'>邻接矩阵</font>表示方式<font color='red'>唯一</font>，因此<font color='red'>深度优先生成树唯一</font></strong></li><li><strong>同一个图的<font color='red'>邻接表</font>表示方式<font color='red'>不唯一</font>，因此<font color='red'>深度优先生成树不唯一</font></strong></li></ul><h4 id="图的遍历和图的连通性"><a href="#图的遍历和图的连通性" class="headerlink" title="图的遍历和图的连通性"></a>图的遍历和图的连通性</h4><p><strong>无向图</strong></p><ul><li>DFS/BFS函数调用次数 = 连通分量数</li></ul><p><strong>有向图</strong></p><ul><li>若从起始顶点到其他顶点都有路径，则只需调用一次DFS/BFS函数</li><li>对于强连通图，从任一顶点出发都只需调用1次DFS/BFS函数</li></ul><h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>对于一个<font color='red'>带权<strong>连通</strong>无向图</font>G = (V，E),生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中<font color='red'>边的权值之和最小的生成树</font>，则T称为G的<font color='red'>最小生成树</font>。</p><ul><li>最小生成树可能有多个，但边的权值之和总是唯一且最小的。</li><li>最小生成树的边数 = 顶点数 — 1。减少一条则不连通，增加一条边则会出现回路。</li><li>如果一个连通图本身就是一棵树，则其最小生成树就是它本身。</li><li>只有连通图才有生成树，非连通图只有生成森林。</li></ul><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><h5 id="手算操作"><a href="#手算操作" class="headerlink" title="手算操作"></a>手算操作</h5><p>从某个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p><h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p><strong>O(|V|²)，不依赖于|E|,</strong></p><p><strong>适合边稠密图</strong></p><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><h5 id="手算操作-1"><a href="#手算操作-1" class="headerlink" title="手算操作"></a>手算操作</h5><p>每次选择一条权值最小的边（可能会出现多个连通分量），使这条边的两头变通（原本<strong>已经连通</strong>的就不选），直到所有结点都连通。</p><h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p><strong>O(|E|㏒|E|)，不依赖于|V|,</strong></p><p><strong>适合边稀疏顶点多图</strong></p><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="单源对段路径"><a href="#单源对段路径" class="headerlink" title="单源对段路径"></a>单源对段路径</h4><h5 id="BFS算法（无权图）"><a href="#BFS算法（无权图）" class="headerlink" title="BFS算法（无权图）"></a>BFS算法（无权图）</h5><h6 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组，从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="comment">//d[i]表示从u到i结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        d[i] = ∞;<span class="comment">//初始化路径长度</span></span><br><span class="line">        path[i] - <span class="number">-1</span>;<span class="comment">//最短路径从那个顶点过来，也就上前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[v] = <span class="number">0</span>;<span class="comment">//到达本身的长度为0;</span></span><br><span class="line">    </span><br><span class="line">    visited[v] = <span class="literal">true</span>;<span class="comment">//对v做已访问标记</span></span><br><span class="line">    EnQueue(Q,v);<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isQueue(Q))&#123;<span class="comment">//BFS算法的主过程</span></span><br><span class="line">        DeQueue(Q,v);<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G,v); w &gt; <span class="number">0</span>;w = NextNeighbor(Q,v,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">               <span class="comment">//visit函数的内容</span></span><br><span class="line">               d[w] = d[v] +<span class="number">1</span>;<span class="comment">//路径长度加1</span></span><br><span class="line">                path[w] = w;<span class="comment">//最短路径从v到w</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                visitted[w] = <span class="literal">true</span>;<span class="comment">//对w做以访问标记</span></span><br><span class="line">                EnQueue(Q,w);<span class="comment">//对顶点入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ;i &lt;= G.vexnum;++i)visited[i] = <span class="literal">false</span>;<span class="comment">//访问标记数组进行初始化</span></span><br><span class="line">    InitQueue(Q);<span class="comment">//队列初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;++i)<span class="comment">//从1号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])<span class="comment">//对每一个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Dijkstra算法（带权图、无权图）"><a href="#Dijkstra算法（带权图、无权图）" class="headerlink" title="Dijkstra算法（带权图、无权图）"></a>Dijkstra算法（带权图、无权图）</h5><ul><li>使用邻接矩阵表示时，时间复杂度：<strong>O(|v|²)</strong></li><li><strong>Dijkstra算法并<font color='red'>不</font>适用带负权值的图</strong></li><li>算法是基于<strong>贪心策略</strong>的。</li></ul><h4 id="各顶点之间的最短路径"><a href="#各顶点之间的最短路径" class="headerlink" title="各顶点之间的最短路径"></a>各顶点之间的最短路径</h4><h5 id="Floyd算法-带权图、无权图"><a href="#Floyd算法-带权图、无权图" class="headerlink" title="Floyd算法(带权图、无权图)"></a>Floyd算法(带权图、无权图)</h5><ul><li>Floyd算法基于<strong>动态规划</strong>的思想</li></ul><h6 id="算法文字过程"><a href="#算法文字过程" class="headerlink" title="算法文字过程"></a>算法文字过程</h6><p>将问题的求解分为多个阶段</p><p>​    对于n个顶点的图G，求任意一对顶点Vi —&gt; Vj之间的最短路径可分为如下几个阶段</p><ul><li><p>初始：不允许在其他顶点终端，最短路径是？</p></li><li><p>0：若允许在V0中转，最短路径是？</p></li><li><p>1：若允许在V0、V1中转，最短路径是？</p></li><li><p>2：若允许在V0、V1、V2中转，最短路径是？</p><p>…..</p></li><li><p>n-1：若允许在V0、V1…..V(n-1)中转，最短路径是？</p></li></ul><h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">A矩阵表示从Vi——&gt;Vj的最短路径</span></span><br><span class="line"><span class="comment">path矩阵表示从Vi——&gt;Vj的最短路径需要那个中转点</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//....准备工作，根据图的信息初始化矩阵 A 和 path</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;<span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//遍历整个矩阵，i为行号。j为列号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j] &gt; A[i][k] + A[k][j])&#123;<span class="comment">//以Vk为中转点的路径最短</span></span><br><span class="line">                A[i][j] = A[i][k] + A[k][j];<span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j] = k;<span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h6><p><strong>时间复杂度：O(|V|³)</strong></p><p><strong>空间复杂度：O(|V|²)</strong></p><p><strong>Floyd允许出现图中出现有带负权值的边，但是不允许有包含带负权值的边组成的回路</strong></p><h2 id="有向无环图应用"><a href="#有向无环图应用" class="headerlink" title="有向无环图应用"></a>有向无环图应用</h2><h3 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h3><p><strong>定义：</strong>若一个<font color='red'>有向图</font>中<font color='red'>不存在环</font>，则称为有向无环图，简称<font color='red'>DAG图</font></p><h3 id="DAG描述表达式"><a href="#DAG描述表达式" class="headerlink" title="DAG描述表达式"></a>DAG描述表达式</h3><p>有向无环图是描述<font color='red'>含有公共子式</font>的表达式的有效工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">( (a+b) * ( b * ( c + d )) + ( c + d ) * e) * ((c+d) *e)</span><br><span class="line">用二叉树来表示，在树中存在一些相同的子表达式。</span><br><span class="line">使用有向无环图，可以将相同子树的父节点指向同一个子树，依次来实现对相同子式的共享，节省存储空间</span><br></pre></td></tr></table></figure><h4 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h4><p><strong>有向无环图中不存在相同的结点</strong></p><p><strong>步骤</strong></p><ol><li>把各个操作数不重复的排成一排。</li><li>标出各个运算符的生效顺序(先后顺序有点出入无所谓)，防止遗漏运算符。</li><li>按顺序加入运算符，注意“<strong><font color='red'>分层</font></strong>”。上层的运算需要以下层的运算结果来作为数值。</li><li>从底向上逐层检查<strong><font color='red'>同层</font></strong>的运算符是否可以合体（由于操作数各不相同，所以操作数不需要合并，只需要合并运算符）。</li></ol><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h4><p><strong>定义(用顶点表示活动的网):</strong><font color='red'>用DAG图(有向无环图)</font>表示一个工程。顶点表示活动，有向边&lt;Vi,Vj&gt;表示活动Vi必须先于活动Vj进行.</p><h4 id="拓扑排序定义"><a href="#拓扑排序定义" class="headerlink" title="拓扑排序定义"></a>拓扑排序定义</h4><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>手算步骤：</strong></p><ol><li>从AOV网中选择一个没有前驱(<strong><font color='red'>入度为0</font></strong>)的顶点并输出。</li><li>从网中删除该顶点和所有以它为起点的有向边。</li><li>重复①和②直到当前的<strong><font color='red'>AOV网为空</font></strong>或当<strong><font color='red'>前网中不存在无前驱的顶点为止（说明有回路）</font></strong>。</li></ol><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><h4 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h4><p><strong>步骤：</strong></p><ol><li>从AOV网中选择一个没有后继(<strong><font color='red'>出度为0</font></strong>)的顶点并输出。</li><li>从网中删除该顶点和所有以它为终点的有向边。</li><li>重复①和②直到当前的<strong><font color='red'>AOV网为空</font></strong>或当<strong><font color='red'>前网中不存在无前驱的顶点为止（说明有回路）</font></strong>。</li></ol><h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><h3 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h3><p><strong>定义：</strong>在带权有向图中，以<strong><font color='red'>顶点表示事件</font></strong>，以<strong><font color='red'>有向边表示活动</font></strong>，以<strong><font color='red'>边上的权值表示完成该活动的开销</font></strong>(如完成活动所需要的时间)，称之为用边表示活动的网络，简称<strong><font color='red'>AOE网</font></strong></p><p><strong>AOE网具有以下的两个性质:</strong></p><ol><li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li><li>只有在进入某顶点的各有向边所表示的活动都已结束时，该顶点所代表的事件才能发生。另外，<strong>有些活动是可以并行进行的</strong>。</li></ol><p>在AOE网中<strong><font color='red'>仅有一个</font></strong>入度为0的顶点，称为<strong><font color='red'>开始顶点（源点）</font></strong>，它表示整个工程的开始；</p><p>也<strong><font color='red'>仅有一个</font></strong>出度为0的顶点，称为<strong><font color='red'>结束顶点（汇点）</font></strong>，它表示整个工程的结束。</p><h3 id="关键路径概念"><a href="#关键路径概念" class="headerlink" title="关键路径概念"></a>关键路径概念</h3><p><strong>定义：</strong>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为<font color='red'>关键路径</font>，而把关键路径上的活动称为<font color='red'>关键活动</font>。</p><p>完成整个工程的最短时间就是关键路径的长度；若关键活动不能按时完成，则整个工程的完成事件就会延长</p><p><strong>概念</strong></p><ul><li><p><font color='orange'>事件Vk的<strong>最早发生</strong>时间Ve(k) </font>——决定了所有从Vk开始的活动能够开工的最早时间。</p></li><li><p><font color='red'>活动ai的最早开始时间e(i) </font>——指该活动弧的起点所表示的事件的最早发生时间。</p></li><li><p><font color='orange'>事件Vk的<strong>最迟发生</strong>时间Vl(k)</font>——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</p></li><li><p><font color='red'>活动ai的<strong>最迟开始</strong>时间l(i) </font>——指该活动弧的终点点所表示的事件的最迟发生时间与该活动所需时间之差。</p></li><li><p><font color='red'>活动ai的<strong>时间余量d(i) = l(i) - e(i)</strong></font>,表示在不增加完成整个工程所需总时间的情况下，活动ai可以拖延的时间</p><p>若一个活动的时间余量为<strong>零</strong>，则说明该活动必须要如期完成，d(i) = 0或 l(i) = e(i) 的活动ai是<strong><font color='red'>关键活动</font></strong>。</p><p>由<strong><font color='red'>关键活动</font></strong>组成的路径叫做<strong><font color='red'>关键路径</font></strong></p></li></ul><h3 id="求关键路径的步骤"><a href="#求关键路径的步骤" class="headerlink" title="求关键路径的步骤"></a>求关键路径的步骤</h3><ol><li><p>求所有事件的最早发生事件ve();</p><p>按<strong><font color='red'>拓扑排序</font></strong>序列，依次求各个顶点的Ve(k)：</p><p>​    Ve(源点) = 0；</p><p>​    Ve(k) = Max{Ve(j) + Weight(Vj , Vk)}，Vj为Vk的任意前驱，Weight(Vj , Vk)表示从&lt;Vj , Vk&gt;的权值</p></li><li><p>求所有事件的最迟发生事件Vl();</p><p>按<strong><font color='red'>逆拓扑排序</font></strong>序列,依次求各个顶点的Vl(k):</p><p>​    Vl(汇点) = Ve(汇点)；</p><p>​    Vl(k) = Min{ Vl( j ) - Weight(Vj,Vk)} ，Vj为Vk的任意后继。</p></li><li><p>求所有活动的最早发生事件e();</p><p>e(i) = Ve(k);</p></li><li><p>求所有活动的最迟发生时间 l();</p><p>l(i) = Vl( i ) - Weight(Vk,Vj);</p></li><li><p>求所有活动的时间余量d();——<strong><font color='red'>d(i) = 0的活动就是关键路径，由关键活动可得到关键路径</font></strong>.</p><p>d( i ) = e( i ) - l( i );</p></li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>若关键活动耗时增加，则整个工程的工期将增长。</li><li>缩短关键活动的时间，可以缩短整个工程的工期。</li><li>当缩短到一定程度时，关键活动可能会变成非关键活动。</li><li>可能由多条关键路径，只提高一条关键路径上的关键活动并不能缩短整个工程的工期，只有<strong>加快那些包括在所有关键路径上的关键活动</strong>才能达到缩短工期的目的。</li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/ee040603/#disqus_thread</comments>
    </item>
    
    <item>
      <title>树</title>
      <link>http://yoursite.com/posts/7b216a3b/</link>
      <guid>http://yoursite.com/posts/7b216a3b/</guid>
      <pubDate>Sat, 21 Aug 2021 12:24:54 GMT</pubDate>
      <description>
      
        树的基本概念，二叉排序树、平衡二叉树的概念以及操作、哈夫曼树的概念以及哈夫曼编码
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><ul><li>空树：结点数为0的树</li><li>非空树的特性<ul><li>有且仅有一个根节点</li><li>没有后继的结点称为“叶子结点”，（或终端结点）</li><li>有后继的结点称为“分支结点‘  （或非终端结点）</li><li>除了根节点之外，任何一个结点都<font color='red'>有且仅有一个前驱</font></li><li>每个结点可有0个或者多个后继。没有后继的结点叫做叶子结点</li></ul></li><li>当n&gt;1时，其余结点可分为m( m &gt; 0)个<font color='red'>互不相交的有限集合</font>，其中每个集合本身又是一棵树，并且称为根节点的<strong><font color='red'>子树。</font></strong></li><li>树是一种<strong><font color='red'>递归定义</font></strong>的数据结构</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="结点之间的关系描述"><a href="#结点之间的关系描述" class="headerlink" title="结点之间的关系描述"></a>结点之间的关系描述</h4><ul><li>祖先结点：从该结点出发，前驱及其前驱上面的所有结点都是该结点的祖先节点。</li><li>子孙结点：从该结点出发，后继及其后继下面的所有结点都是该结点的子孙结点。</li><li>双亲结点（父节点）：该节点的直接前驱就是父节点。</li><li>孩子结点：该节点的直接后继就是该节点的孩子结点</li><li>兄弟结点：父节点的所有后继节点（除本结点）称为该节点的兄弟结点。</li><li>路径：<font color='red'>只能从上往下</font></li><li>路径长度：经过了几条边。</li></ul><h4 id="结点、树的属性描述"><a href="#结点、树的属性描述" class="headerlink" title="结点、树的属性描述"></a>结点、树的属性描述</h4><p><strong>属性</strong></p><ul><li>结点的层次（深度）——从上往下数，<strong><font color='red'>默认从1开始</font></strong></li><li>结点的高度——从下往上数</li><li>数的高度——总共多少层</li><li>结点的度——有几个孩子（分支）</li><li>树的度：树种结点的最大度称为树的度。</li></ul><p><strong>有序树：</strong>从逻辑上看，树中结点的各子树<strong><font color='red'>从左至右是有次序的</font></strong>，不能互换。</p><p><strong>无序树：</strong>从逻辑上看，树中结点的各子树<strong><font color='red'>从左至右是无次序的</font></strong>，可以互换。</p><p><strong>森林：</strong>m( m &gt; 0 )颗互不相交的树的集合。</p><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><ul><li><strong>树中的结点等于所有结点的度数之和加1。</strong></li><li><strong>度为m的树中上之多有m^(i - 1)个结点。</strong></li><li><strong>高度为h的m叉树至多有(m^(h) - 1) / (m - 1)</strong></li><li><strong>具有n个结点的m叉树的最小高度为㏒(m)(n(m - 1) + 1){向上取整}</strong></li></ul><p>树的度与m叉树的区别</p><ul><li>树的度为m：<ul><li>任意结点的度 ≤ m (最多m个孩子)</li><li>各个结点的度的最大值，至少有一个结点度 = m</li><li>一定是非空树，至少有m+1个结点</li></ul></li><li>m叉树：<ul><li>任意结点的度 ≤ m（最多m个孩子）</li><li>允许所有结点的度 ≤ m，不一定存在一个结点度 = m。</li><li>可以是空树</li></ul></li></ul><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法-顺序存储"><a href="#双亲表示法-顺序存储" class="headerlink" title="双亲表示法(顺序存储)"></a>双亲表示法(顺序存储)</h4><p><strong>定义</strong>：这种存储方式采用一组<strong>连续空间</strong>来存储每个结点，每个结点中保存指向双亲的“指针“。</p><ul><li><strong>优点：</strong>查指定结点的双亲很方便</li><li><strong>缺点：</strong>查找指定结点的孩子只能从头遍历</li></ul><p><strong>与二叉树的顺序存储对比</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来。</span><br><span class="line">结点编号不仅反应了存储位置，也隐含了结点之间的逻辑关系</span><br><span class="line"></span><br><span class="line">而树的顺序存储结构中，数组下标仅仅代表结点的编号，下标中所存的内容指示了结点之间的关系。</span><br></pre></td></tr></table></figure><p><strong>存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100<span class="comment">//树中最多结点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    <span class="keyword">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;<span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure><h4 id="孩子表示法-顺序-链式存储"><a href="#孩子表示法-顺序-链式存储" class="headerlink" title="孩子表示法(顺序+链式存储)"></a>孩子表示法(顺序+链式存储)</h4><p><strong>定义：</strong>将每个结点的孩子结点都用<font color='red'>单链表</font>连接起来形成一个线性结构，也就是一共有n个孩子链表，叶子结点的链表围为空链表</p><ul><li><strong>优点：</strong>寻找子结点很直接</li><li><strong>缺点：</strong>查询父节点需要遍历n个结点的孩子链表</li></ul><p><strong>存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100<span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;<span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span><span class="comment">//下一次孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span><span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n,r;<span class="comment">//结点树和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure><h4 id="孩子兄弟表示法-链式存储"><a href="#孩子兄弟表示法-链式存储" class="headerlink" title="孩子兄弟表示法(链式存储)"></a>孩子兄弟表示法(链式存储)</h4><p><strong>定义：</strong>每个结点包括三部分(结点值、指向结点的第一个孩子结点的指针、指向结点下一个兄弟结点的指针)</p><ul><li><strong>优点：</strong>方便的实现树转换为二叉树的操作，易于查询结点的孩子等</li><li>从当前结点查询其窗前结点比较麻烦<ul><li>为此我们可以每个结点增加一个父节点域指向父节点。</li></ul></li></ul><p><strong>存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span><span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><h4 id="树—-gt-二叉树"><a href="#树—-gt-二叉树" class="headerlink" title="树—&gt;二叉树"></a>树—&gt;二叉树</h4><p><strong>规则</strong>：每个结点左指针指向它的第一个孩子，右指针指向它在树种的相邻右兄弟，=》<strong>左孩子右兄弟</strong></p><p><strong>画法</strong></p><ol><li>在兄弟节点之间加一连线。</li><li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉</li><li>以树根为轴心，顺时针旋转45°</li></ol><h4 id="森林—-gt-二叉树"><a href="#森林—-gt-二叉树" class="headerlink" title="森林—&gt;二叉树"></a>森林—&gt;二叉树</h4><p><strong>规则：</strong>先把森林中的每棵树转换成二叉树，由于任何一颗和树对应的二叉树的右子树必空，所有将第二课树视为第一棵树的右兄弟，第三棵树视为第二棵树的右兄弟…</p><p><strong>画法</strong></p><ol><li>将森林中的每棵树转换成对应的<strong>孩子兄弟表示法</strong>二叉树</li><li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根线</li><li>以第一棵树的轴心顺时针旋转45°</li></ol><h3 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h3><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><h5 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h5><p><strong>定义：</strong>若树非空，先访问根节点，再依次对每颗子树进行先根遍历</p><p><strong><font color='orange'>树的先根遍历序列与这棵树相应二叉树的<font color='red'>先</font>序序列相同</font></strong></p><h5 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h5><p><strong>定义：</strong>若树非空，先依次对每颗子树进行后根遍历，最后访问根节点。</p><p><strong><font color='orange'>树的后根遍历序列与这棵树相应二叉树的<font color='red'>中</font>序序列相同</font></strong></p><h5 id="层序遍历-队列实现"><a href="#层序遍历-队列实现" class="headerlink" title="层序遍历(队列实现)"></a>层序遍历(队列实现)</h5><ol><li>若树非空，则根结点入队</li><li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li><li>重复步骤2直到队列为空</li></ol><h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p><strong>就是各树的先根遍历</strong></p><p>若森林非空，则按如下规则进行遍历：</p><ol><li>访问僧林中第一棵树的根节点</li><li>先序遍历第一棵树中根节点的子树森林</li><li>先序遍历除去第一棵树之后剩余的树构成的森林。</li></ol><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p><strong>就是各个树的后根遍历</strong></p><p>若森林非空，则按如下规则进行遍历：</p><ol><li>中序遍历第一棵树中根节点的子树森林</li><li>访问僧林中第一棵树的根节点</li><li>中序遍历除去第一棵树之后剩余的树构成的森林。</li></ol><h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>二叉树是n(n ≥ 0)个结点的有限集合</p><ul><li>或者为<font color='red'>空二叉树</font>，即n = 0；</li><li>或者由一个<font color='red'>根节点</font>和两个互不相交的被称为根的<font color='red'>左子树</font>和<font color='red'>右子树</font>组成。左子树和右子树右分别是一颗二叉树</li><li>特点<ul><li>每个结点至多只有两颗子树。</li><li>左右子树不能颠倒（二叉树是<font color='red'>有序树</font>）。</li></ul></li></ul><h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><strong>定义：</strong>一个高度为h，且含有2∧(h) - 1个结点的二叉树。</p><p><strong>特点</strong></p><ol><li>只有最后一层有叶子节点</li><li>不存在度为1的结点</li><li>按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为 i /2{向下取整}(如果有的话)</li></ol><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><strong>定义:</strong>当且仅当<strong>其每个结点都与高度h的满二叉树中编号1~n的结点一一对应</strong>时，称为完全二叉树。</p><p><strong>特点</strong></p><ol><li><p>只有最后两层可能有叶子结点。</p></li><li><p><strong>最多只有一个度为1的结点，且该结点只有左孩子而无右孩子</strong>。</p></li><li><p>按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为 i /2{向下取整}(如果有的话)</p></li><li><p>i ≤ (n / 2){向下取整}为分支结点， i &gt;  (n / 2){向下取整}为分支结点</p></li><li><p>若n为<strong>奇数</strong>，则每个分支结点都有左孩子和右孩子；</p><p>若n为<strong>偶数</strong>，则最大编号的分支节点（编号为 ( n / 2 ) ）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</p></li></ol><h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p><strong>定义：</strong>一颗二叉树或者是空二叉树，或者具有如下性质的二叉树：</p><ul><li><strong><font color='red'>左子树</font></strong>上所有的结点的<strong><font color='orange'>关键字</font></strong>均<strong><font color='orange'>小于根节点</font></strong>的关键字。</li><li><strong><font color='red'>右子树</font></strong>上所有的结点的<strong><font color='orange'>关键字</font></strong>均<strong><font color='orange'>大于根节点</font></strong>的关键字。</li><li>左子树和右子树又各是一颗二叉排序树。</li></ul><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><strong>定义：</strong>树上任一结点的<font color='orange'>左子树</font>和<font color='orange'>右子树</font>的<font color='orange'>深度之差不超过1</font>.</p><h3 id="常考性质"><a href="#常考性质" class="headerlink" title="常考性质"></a>常考性质</h3><h4 id="考点一"><a href="#考点一" class="headerlink" title="考点一"></a>考点一</h4><p> <strong>设非空二叉树中度为0，1和2的结点个数分别由n0，n1和n2，则<font color='red'>n0 = n2 +1</font>(叶子结点比二分支结点多一个)</strong></p><p><strong>证明</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">假设树中结点总数为n，则</span><br><span class="line">1、n &#x3D; n0 + n1 + n2</span><br><span class="line">2、n &#x3D; n1 + 2n2 + 1</span><br><span class="line">&#x3D;&#x3D;&gt; n0 &#x3D; n2 +1</span><br></pre></td></tr></table></figure><h4 id="考点二"><a href="#考点二" class="headerlink" title="考点二"></a>考点二</h4><p><strong>二叉树中第i层上之多有2^(i - 1)个结点。</strong></p><h4 id="靠点三"><a href="#靠点三" class="headerlink" title="靠点三"></a>靠点三</h4><p><strong>高度为h的二叉树至多有2^(h) - 1（满二叉树）</strong></p><h4 id="考点四"><a href="#考点四" class="headerlink" title="考点四"></a>考点四</h4><p><strong>对于完全二叉树，可以由的结点数n推出度为0、1、2的结点数为n0、n1和n2</strong></p><p><strong>推论</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">完全二叉树最多只有一个度为1的结点，即 n1 &#x3D; 0 或 1</span><br><span class="line">由考点一得出 n0 &#x3D; n2 + 1</span><br><span class="line">所有 n0 + n2 &#x3D; 2n2 + 1 &#x3D;&gt;奇数</span><br><span class="line">当完全二叉树有2k个(偶数)个结点，则必有  n1 &#x3D; 1,n0 &#x3D; k,n2 &#x3D; k-1</span><br><span class="line">当完全二叉树有2k+1个(奇数)个结点，则必有 n1 &#x3D; 0; n0 &#x3D; k + 1;n2 &#x3D; k</span><br></pre></td></tr></table></figure><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><ul><li>顺序存储适合使用在<strong>完全二叉树或者满二叉树</strong></li><li>把二叉树的结点编号与完全二叉树对应起来</li></ul><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty;<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];</span><br><span class="line"><span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下，从左至右的顺序依次存储 完全二叉树或者满二叉树 中的各个节点</span></span><br></pre></td></tr></table></figure><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchidld</span>,*<span class="title">rchild</span>;</span><span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><ul><li>n个结点的二叉链表有<strong>n+1</strong>个空指针域</li></ul><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><strong>遍历：</strong>按照某种次序把所有结点都访问一遍。</p><p><strong>三种遍历方式：</strong>(序：按照根结点在何时被访问)</p><ul><li>先序遍历(NLR)</li><li>中序遍历(LNR)</li><li>后序遍历(LRN)</li></ul><h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><strong>步骤</strong></p><ul><li>若二叉树为空，则什么都不做</li><li>若二叉树非空，则<ol><li>访问根节点</li><li>访问左子树</li><li>访问右子树</li></ol></li></ul><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);<span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(n)</strong></li><li><strong>空间复杂度：O(h)</strong></li></ul><h3 id="中序遍历-LNR"><a href="#中序遍历-LNR" class="headerlink" title="中序遍历(LNR)"></a>中序遍历(LNR)</h3><p><strong>步骤</strong></p><ul><li>若二叉树为空，则什么都不做</li><li>若二叉树非空，则<ol><li>访问左子树</li><li>访问根节点</li><li>访问右子树</li></ol></li></ul><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);<span class="comment">//访问根节点</span></span><br><span class="line">        InOrder(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(n)</strong></li><li><strong>空间复杂度：O(h)</strong></li></ul><h3 id="后序遍历-LRN"><a href="#后序遍历-LRN" class="headerlink" title="后序遍历(LRN)"></a>后序遍历(LRN)</h3><p><strong>步骤</strong></p><ul><li>若二叉树为空，则什么都不做</li><li>若二叉树非空，则<ol><li>访问左子树</li><li>访问右子树</li><li>访问根节点</li></ol></li></ul><p><strong>实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PostOrder(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：O(n)</strong></li><li><strong>空间复杂度：O(h)</strong></li></ul><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ol><li>初始化一个辅助<font color='orange'>队列</font></li><li>根节点入队</li><li>若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话)。</li><li>重复3直至队列为空。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LinkQueue Q;<span class="comment">//链队列</span></span><br><span class="line">    InitQueue(Q);<span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);<span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;<span class="comment">//队列不空则循环</span></span><br><span class="line">        DeQueue(Q,p);<span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);<span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchirld);<span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q.p-&gt;rchild);<span class="comment">//右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历序列构造二叉树"><a href="#遍历序列构造二叉树" class="headerlink" title="遍历序列构造二叉树"></a>遍历序列构造二叉树</h3><ul><li><p>对于不同的二叉树，使用中序遍历，可能得到一个相同的中序遍历序列。</p><p><strong>若只是给出一颗二叉树的前/中/后/层    序遍历序列中的一种，不能唯一确定一颗二叉树。</strong></p></li></ul><p><strong>确定唯一的二叉树的三种方法序列组合</strong></p><ul><li>前序 + 中序 遍历序列</li><li>后序 + 中序 遍历序列</li><li>层序 + 中序 遍历序列</li></ul><h4 id="前序-中序-遍历序列"><a href="#前序-中序-遍历序列" class="headerlink" title="前序 + 中序 遍历序列"></a>前序 + 中序 遍历序列</h4><ul><li>前序遍历序列： <strong>根节点</strong>         <font color='red'>左子树的前序遍历序列</font>        <font color='orange'>右子树的前序遍历序列</font></li><li>中序遍历序列：  <font color='red'>左子树的中序遍历序列</font>         <strong>根节点</strong>        <font color='orange'>右子树的中序遍历序列</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg:</span><br><span class="line">前序:A D B C E</span><br><span class="line">中序:B D C A E  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、由于前序遍历序列第一个出现的结点肯定是根节点，所有可以根据前序遍历序列确定根节点A</span><br><span class="line">2、在中序遍历序列中，A结点左边的结点就是左子树的结点(B D C)，A结点右边的结点就是右子树的结点(E)</span><br><span class="line">前序遍历序列中左子树(D B C),右子树的结点(E)</span><br><span class="line">3、对于左、右子树重复1、2步骤</span><br><span class="line">确定D为根节点，B是左子树，C是右子树</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h4 id="后序-中序-遍历序列"><a href="#后序-中序-遍历序列" class="headerlink" title="后序 + 中序 遍历序列"></a>后序 + 中序 遍历序列</h4><ul><li><p>后序遍历序列： <font color='red'>左子树的前序遍历序列</font>        <font color='orange'>右子树的前序遍历序列</font>        <strong>根节点</strong> </p></li><li><p>中序遍历序列：  <font color='red'>左子树的中序遍历序列</font>         <strong>根节点</strong>        <font color='orange'>右子树的中序遍历序列</font></p><pre><code>eg:后序:    A D B C E中序:    B D C A E 1、由于后序遍历序列最后一个出现的结点肯定是根节点，所有可以根据后序遍历序列确定根节点E2、在中序遍历序列中，E结点左边的结点就是左子树的结点(B D C A)，E结点右边的结点就是右子树的结点()    后序遍历序列中左子树(A D B C),右子树的结点()3、对于左、右子树重复1、2步骤    确定C为根节点，(B D)是左子树，A是右子树    ……</code></pre></li></ul><h4 id="层序-中序-遍历序列"><a href="#层序-中序-遍历序列" class="headerlink" title="层序 + 中序 遍历序列"></a>层序 + 中序 遍历序列</h4><ul><li>层序遍历序列： <strong>根节点</strong>    <font color='red'>左子树的根</font>        <font color='orange'>右子树的根</font></li><li>中序遍历序列：  <font color='red'>左子树的中序遍历序列</font>         <strong>根节点</strong>        <font color='orange'>右子树的中序遍历序列</font></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">eg</span><br><span class="line">层序:D A B E F C G H I</span><br><span class="line">中序:E A F D H C B G I</span><br><span class="line"></span><br><span class="line">1、由于层序遍历序列第一个出现的结点肯定是根节点，所有可以根据层序遍历序列确定根节点D</span><br><span class="line">2、在中序遍历序列中，D结点左边的结点就是左子树的结点(E A F)，D结点右边的结点就是右子树的结点(H C B G I)</span><br><span class="line">3、第二层的左子树根节点是A，右子树的根节点是B</span><br><span class="line">在中序遍历序列中，A结点左边的结点就是左子树的结点(E)，A结点右边的结点就是右子树的结点(F)</span><br><span class="line">在中序遍历序列中，B结点左边的结点就是左子树的结点(H C)，B结点右边的结点就是右子树的结点(G I)</span><br><span class="line">4、第三层的根节点E F C G </span><br><span class="line">……</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>作用</strong>：引入线索二叉树是为了<strong>加快查找结点的结点前驱和后继的速度。</strong></p><h4 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h4><ul><li><strong>线索：</strong>指向前驱、后继的指针称为“线索”。</li><li><strong>线索化：</strong>将一个二叉链表的空指针指向遍历序列的前驱和后继。</li></ul><h4 id="三种线索二叉树"><a href="#三种线索二叉树" class="headerlink" title="三种线索二叉树"></a>三种线索二叉树</h4><ul><li><strong>中序线索二叉树：</strong>以中序遍历序列为依据进行“线索化‘。</li><li><strong>先序线索二叉树：</strong>以先序遍历序列为依据进行“线索化‘。</li><li><strong>后序线索二叉树：</strong>以后序遍历序列为依据进行“线索化‘。</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>存储结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;<span class="comment">//左右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">tag == 1 表示指针指向的是“线索”</span></span><br><span class="line"><span class="comment">tag == 0 表示指针指向的是孩子</span></span><br><span class="line"><span class="comment">ltag:</span></span><br><span class="line"><span class="comment">0：lchild域指向结点的左孩子</span></span><br><span class="line"><span class="comment">1：lchild域指向结点的前驱</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">rtag:</span></span><br><span class="line"><span class="comment">0：rchild域指向结点的右孩子</span></span><br><span class="line"><span class="comment">1：rchild域指向结点的后继</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><h3 id="手算画出线索二叉树"><a href="#手算画出线索二叉树" class="headerlink" title="手算画出线索二叉树"></a>手算画出线索二叉树</h3><ol><li>确定线索二叉树的类型——中序、先序、后序</li><li>按照对应遍历规则，确定各个节点的访问顺序，并写上编号</li><li>将 n+1 个空链域连上前驱、后继。</li></ol><h3 id="线索二叉树构造"><a href="#线索二叉树构造" class="headerlink" title="线索二叉树构造"></a>线索二叉树构造</h3><h4 id="中序线索二叉树的构造-代码"><a href="#中序线索二叉树的构造-代码" class="headerlink" title="中序线索二叉树的构造(代码)"></a>中序线索二叉树的构造(代码)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对结点进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadNode</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;rchild = pre;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        p-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild,pre);<span class="comment">//递归，线索化左二叉树</span></span><br><span class="line">        ThreadNode(p,&amp;pre);</span><br><span class="line">        InThread(p-&gt;rchild,pre);<span class="comment">//递归，线索化右二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;<span class="comment">//非空二叉树、线索化</span></span><br><span class="line">        InThread(T,pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="comment">//处理遍历的最后的一个结点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里不需要判断是否该结点是否还有右孩子、因为该结点是遍历序列中的最后一位，因为中序遍历是左中右，</span></span><br><span class="line"><span class="comment">        当该结点有右孩子时，按照中序遍历的规定，该结点就不是序列中的最后一位。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="先序线索二叉树的构造-代码"><a href="#先序线索二叉树的构造-代码" class="headerlink" title="先序线索二叉树的构造(代码)"></a>先序线索二叉树的构造(代码)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对结点进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadNode</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;rchild = pre;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        p-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        ThreadNode(p,&amp;pre);</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">        <span class="comment">//这里如果判断，可能出现死循环</span></span><br><span class="line">        <span class="comment">//当p的左孩子指针指向前驱的时候，我们再继续递归遍历，就有回到前驱结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        PreThread(p-&gt;lchild,pre);<span class="comment">//递归，线索化左二叉树</span></span><br><span class="line">        PreThread(p-&gt;rchild,pre);<span class="comment">//递归，线索化右二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;<span class="comment">//非空二叉树、线索化</span></span><br><span class="line">        PreThread(T,pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="comment">//处理遍历的最后的一个结点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里不需要判断是否该结点是否还有右孩子、因为该结点是遍历序列中的最后一位，因为先序遍历是中左右，</span></span><br><span class="line"><span class="comment">        当该结点有右孩子时，按照先序遍历的规定，该结点就不是序列中的最后一位。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序线索二叉树的构造-代码"><a href="#后序线索二叉树的构造-代码" class="headerlink" title="后序线索二叉树的构造(代码)"></a>后序线索二叉树的构造(代码)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对结点进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadNode</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;rchild = pre;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        p-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostThread(p-&gt;lchild,pre);<span class="comment">//递归，线索化左二叉树</span></span><br><span class="line">        PostThread(p-&gt;rchild,pre);<span class="comment">//递归，线索化右二叉树</span></span><br><span class="line">        ThreadNode(p,&amp;pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;<span class="comment">//非空二叉树、线索化</span></span><br><span class="line">        PostThread(T,pre);<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="comment">//处理遍历的最后的一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild = <span class="literal">NULL</span>;)</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h4><ul><li>最后一个结点rchild、rtag的处理</li><li>先序线索化中，注意处理死循环的问题，当ltag == 0时，才能最左子树先序线索化。</li></ul><h3 id="线索二叉树中查找前驱、后继"><a href="#线索二叉树中查找前驱、后继" class="headerlink" title="线索二叉树中查找前驱、后继"></a>线索二叉树中查找前驱、后继</h3><h4 id="中序二叉树"><a href="#中序二叉树" class="headerlink" title="中序二叉树"></a>中序二叉树</h4><h5 id="查找后继"><a href="#查找后继" class="headerlink" title="查找后继"></a>查找后继</h5><p>在中序线索二叉树中找到指定结点*p的中序后继 next</p><ul><li>若 p -&gt; rtag == 1,则 next = p -&gt;rchild</li><li>若 p -&gt; rtag == 0,则右子树中最左下的结点就是后继结点next</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到以p为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最左下结点(不一定是叶子结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)p = p-&gt;lchile;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="查找前驱"><a href="#查找前驱" class="headerlink" title="查找前驱"></a>查找前驱</h5><p>在中序线索二叉树中找到指定结点*p的中序前驱 pre</p><ul><li>若 p -&gt; ltag == 1,则 next = p -&gt;lchild</li><li>若 p -&gt; ltag == 0,则左子树中最右下的结点就是前驱结点 pre</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到以p为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Lastnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最右下结点(不一定是叶子结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)p = p-&gt;rchile;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h2><p><strong>定义</strong></p><p>一颗二叉树或者<strong>是空二叉树</strong>，或者<strong>是具有如下性质的二叉树</strong>：</p><ol><li><p>左子树所有的关键字均小于根结点的关键字</p></li><li><p>右子树所有的关键字均大于根结点的关键字</p></li><li><p>左子树和右子树又各是一棵二叉排序树</p><p><strong><font color='orange'>左子树结点值 &lt;  根结点值 &lt; 右子树结点值</font></strong></p></li></ol><p><strong>中序遍历序列，可以得到一个递增的有序序列</strong></p><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉排序树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode,*BSTree</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><ul><li>规则<ol><li>若树非空，目标值与根节点的值比较</li><li>若相等，则查找成功</li><li>若小于根节点，则在左子树上查找，否则就在右子树上查找</li><li>查找成功，返回结点指针；失败返回NULL;</li></ol></li><li>代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点(非递归实现)</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;key)&#123;<span class="comment">//若树空或者等于根节点值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;key)<span class="comment">//小于，则在左子树上查找</span></span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//大于，则在右子树上查找</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏时间复杂度：O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点(递归实现)</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BSTSearch</span><span class="params">(BSTree T,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">       <span class="keyword">return</span> T;<span class="comment">//查找失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;<span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);<span class="comment">//在左子树中找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);<span class="comment">//在右子树中找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏时间复杂度：O(h)</span></span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><ul><li>规则<ol><li>若原二叉排序树为空，则直接插入结点。</li><li>若原二叉排序树中已经存在该值的结点，则不插入。</li><li>若关键字k小于根节点值，则插入到左子树。</li><li>若关键字k大于根节点值，则插入到右子树。</li></ol></li><li>代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树插入关键字为k的新节点(递归实现)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;<span class="comment">//原树为空，新插入的结点为根节点</span></span><br><span class="line">    T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild = <span class="literal">NULL</span>; </span><br><span class="line">        T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//返回1.则插入成功</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;key)&#123;<span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)&#123;<span class="comment">//插入到T的左子树</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//插入到T的右子树</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>构造</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat_BST</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> str[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    T = <span class="literal">NULL</span>;<span class="comment">//初始化T为空树</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;<span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        BST_Insert(T.str[i]);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同一组关键字的不同序列可能得到同款二叉排序树，也可能得到不同款二叉排序树</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1、被删结点为叶子，直接删除</span><br><span class="line">2、被删结点只有左或只有右子树，用其子树顶替其位置</span><br><span class="line">3、被删结点有左、右子树</span><br><span class="line">A.可用其后继结点顶替，再删除后继结点</span><br><span class="line">a.后继：右子树最左下的结点</span><br><span class="line">B.可用其前驱节点顶替，再删除前驱结点</span><br><span class="line">b.前驱：左子树中最右下的结点</span><br></pre></td></tr></table></figure><h3 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h3><p><strong>查找长度：</strong>在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度。</p><p>若树高h，找到最下层的一个结点需要对比h次。</p><ul><li><strong>最好情况：</strong>n各结点的二叉树最小高度为   <strong>{㏒(2)(n)}[向下取整]+1</strong></li><li><strong>最坏情况：</strong>每个结点只有一个分支，树高h=结点数n，平均查找高度 = O(n)</li></ul><p><strong>查找成功平均查找长度</strong></p><p><strong>查找失败平均查找长度</strong></p><h2 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>定义：</strong>简称平衡树(<strong>AVL树</strong>)，树上任一结点的左子树和右子树的高度之差不超过1.</p><p><strong><font color='red'>结点的平衡因子 </font>= 左子树高 - 右子树高。</strong></p><p>平衡二叉树的平衡因子的值 只可能是 ”-1“、”0“、”1“。</p><h3 id="如何保持平衡"><a href="#如何保持平衡" class="headerlink" title="如何保持平衡"></a>如何保持平衡</h3><p>在二叉排序树中插入新结点后，如何保持平衡</p><ul><li>从插入点往回找到第一个不平衡结点，调整以该结点为根的子树————<font color='red'>最小不平衡子树</font>。</li></ul><p><strong>目标</strong></p><ul><li>恢复平衡</li><li>保持二叉排序树特性<ul><li>左子树结点值 &lt; 根节点值 &lt; 右子树结点值</li></ul></li></ul><h4 id="调整最小不平衡子树"><a href="#调整最小不平衡子树" class="headerlink" title="调整最小不平衡子树"></a>调整最小不平衡子树</h4><ul><li><strong>只有左孩子才能右上旋</strong></li><li><strong>只有右孩子才能左上旋</strong></li></ul><h5 id="LL-在A的左孩子的左子树中插入导致不平衡"><a href="#LL-在A的左孩子的左子树中插入导致不平衡" class="headerlink" title="LL(在A的左孩子的左子树中插入导致不平衡)"></a>LL(在A的左孩子的左子树中插入导致不平衡)</h5><p>*<em>BL &lt; B &lt; BR &lt; A &lt; AR *</em></p><p><strong>操作(右单旋转)</strong>：由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的左孩子<font color='orange'>B向右上旋转</font>代替A成为根节点，将<font color='orange'>A结点向右下旋</font>成为B的右孩子的根节点，<font color='red'>而B的<strong>原右</strong>子树则作为A结点的<strong>左</strong>子树。</font></p><h5 id="RR-在A的右孩子的右子树中插入导致不平衡"><a href="#RR-在A的右孩子的右子树中插入导致不平衡" class="headerlink" title="RR(在A的右孩子的右子树中插入导致不平衡)"></a>RR(在A的右孩子的右子树中插入导致不平衡)</h5><p>*<em>AL &lt; A &lt; BL &lt; B &lt; BR  *</em></p><p><strong>操作(左单旋转)</strong>：由于在结点A的右孩子(R)的左子树(R)上插入了新结点，A的平衡因子由-1增至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将A的右孩子<font color='orange'>B向左上旋转</font>代替A成为根节点，将<font color='orange'>A结点向左下旋</font>成为B的左孩子的根节点，而<font color='red'>B的<strong>原左</strong>子树则作为A结点的<strong>右</strong>子树</font>。</p><h5 id="LR-在A的左孩子的右子树中插入导致不平衡"><a href="#LR-在A的左孩子的右子树中插入导致不平衡" class="headerlink" title="LR(在A的左孩子的右子树中插入导致不平衡)"></a>LR(在A的左孩子的右子树中插入导致不平衡)</h5><p><strong>BL &lt; B &lt; CL &lt; C &lt; CR &lt; A &lt; AR</strong></p><p><strong>操作(先左后右双旋转)：</strong>由于在A的左孩子(L)的右孩子(R)上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行<font color='cornflowerblue'>两次旋转操作</font>，先左旋(C)后右旋转(C).先将A结点的左孩子(B)的右子树的<strong>根结点(C)向左上旋转</strong>提升到B结点的位置，然后再把<strong>该结点C向右上旋转</strong>提升到A结点的位置。</p><h5 id="RL-在A的右孩子的左子树中插入导致不平衡"><a href="#RL-在A的右孩子的左子树中插入导致不平衡" class="headerlink" title="RL(在A的右孩子的左子树中插入导致不平衡)"></a>RL(在A的右孩子的左子树中插入导致不平衡)</h5><p><strong>AL &lt; A &lt; CL &lt; C &lt; CR &lt; B &lt; BR</strong></p><p><strong>操作(先右后左双旋转)：</strong>由于在A的右孩子(R)的左子树(L)上插上新结点，A的平衡因子由-1到-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，<font color='cornflowerblue'>先右旋转后左旋转</font>。先将A结点的右孩子B的左子树的根节点<strong><font color='orange'>C向右上旋转提升至B结点的位置</font></strong>,然后再把该<strong><font color='orange'>C结点想左上旋转提升到A结点的位置</font></strong></p><h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> balance;<span class="comment">//平衡因子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><h3 id="查找效率分析-1"><a href="#查找效率分析-1" class="headerlink" title="查找效率分析"></a>查找效率分析</h3><p>假设以n(h)表示深度h的平衡树中含有的<strong>最少结点</strong>数：</p><p>则有n(0) = 0，n(1) = 1 , n(2) = 2 ,并且有 <strong>n(h) = n(h-1) + n(h-2) +1</strong>  , </p><p>若结点数为n，则<strong>h(max) = O(㏒n);</strong></p><p>时间复杂度：<strong>O(㏒n);</strong></p><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>结点的<font color='orange'>权</font>：</strong>有某种现实含义的数值。</p><p><strong><font color='orange'>结点的带权路径长度</font>：</strong>从树的根到该结点的<strong>路径长度</strong>(经过的边数)与该结点上<strong>权值</strong>的<strong>乘积</strong>。</p><p><strong><font color='orange'>树的带权路径长度</font>：</strong>树中所有<strong><font color='red'>叶节点</font></strong>的带权路径长度之和。</p><p><strong>定义：</strong>在含有n个带权叶节点的二叉树中，其中<strong><font color='orange'>带权路径长度(WPL)最小的二叉树</font></strong>称为<strong><font color='red'>哈夫曼树</font></strong>，也称<strong><font color='red'>最优二叉树</font>。</strong></p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>对于给定n个权值分别为w(1),w(2),w(3),…,w(n)的结点，构造哈夫曼树的算法描述如下：</p><ol><li>将这n个结点分别作为n棵树仅含一个结点的二叉树，构造森林F。</li><li>构造一个新结点，从F中选取<strong>两颗根结点权值最小</strong>的树做为新结点的左、右子树，并将<strong>新结点的权值</strong>置为左、右子树上根结点的权值之和。</li><li>从F从删除刚才选出的两棵树，同时将新得到的树加入F中。</li><li>重复步骤2、3，直至F中只剩下一棵树为止。</li></ol><p><strong>性质</strong></p><ul><li>每个初始结点最终都成为叶节点，且权值越小的结点到根结点的路径长度越大。</li><li>哈夫曼树的结点总数为 <strong>2n-1</strong></li><li>哈夫曼树中<strong>不存在度为1</strong>的结点</li><li>哈夫曼树不唯一，但是<strong>最小带权长度唯一</strong>。</li></ul><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/7b216a3b/#disqus_thread</comments>
    </item>
    
    <item>
      <title>查找算法</title>
      <link>http://yoursite.com/posts/aad2137f/</link>
      <guid>http://yoursite.com/posts/aad2137f/</guid>
      <pubDate>Sat, 21 Aug 2021 12:24:54 GMT</pubDate>
      <description>
      
        顺序查找、折半查找、分块查找、B树、散列查找
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><font color='red'>查找</font>——在数据集合中寻早曼珠某种条件的数据元素的过程称为查找</li><li><font color='red'>查找表</font>(查找结构) —— 用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录)组成</li><li><font color='red'>关键字</font>——数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果因该是<strong>唯一</strong>的。</li></ul><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ul><li>查找符合条件的数据元素<ul><li><strong>静态查找表</strong><ul><li>仅仅关注查找速度即可</li></ul></li><li>查找表不会发生改变</li></ul></li><li>插入、删除某个数据元素<ul><li><strong>动态查找表</strong><ul><li>关注查找速度</li><li>关注删除、增加操作是否方便</li></ul></li><li>查找表会发生改变</li></ul></li></ul><h3 id="查找算法的评价指标"><a href="#查找算法的评价指标" class="headerlink" title="查找算法的评价指标"></a>查找算法的评价指标</h3><ul><li><strong>查找长度：</strong>——在查找运算中，需要对比关键字的次数称为查找长度</li><li><strong>平均查找长度（ASL）：</strong>——所有查找过程中进行关键字的比较次数的平均值</li></ul><p><strong>评价一个查找算法的效率时，通常考虑查找成功、查找失败两种情况的ASL。</strong></p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>定义：又名”线性查找“，通常用于<strong>线性表</strong></p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>遍历</strong></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//查找表的数据结构(顺序表)</span></span><br><span class="line">    ElemType *elem;<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="keyword">int</span> TableLen;<span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找（普通模式）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable st,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; st.TableLen ; ++i)&#123;</span><br><span class="line">        <span class="comment">//查找成功则返回元素下标</span></span><br><span class="line">        <span class="keyword">if</span>(St.elem[i] == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找失败，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找（哨兵模式）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable st,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数组的元素从1开始</span></span><br><span class="line">    <span class="keyword">int</span> st.elem[<span class="number">0</span>] = key;<span class="comment">//哨兵</span></span><br><span class="line">    <span class="comment">//若数组中存在key则返回其下标，由于elem[0] = key，不存在则返回0；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = TableLen;st.elem[i] != key ; --i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优点：无需判断是否越界，效率更高</span></span><br></pre></td></tr></table></figure><h4 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h4><ul><li><p>ASL(成功) = （n+1）/ 2</p></li><li><p>ASL(失败) =    n+1</p></li></ul><h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><h4 id="有序表的优化"><a href="#有序表的优化" class="headerlink" title="有序表的优化"></a>有序表的优化</h4><p>当发现数已经大于本身时，可以判定查找失败。</p><h5 id="用查找判定树分析ASL"><a href="#用查找判定树分析ASL" class="headerlink" title="用查找判定树分析ASL"></a>用查找判定树分析ASL</h5><ul><li>一个成功结点的查找长度 = 自身所在层数</li><li>一个失败结点的查找长度 = 其父节点所在层数</li><li>默认情况下，各种失败情况或者成功情况都等概率发生</li></ul><h4 id="被查概率不相等"><a href="#被查概率不相等" class="headerlink" title="被查概率不相等"></a>被查概率不相等</h4><p><strong>被查找概率打的放在靠前位置</strong></p><ul><li>提高查找成功的ASL</li><li>降低了查找失败的ASL</li></ul><h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>适用于<strong>有序</strong>的<strong>顺序表</strong><ul><li>有序——为了判断目标值是在哪个区间</li><li>顺序表——为了随机访问</li></ul></li></ul><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="comment">//查找表的数据结构(顺序表)</span></span><br><span class="line">    ElemType *elem;<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="keyword">int</span> TableLen;<span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SSTable L,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = L.TableLen - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;<span class="comment">//取中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;<span class="comment">//查找成功则返回所在位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;<span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;<span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找判定树"><a href="#查找判定树" class="headerlink" title="查找判定树"></a>查找判定树</h3><h4 id="构造（-mid-low-high-2）"><a href="#构造（-mid-low-high-2）" class="headerlink" title="构造（ mid = (low + high) / 2）"></a>构造（ mid = (low + high) / 2）</h4><ul><li>如果当前low和high之间由<strong><font color='red'>奇数个</font></strong>元素，则mid分隔后，<strong><font color='red'>左右两部分元素个数相等</font></strong></li><li>如果当前low和high之间有<strong><font color='red'>偶数个</font></strong>元素，则mid分隔后，<strong><font color='red'>左半部分比右半部分少一个元素</font></strong></li></ul><p>折半查找的判定树中，若mid = { (low + high) / 2}(向下取整),则对于任何一个结点，必有：<strong><font color='red'>右子树结点数 — 左子树结点数 = 0或1</font></strong></p><ul><li><p>折半查找的判定树<strong><font color='red'>一定是平衡二叉树</font></strong></p></li><li><p>折半查找的判定树中，<strong><font color='red'>只有最下面一层是不满的</font></strong></p><p>因此，元素个数为n时<strong><font color='red'>树高h = { ㏒( n + 1)}(向上取整)</font></strong></p></li></ul><p><strong>注意：</strong>在折半查找判定树中的方形结点是虚构的，它并不计入比较的次数中</p><h3 id="折半查找效率"><a href="#折半查找效率" class="headerlink" title="折半查找效率"></a>折半查找效率</h3><p><strong>时间复杂度：O(㏒n)</strong></p><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><ul><li>特点：块内无序，块间有序</li><li>索引表中保存每个分块的最大关键字和分块存储区间</li></ul><p><strong><font color='red'>分块查找</font></strong>，又称<strong><font color='red'>索引顺序查找</font></strong>，算法过程如下：</p><ol><li>在索引表中确定带查找记录所属分块(可顺序，可折半)</li><li>在块内顺序查找</li></ol><p>若索引表中不包含目标关键字，则折半查找索引表最终停在low&gt;high,要<strong><font color='red'>在low所指分块中查找</font></strong></p><ul><li>low&gt;high退一步——》low == high == mid<ul><li>elem[mid] &gt; key ====&gt; high = mid -1; (也就是low = mid &gt; high)</li><li>elem[mid] &lt; key ====&gt; low = mid +1;( 也就是low = mid +1 &gt; mid = high)</li></ul></li></ul><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//索引表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType MaxValue;<span class="comment">//块内最大值</span></span><br><span class="line">    <span class="keyword">int</span> low,high;<span class="comment">//块区间的头尾下标</span></span><br><span class="line">&#125;Index;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表存储实际元素</span></span><br><span class="line">ElemType List[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><h3 id="查找效率分析ASL"><a href="#查找效率分析ASL" class="headerlink" title="查找效率分析ASL"></a>查找效率分析ASL</h3><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="5叉查找树"><a href="#5叉查找树" class="headerlink" title="5叉查找树"></a>5叉查找树</h3><p><strong>结点定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5叉排序树的结点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType keys[<span class="number">4</span>];<span class="comment">//最多4个关键字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">child</span>[5];</span><span class="comment">//最多五个孩子</span></span><br><span class="line">    <span class="keyword">int</span> num;<span class="comment">//结点中有几个关键字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>结点最少一个关键字，2个分叉</p><p>最多4个关键字，5个分叉</p><p>结点内关键字有序</p></li></ul><h3 id="B树基本概念"><a href="#B树基本概念" class="headerlink" title="B树基本概念"></a>B树基本概念</h3><p><strong>定义：</strong><font color='red'>B树</font>，又称<font color='red'>多路平衡(所有子树的高度都要相同)查找树</font>，B树中所有结点的<font color='red'>孩子个数的最大值称为B树的阶</font>，通常用m表示。一颗<font color='red'>m阶B树</font>或为空树，或为满足如下特性的m叉树：</p><ol><li>树中每个结点至多有m棵子树，即至多含有m-1个关键字</li><li>若根结点不是终端结点，则至少有两棵子树</li><li><font color='red'>除根结点外</font>的所有非叶节点至少有<font color='red'>{m / 2}(向上取整) 棵子树</font>，即至少含有 <font color='red'>{ m / 2 }(向上取整) - 1个关键字</font>。</li><li>所有的<font color='cornflowerblue'>叶结点</font>都出现在同一层次上，并且不带有信息(可以视为外部节点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空)</li></ol><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><strong>核心要求：</strong></p><ol><li>对m阶B树——除根结点外，结点关键字数<font color='red'>⌈m / 2⌉ — 1 ≤ n ≤ m - 1</font></li><li>子树0 &lt; 关键字1 &lt; 子树1 &lt; 关键字2 &lt; …</li></ol><p><strong>插入过程：</strong></p><ul><li>新元素一定是插入到最底层”终端节点”，用<strong>“查找”来确定插入位置</strong></li><li>在插入key后，若导致原结点关键字超过上限，则从中间位置( <font color='red'>⌈m / 2⌉</font> )将其中的关键字<font color='red'>分为两部分</font>，左部分包含的关键放在原结点，右部分包含的关键字放在新结点中，中间位置( <font color='red'>⌈m / 2⌉</font> )的结点插入原结点的父节点。==分裂操作</li><li>若此时导致<font color='red'>其父结点的关键字</font>个数也<font color='red'>超过</font>了<font color='red'>上限</font>，则<font color='red'>继续</font>进行这种<font color='red'>分裂</font>操作，直至这个过程传到根结点为止，<font color='red'>进而导致B树高度增1</font></li></ul><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>删除非终端结点：</strong></p><p>若被删除关键字在<font color='red'>非终端结点</font>，则用<font color='red'>直接前驱或直接后继来替代被删除的关键字</font>；</p><ul><li><font color='red'>直接前驱</font>：当前关键字<font color='red'>左侧指针所指子树中“最右下”的元素</font></li><li><font color='red'>直接后继</font>：当前关键字<font color='red'>右侧指针所指子树中“最左下”的元素</font></li></ul><p><strong><font color='red'>对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作</font></strong></p><p><strong>删除终端结点</strong>：</p><ul><li><p>若删除终端结点的某一关键字后，关键字数量没有低于下限，则直接删除，否则</p></li><li><p><font color='red'>兄弟够借</font>。若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结点的关键字个数该很充裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点(父子换位法)</p></li><li><p><font color='red'>兄弟不够借</font>。若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均为 ⌈m / 2⌉—1，则将关键字删除后<font color='red'>与左(或右)兄弟结点</font>及<font color='red'>双亲结点中的关键字</font>进行合并。</p><p>在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有两颗子树），则直接将根结点删除，合并后的新结点为根；若双亲结点不是根结点，且关键字个数减少到⌈m / 2⌉—2，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。</p></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><strong>定义：</strong>一棵m阶的B+树需满足下列条件：</p><ol><li>每个分支结点最多有m棵子树</li><li><font color='red'>非叶根点至少有两棵子树</font>，其余每个分支结点至少有⌈m / 2⌉ 棵子树。</li><li><font color='red'>结点的子树个数与关键字个数相等</font>。</li><li>所有<font color='red'>叶结点包含全部关键字及指向相应记录的指针</font>，叶结点中将关键字按大小顺序排列，并且<font color='red'>相邻叶结点按大小顺序相互连接起来</font>.</li><li>所有分支结点(可视为索引的索引)中<font color='red'>仅</font>包含<font color='red'>它的各个子结点(即下一级的索引块)中关键字的最大值</font>及<font color='red'>指向其子节点的指针</font>。</li></ol><p><strong>B+树，在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的关键字为止。所以<font color='red'>在B+树上查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径</font></strong>。</p><h3 id="B树与B-树的差异"><a href="#B树与B-树的差异" class="headerlink" title="B树与B+树的差异"></a>B树与B+树的差异</h3><ul><li><p>子树个数</p><ul><li>在B+树中，具有n个关键字的结点只<font color='red'>含有<strong>n</strong>棵子树</font>，即每个关键字对应一颗子树</li><li>在B树中，具有n个关键字的结点<font color='red'>含有<strong>n+1</strong>棵子树</font>。</li></ul></li><li><p>关键字个数</p><ul><li>在B+树中，每个结点(非根内部结点)的关键字个数n的范围是<font color='red'>⌈m / 2⌉  ≤ n ≤ m</font>(根结点：1 ≤ n ≤ m)；</li><li>在B树中，每个结点(非根内部结点)的关键字个数n的范围是<font color='red'>⌈m / 2⌉  ≤ n ≤ m-1</font>(根结点：1 ≤ n ≤ m-1)；</li></ul></li><li><p>叶结点与非叶结点包含的信息</p><ul><li>在B+树中，<font color='red'>叶结点包含信息，所有非叶节点仅其索引作用</font>，非叶结点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li></ul></li><li><p>在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中,<font color='red'>重复的</font></p><p>在B树中，叶结点(最外层内部结点)包含的关键字和其他结点包含的关键字是<font color='red'>不重复的</font>.</p></li></ul><h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p><strong>定义：</strong>又称<font color='red'>哈希表</font>，是一种数据结构，特点是：数据元素的<font color='red'>关键字</font>与其<font color='red'>存储地址直接相关</font>.</p><ul><li>通过<font color='red'>“散列函数(哈希函数)</font>：Addr = H(key)”来建立关键字与存储地址的联系</li></ul><p><strong>术语</strong></p><ul><li><font color='red'>同义词</font>：不同的关键字通过散列函数映射到同一个值</li><li><font color='red'>冲突</font>：通过散列函数确定的为止已经存放了其他元素</li><li><strong><font color='red'>装填因子α  =  表中记录数 / 散列表长度</font></strong><ul><li>装填因子会直接影响散列表的查找效率</li></ul></li></ul><h3 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a><strong>处理冲突的方法</strong></h3><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><ul><li>把所有“同义词”存储到一个链表中。</li></ul><h4 id="开发定址法"><a href="#开发定址法" class="headerlink" title="开发定址法"></a>开发定址法</h4><p><strong>定义</strong>：指可存放心表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放，</p><p><strong>数学递推公式： H(i) = ( H(key) + d( i )) % m</strong></p><ul><li>m表示散列表的表长</li><li>d(i) 为增量序列</li><li>i 表示第i次发生冲突</li></ul><p><strong>增量序列的取定</strong></p><ul><li><p>线性探测法</p><ul><li><p>d(i) = 0，1，2，3，4… m-1；即发生冲突时，每次往后探测相邻的下一个单元是否为空。</p></li><li><p>缺点：这种方法会造成<font color='red'>同义词、非同义词在相邻的散列地址上“聚集</font>”起来，大大降低查找效率。</p><p><strong><font color='red'>越早遇到空位置，就可以越早确定查找失败，提高效率</font></strong></p></li></ul></li><li><p>平方探测法</p><ul><li>d(i) = 0²，1²，-1²，2²，-2²，3²，-3²，4²,-4²… k², -k²；(k ≤ m/2)</li><li><strong>m必须是一个可以表示称<font color='red'> 4j + 3的素数</font>{7,11…..}，才能探测到所有的为止</strong></li></ul></li><li><p>伪随机序列法</p><ul><li>d(i)是一个伪随机序列，如d(i) = 0,1,4,7,12…</li></ul></li></ul><p><strong>开放地址法在删除结点时，不能简单的将被删除的空间置为空，否则将<font color='red'>截断在它之后填入散列表的同义词结点的查找路径</font>，可以<font color='red'>做一个”删除标记”，进行逻辑删除</font>。</strong></p><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><ul><li>除留余数法——H(key)  =  key % p<ul><li>散列表长度为m，取一个不大于但最接近或等于m的<font color='red'>质数</font>p<ul><li>质数取模，分布跟均匀，冲突更少</li></ul></li></ul></li><li>直接定址法——H(key)  = key 或 H(key) = a * key + b<ul><li>a和b是常数。这种方法计算最简单，且<strong><font color='red'>不会产生冲突</font></strong>，<font color='red'>它适合关键字的分布基本连续的情况</font>，若关键字分布不连续，空位较多，则会造成存储空间的浪费.</li></ul></li><li>数字分析法——选取数码分布较为均匀的若干位作为散列地址。<ul><li><strong><font color='red'>适合已知的关键字集合。</font></strong></li><li>设关键字是r进制数，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某集中数码经常出现，此时应该<font color='red'>选取数码分布较为均匀的若干位作为散列地址</font>。</li></ul></li><li>平方取中法——去关键字的平方值的中间几位作为散列地址。<ul><li>这种方法取关键字的平方值的中间极为作为散列地址</li><li><font color='red'>得到的散列地址与关键字的每位都有关系</font></li></ul></li></ul><p><strong>散列查找是典型“<font color='red'>用空间换时间</font>”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率就越低</strong></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/aad2137f/#disqus_thread</comments>
    </item>
    
    <item>
      <title>排序算法</title>
      <link>http://yoursite.com/posts/735e5788/</link>
      <guid>http://yoursite.com/posts/735e5788/</guid>
      <pubDate>Sat, 21 Aug 2021 12:24:54 GMT</pubDate>
      <description>
      
        插入排序、冒泡排序、选择排序、归并排序等关键排序算法以及对对应的复杂度比较
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="comment">//依次将2~N的数据插入到前面已排序序列（数据下标从1开始，同时A[1]是已经排序完成的）</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; j &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; A[i<span class="number">-1</span>])&#123;<span class="comment">//若A[i]关键字小于其前驱（前面排序序列的最大值），就将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];<span class="comment">//复制为哨兵，A[0]充当哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">1</span>; A[<span class="number">0</span>] &lt; A[j];--j)<span class="comment">//从后往前查找带插入的位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];<span class="comment">//向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];<span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><strong>空间复杂度：O(1)</strong></li><li><strong>时间复杂度：O(n²)</strong></li></ul><p><strong>算法稳定性：稳定</strong></p><h3 id="折半插入排序（优化）"><a href="#折半插入排序（优化）" class="headerlink" title="折半插入排序（优化）"></a>折半插入排序（优化）</h3><p>由于是顺序存储的线性表，且前面序列是已经排好序的序列，我们在查找某个元素的插入位置的时候，可以<strong>使用折半查找来确定待插入位置</strong>，确定插入位置后，在统一的向后移动位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入查找</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)&#123;<span class="comment">//依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];<span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low == <span class="number">1</span>;high = i<span class="number">-1</span>;<span class="comment">//设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;<span class="comment">//找到插入的位置。low</span></span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;<span class="comment">//取中间值</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>])<span class="comment">//当A[mid] == A[0]时，为了稳定性，我们继续往右找一个位置。</span></span><br><span class="line">                high = mid - <span class="number">1</span>;<span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;<span class="comment">//查找右半子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//low = high +1</span></span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= low; --j)</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];<span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        A[low] = A[<span class="number">0</span>];<span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>节省了比较的次数，但是没有节省移动的时间——<strong>时间复杂度：O(n²)</strong></p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>先将待排序表分割成若干形如L[i , i+d, i+2d, i+3d,….. i+kd]的“特殊“子表，对各个子表分别进行直接插入排序，缩小<font color='red'>增量d</font>,重复上述过程，直到d为1为止。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d,i,j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已经到了</span></span><br><span class="line">    <span class="keyword">for</span>(d = n/<span class="number">2</span> ; d &gt;= <span class="number">1</span> ; d = d/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = d+<span class="number">1</span>; i&lt;=n;i++)&#123;<span class="comment">//步长变化</span></span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i-d])&#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[i];<span class="comment">//暂存A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j = i-d; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j]; j = j-d)&#123;</span><br><span class="line">                    A[j+d] = A[j];<span class="comment">//记录后移动，查找插入的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                A[j+d] = A[<span class="number">0</span>];<span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><strong>空间复杂度：O(1)</strong></li><li><strong>时间复杂度：O(n²)</strong></li></ul><p><strong>希尔排序仅仅适用于顺序表，不适用于链表</strong></p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>从后往前(或者从前往后)两两比较相邻元素的值，若为逆序(即A[i-1] &gt; A[i])，则交换它们，直到序列比较完，称这样过程为”一趟“冒泡排序</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i;j++)&#123;<span class="comment">//一趟冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j])&#123;<span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);<span class="comment">//交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;<span class="comment">//如果在一趟遍历后，没有发生任何交换，说明表已经有序了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li><strong>空间复杂度：O(1)</strong></li><li><strong>时间复杂度：O(n²)</strong></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>在待排序表L[1 , 2… n]中任取一个元素pivot作为<font color='red'>基准（通常取首元素）</font>，通过一趟排序将待排序表划分为独立的两部分L[1,… k-1]和L[k+1,…n]，使得L[1,… k-1]中的所有元素小于pivot，L[k+1,…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一次“划分”，然后分别<font color='red'>递归</font>地对两个子表重复上述过程，直至每部分内只有一个元素或者空为止，即所有元素放在了最终位置上。</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;<span class="comment">//当子表中存在一个或者没有元素时，不进行操作</span></span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition(A,low,high);<span class="comment">//划分</span></span><br><span class="line">    QuickSort(A,low,pivotpos<span class="number">-1</span>);<span class="comment">//划分左子表</span></span><br><span class="line">    QuickSort(A,pivotpos+<span class="number">1</span>,high);<span class="comment">//划分右子表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用第一个元素将待排序序列分成左右两个部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[low];<span class="comment">//用第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;<span class="comment">//用low、high搜索枢轴的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high]&gt;=pivot) --high;<span class="comment">//从右往左找到比枢轴小的元素的下标</span></span><br><span class="line">        A[low] = A[high];<span class="comment">//比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt; pivot) ++low;<span class="comment">//从左往右找到比枢轴大的元素的下标</span></span><br><span class="line">        A[high] = A[low];<span class="comment">//比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;<span class="comment">//枢轴元素存放的最终位置</span></span><br><span class="line">    <span class="keyword">return</span> low;<span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul><li><strong>时间复杂度：O(n*递归层数)</strong><ul><li>最好：O(n㏒n)</li><li>最坏：O(n²)            <strong>{原本逆序或者顺序}</strong></li></ul></li><li><strong>空间复杂度：O(递归层数)</strong><ul><li>最好：O(㏒n)</li><li>最坏：O(n)            <strong>{原本逆序或者顺序}</strong></li></ul></li></ul><p><strong>n个元素组织成二叉树，二叉树的层数就算递归调用的层数：最小高度 = ⌊ ㏒ n⌋ + 1,最大高度 = n；</strong></p><p><strong><font color='red'>快速排序是所有内部排序算法中平均性能最优的排序算法</font></strong></p><p><strong>快速排序是不稳定的</strong></p><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>每一趟在待排序元素中选取关键字最小的元素加入有序子序列</strong></p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>; i++)&#123;<span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;<span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;<span class="comment">//在A[i... n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[<span class="built_in">min</span>]) <span class="built_in">min</span> = j;<span class="comment">//更新最小元素的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> != <span class="number">1</span>) swap(A[i],A[<span class="built_in">min</span>])<span class="comment">//封装的swap()函数共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><ul><li>时间复杂度：O(n²)</li><li>空间复杂度：O(1);</li></ul><p><strong>简单选择排序是不稳定的</strong></p><p><strong>既可以使用在顺序表，也可以是链表</strong></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>定义：</strong>若关键字序列L[1…n]满足下面某条性质，则称为<font color='red'>堆(Heap)</font></p><ol><li>若满足：L(i) ≥ L(2i) 且 L(i) ≥ L(2i+1) (1 ≤ i ≤ n/2)     —— <strong><font color='red'>大根堆 (大顶堆)</font></strong></li><li>若满足：L(i) ≤ L(2i) 且 L(i) ≤ L(2i+1) (1 ≥ i ≥ n/2)     —— <strong><font color='red'>小根堆 (小顶堆)</font></strong></li></ol><p>大根堆：完全二叉树中，<font color='red'>根 ≥ 左、右</font></p><p>小根堆：完全二叉树中，<font color='red'>根 ≤ 左、右</font></p><p><strong>完全二叉树中：</strong></p><ul><li><strong>i的左孩子 ——2i</strong></li><li><strong>i的右孩子 —— 2i+1</strong></li><li><strong>i的父节点 ——⌊ i/2 ⌋</strong></li></ul><h3 id="建立大根堆"><a href="#建立大根堆" class="headerlink" title="建立大根堆"></a>建立大根堆</h3><ul><li><font color='red'>根 ≥ 左、右</font></li></ul><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p><strong>把所有非终端结点都检查一边，是否满足大根堆的要求，如果不满足，则进行调整。</strong></p><ul><li>检查当前结点是否满足 <font color='red'>根 ≥ 左、右</font>，<strong><font color='red'>若不满足，将当前结点与更大的一个孩子互换</font></strong></li><li>若元素互换破坏了下一级的堆，则采用相同的办法继续往下调整(<font color='red'>小元素不断”下坠“</font>)</li></ul><p>{在顺序存储的完全二叉树中，非终端结点编号 <font color='red'>i ≤ ⌊ n/2 ⌋</font>}</p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        HeadAdjust(A,j,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];<span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * k;i &lt; len; i *= <span class="number">2</span>)&#123;<span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">            i++;<span class="comment">//取key较大的子结点的下标，</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i])<span class="keyword">break</span>;<span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = A[i];<span class="comment">//A[i]调整到双亲结点上</span></span><br><span class="line">            k = i;<span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><p><strong>时间复杂度：O(n)</strong></p><p>关键字比较总次数不超过4n</p></li></ul><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>定义：</strong>每一趟将堆顶元素加入有序子序列(与待排序序列中的最后一个元素交换)。并将待排序元素序列再次调整为大根堆（小元素不断“下坠”）同时len-1。</p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len):<span class="comment">//初始建堆 O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; --i)&#123;<span class="comment">//n-1趟的交换和建堆过程 </span></span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]);<span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;<span class="comment">//一趟：O(h) = O(⌊ ㏒n ⌋ + 1),总的时间复杂度是O( n㏒n )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color='red'>获得是递增序列</font></strong></p><h4 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li>时间复杂度：O(n㏒n)</li><li>空间复杂度：O(1)</li></ul><p><strong>堆排序是不稳定的</strong></p><h3 id="堆的插入和删除-以小根堆为例"><a href="#堆的插入和删除-以小根堆为例" class="headerlink" title="堆的插入和删除(以小根堆为例)"></a>堆的插入和删除(以小根堆为例)</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>对于小根堆，新元素放到表尾，与父结点对比，若<font color='red'>新元素</font>比父节点<font color='red'>更小</font>，则将二者互换。新元素就这样子一路“<font color='red'>上升</font>”，直到无法继续上升为止。</p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>被删除的元素用<font color='red'>堆底元素替代</font>，然后让该元素不断“<font color='red'>下坠</font>”，直到无法下坠为止。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><p>归并：把两个或多个已经有序的序列合并成一个。</p><p>2路归并：把两个已经有序的序列合并成一个。</p><h3 id="手动模拟排序"><a href="#手动模拟排序" class="headerlink" title="手动模拟排序"></a>手动模拟排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">初始序列：        49 38 65 97 76 13 27</span><br><span class="line">                [49 38] [65 97] [76 13] [27]</span><br><span class="line">第一趟归并排序：   38 49  65 97 13 76 27</span><br><span class="line">[38 49  65 97] [13 76 27]</span><br><span class="line">第二趟归并排序:    38 49  65 97 13 76 27</span><br><span class="line">[38 49  65 97 13 76 27]</span><br><span class="line">第二趟归并排序:13 27 38 49 65 76 97</span><br></pre></td></tr></table></figure><p><strong>核心操作：把数组内的两个有序序列归并为一个</strong></p><h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));<span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low....mid]和A[mid+1 ... high]各自有序，将两个部分合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k &lt;= high; k++)&#123;</span><br><span class="line">        B[k] = A[k];<span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = low,j = mid + <span class="number">1</span>,k = i; i&lt;= mid &amp;&amp; j &lt;= high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i] &lt;= B[j])<span class="comment">//将较小值复制到A中。(这里等号可以保证算法的稳定性)</span></span><br><span class="line">            A[k] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) A[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)&gt;&gt;<span class="number">1</span>;<span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A,low,mid);<span class="comment">//对左部分归并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);<span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);<span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h3><p><strong>空间复杂度：O(n);</strong></p><p><strong>时间复杂度：O(n㏒n)；</strong></p><p>​    每一趟归并的时间复杂度是O(n),共需要进行⌈ ㏒n ⌉。</p><p> <strong>归并排序是稳定的</strong></p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="擅长解决的问题"><a href="#擅长解决的问题" class="headerlink" title="擅长解决的问题"></a>擅长解决的问题</h3><ol><li>数据元素的关键字可以方便地拆分为d组，且d较小</li><li>每组关键字的取值范围不大，即r较小</li><li>数据元素个数n较大。</li></ol><h2 id="内部排序算法的比较"><a href="#内部排序算法的比较" class="headerlink" title="内部排序算法的比较"></a>内部排序算法的比较</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均时间复杂度<strong>O(n²)：</strong>简单选择排序、直接插入排序、冒泡排序</p><p>最好时间复杂度<strong>O(n)：</strong>直接插入排序、冒泡排序。</p><p>最坏时间复杂度<strong>O(n²)</strong>：快速排序</p><p>平均时间复杂度<strong>O(n㏒n)</strong>：快速排序</p><p><strong>归并排序最好、最坏、平均的时间复杂度：O(n㏒n)</strong></p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><strong>O(1):</strong>      简单选择排序、插入排序、冒泡排序、希尔排序、堆排序</p><p><strong>O(㏒n)：</strong>快速排序(平均);</p><p><strong>O(n)：</strong>归并排序、快速排序(<strong>最坏是O(n)</strong>);</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>稳定：</strong>插入排序、冒泡排序、归并排序、基数排序</p><p><strong>不稳定：</strong>简单选择排序、快速排序、希尔排序、堆排序</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li><p><strong>数据量较小时</strong>，采用直接插入排序或者简单选择排序。</p></li><li><p><strong>基本有序</strong>，采用直接插入或者冒泡排序</p></li><li><p><strong>数据量较大时</strong>，采快速排序、归并排序、堆排序</p><p>数据随机分布：快速排序</p><p>辅助空间少：堆排序</p><p>算法稳定：归并排序</p></li></ul><h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/735e5788/#disqus_thread</comments>
    </item>
    
    <item>
      <title>串</title>
      <link>http://yoursite.com/posts/58d9577e/</link>
      <guid>http://yoursite.com/posts/58d9577e/</guid>
      <pubDate>Mon, 12 Jul 2021 15:44:28 GMT</pubDate>
      <description>
      
        字符串的基本概念，模式匹配
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>定义：</strong>即<font color='red'>字符串</font>，是由零个或多个<font color='red'>字符</font>组成的有限序列。一般标记为 S = “    a xx sda an”。</p><ul><li>其中 S是<font color='red'>串名</font>，</li><li>字符的个数n称为<font color='red'>串的长度</font><ul><li>n = 0时的串称为<font color='red'>空串</font>。</li></ul></li></ul><p><strong>术语</strong></p><ul><li>子串：串中任意多个<font color='red'>连续的</font>字符组成的的子序列称为该串的子串。<ul><li>空串也是字串</li></ul></li><li>主串：包含子串的串。</li><li>字符在主串中的位置：字符在串中的序号，<strong>从1开始</strong>。</li><li>字串在主串中的位置：字串在第一个字符在主串中的位置。<strong>从1开始</strong></li><li>空格串：由一个或多个空格组成的串，长度是串中空格字符的个数，<strong>空格串不是空串</strong>。</li></ul><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>串的逻辑结构和线性表极为相似，区别仅在于<strong>串的数据对象限定为字符集</strong>，<strong>基本操作对象通常是以<font color='red'>字串</font>作为操作对象</strong>。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StrAssign(&amp;T , chars): 赋值操作。把串T赋值给chars</span><br><span class="line">StrCopy(&amp;T, S): 复制操作。由串S复制得到串T。</span><br><span class="line">StrEmpty(S): 判空操作。若S为空串，则返回True，否则返回False。</span><br><span class="line">StrLength(S): 求串长。返回串S的元素个数。</span><br><span class="line">ClearString(&amp;S): 求空操作。将S清为空串。</span><br><span class="line">DestroyString(&amp;S): 销毁串。将串S销毁(回收存储空间).</span><br><span class="line">Concat(&amp;S,S1,S2): 串联结。用T返回由S1和S2链接而成的新串。</span><br><span class="line">SubString(&amp;Sub,S,pos,len):求子串。用Sub返回串S的第pos个字符起长度为len的子串。</span><br><span class="line">Index(S,T): 定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</span><br><span class="line">StrCompare(S,T):比较操作，若S&gt;T,则返回值&gt;0;若S&#x3D;T,则返回值&#x3D;0； 若S&lt;T,则返回值&lt;0.</span><br></pre></td></tr></table></figure><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><strong>定长顺序存储—结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255<span class="comment">//预定义最长串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];<span class="comment">//每个分量存储一个字符,静态数组</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br><span class="line"><span class="comment">//为了使数组的下标与串的位置相等，数组从下标1开始。ch[0]是空的</span></span><br></pre></td></tr></table></figure><p><strong>堆分配存储—结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255<span class="comment">//预定义最长串长为255</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;<span class="comment">//按串长分配存储区。ch指向串的基地址。</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;<span class="comment">//动态数组实现，堆分配实现</span></span><br><span class="line"></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(MAXLEN * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//需要手动free</span></span><br><span class="line">S-&gt;length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><strong>链式存储——结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;<span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode,* <span class="keyword">String</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">char类型一个字节，struct StringNode * 占四个字节</span></span><br><span class="line"><span class="comment">这样的结构体存储密度低。</span></span><br><span class="line"><span class="comment">为了改进该存储结构，提高存储密度，我们把每个结构体存储的数据提高</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">4</span>];<span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode,* <span class="keyword">String</span>;</span><br></pre></td></tr></table></figure><h2 id="基本操作（基于静态数组）"><a href="#基本操作（基于静态数组）" class="headerlink" title="基本操作（基于静态数组）"></a>基本操作（基于静态数组）</h2><p><strong>求子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SubString(&amp;Sub,S,pos,len):求子串。用Sub返回串S的第pos个字符起长度为len的子串。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="keyword">int</span> pos,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos + len <span class="number">-1</span> &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; pos + len; i++)&#123;</span><br><span class="line">        Sub.ch[i - pos + <span class="number">1</span>] = S.ch[i];</span><br><span class="line">        Sub.length = len;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>串比较</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StrCompare(S,T):比较操作，若S&gt;T,则返回值&gt;0;若S=T,则返回值=0； 若S&lt;T,则返回值&lt;0.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= S.length &amp;&amp; i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>定位操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Index(S,T): 定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = StrLength(S),m = StrLength(T);</span><br><span class="line">    SString sub;<span class="comment">//用于暂存子串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub, S, i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T) != <span class="number">0</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i ;<span class="comment">//返回子串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//S中不存在与T相等的子串。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><strong>定义：</strong>在主串中找到与模式串相同的子串，并返回其所在位置。</p><ul><li>子串：主串的一部分，一定存在。</li><li>模式串：不一定能在主串中找到。</li></ul><h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><ul><li><p><strong><font color='red'>暴力求解</font></strong></p></li><li><p>假定<strong>主串长度为n，模式串长度为m</strong></p></li><li><p>概念：将主串中<strong><font color='red'>所有长度为m的子串依次与模式串对比</font></strong>，直到找到一个完全匹配的子串，或者所有子串都不匹配。</p><ul><li>最多有<strong>n-m+1</strong>个子串</li></ul></li><li><p><strong>最坏时间复杂度：O(nm)</strong></p><p><strong>最好时间复杂度：O(n)</strong></p></li></ul><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用基本操作实现算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = StrLength(S),m = StrLength(T);</span><br><span class="line">    SString sub;<span class="comment">//用于暂存子串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n-m+<span class="number">1</span>)&#123;<span class="comment">//最多对比n-m+1个子串</span></span><br><span class="line">        SubString(sub, S, i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T) != <span class="number">0</span>) i++;<span class="comment">//如果不匹配，就尝试匹配下一个子串</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i ;<span class="comment">//返回子串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//S中不存在与T相等的子串，匹配失败。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用基本操作实现算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;<span class="comment">//子串匹配比较</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//匹配失败，指针后退重新开始匹配</span></span><br><span class="line">            i = i - j + <span class="number">2</span> ;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length) <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul><li><strong><font color='red'>最坏时间复杂度 O(m+n)</font></strong><ul><li><strong>next数组时间复杂度：O(m)</strong></li><li><strong>模式匹配过程最坏时间复杂度：O(n)   //主串不回溯</strong></li></ul></li></ul><h4 id="手算next数组"><a href="#手算next数组" class="headerlink" title="手算next数组"></a>手算next数组</h4><ul><li><strong><font color='red'>next[1]都无脑写0</font></strong></li><li><strong><font color='red'>next[2]都无脑写1</font></strong></li><li><strong><font color='red'>其他next</font></strong>：在不匹配的位置前，划一根分界限，模式串一步一步往后退，<strong>直到分界线之前“能对上”，或者模式串完全跨越分界线为止</strong>。此时j指向哪里，next数组就是多少。</li></ul><p><strong>代码实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//next[] 当匹配失败时，j指针需要回溯到多少位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S,SString T,<span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt; T.length)&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        1、当j==0时，也就是在匹配过程中，模式串和子串第一个字符就匹配失败，需要换下一个子串并且模式串的指针后退到第一个字符的位置，但在next数组中，对于以上的情况，把j设置为0，所有我们碰到j==0时，我们需要把j++，并且i++，与匹配成功时的操作相同。</span></span><br><span class="line"><span class="comment">        2、子串和模式串的某一字符匹配成功时，移动到下一个字符，进行匹配，直到完全匹配或者匹配失败的全款</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;<span class="comment">//继续比较后面的字符</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];<span class="comment">//匹配失败时，主串指针i不回溯，模式串指针向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length) <span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/58d9577e/#disqus_thread</comments>
    </item>
    
    <item>
      <title>特殊矩阵</title>
      <link>http://yoursite.com/posts/2fce5ec8/</link>
      <guid>http://yoursite.com/posts/2fce5ec8/</guid>
      <pubDate>Mon, 12 Jul 2021 15:44:28 GMT</pubDate>
      <description>
      
        几种特殊矩阵的基本概念
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><ul><li>可以<font color='orange'>用二维数组</font>存储。</li><li>注意：描述矩阵元素时，<font color='red'>行列号通常从1开始</font>；而描述数组时通常下标从0开始。（具体看题目给的条件，注意审题）</li></ul><h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a><strong>对称矩阵</strong></h3><p><strong>概念：</strong>若n阶<font color='orange'>方针</font>中任意一个元素a i,j 都有<font color='orange'> a[i] [j] = a[j] [i]</font>，则该矩阵为<font color='orange'>对称矩阵</font>。</p><p><strong>压缩存储策略：只存储主对角线 + 下三角区</strong></p><ul><li>按<font color='orange'>行优先</font>原则将各个元素存入一维数组中。</li><li>数组大小应该为：*<em>((n+1)</em>n)/2 **</li><li>在使用的时候，我们可以实现一个“映射”函数：<strong><font color='red'>矩阵下标 —&gt; 一位数组下标</font></strong><ul><li>按<font color='orange'>行优先</font>原则,a i j是第 (i * (i - 1))/2 + j 个元素，在数组中的下标是第<font color='red'> (i * (i - 1))/2 + j - 1</font>个位置。</li></ul></li></ul><h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><ul><li><font color='orange'>下三角矩阵</font>：除了主对角线和下三角区，其余的元素都相同。</li><li><font color='orange'>上三角矩阵</font>：除了主对角线和上三角区，其余的元素都相同。</li></ul><p><strong>压缩存储策略</strong></p><ul><li>按<font color='orange'>行优先</font>原则将橙色区元素存入一维数组中。并在<font color='orange'>最后一个位置存储常量c</font></li><li>数组大小应该为：<strong>((n+1)*n)/2  + 1</strong></li><li>在使用的时候，我们可以实现一个“映射”函数：<strong><font color='red'>矩阵下标 —&gt; 一位数组下标</font></strong>.<ul><li>按<font color='orange'>行优先</font>原则,a i j是第 (i * (i - 1))/2 + j 个元素，在数组中的下标是第<font color='red'> (i * (i - 1))/2 + j - 1</font>个位置。</li><li>如果 i &lt; j 则x = a[*<em>((n+1)</em>n)/2];</li></ul></li></ul><h3 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h3><p><strong>概念：</strong>当<font color='orange'>| i - j| &gt; 1 时，有a i j = 0;</font></p><p><strong>压缩存储策略</strong>：</p><ul><li><p>按<font color='orange'>行优先</font>原则，只存储带状部分</p></li><li><p>数组大小：3n - 2 </p></li><li><p>在使用的时候，我们可以实现一个“映射”函数：<strong><font color='red'>矩阵下标 —&gt; 一位数组下标</font></strong>.</p><ul><li><p>i j差值大于 1  则 x = 0;</p></li><li><p>前面i-1行共有 3（i-1）-1 个元素</p><p>a i j 是第i行 第j - i +2个元素</p><p>a i j 是第2i + j  - 2个元素</p></li></ul></li></ul><h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p><strong>概念：</strong>非零元素远远少于矩阵元素的个数</p><p><strong>压缩存储策略</strong></p><ul><li>顺序存储 ——三元组【行，列 ，值】，只存储非零数。<ul><li>失去随机存取的特性</li></ul></li><li>链式存储——十字链表法</li></ul><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ul><li>存储上三角、下三角。</li><li>行优先、列优先。</li><li>矩阵元素的下标从0？1？开始</li><li>数组下标从0？1？开始</li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/2fce5ec8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>栈</title>
      <link>http://yoursite.com/posts/1f4ac2fb/</link>
      <guid>http://yoursite.com/posts/1f4ac2fb/</guid>
      <pubDate>Mon, 12 Jul 2021 15:44:28 GMT</pubDate>
      <description>
      
        栈、顺序栈、链栈的基本概念极其应用
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><ul><li><font color='red'>只允许在一端进行或删除操作</font>的<font color='orange'>线性表</font>.</li><li>重要术语<ul><li>栈顶：允许插入和删除的一端——栈顶元素</li><li>栈底：不允许插入和删除的一端——栈底元素</li><li>空栈</li></ul></li><li>特点：<strong>后进先出</strong></li><li>数学特性：n各不同的元素出栈，出栈元素不同排列的个数为1/(1+n) * Cn(2n)。</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">InitStack(&amp;S):初始化栈。构造一个空栈S,分配内存空间;</span><br><span class="line">DestroyStack(&amp;L):销毁栈销毁并释放栈S所占用的内存空间;</span><br><span class="line"></span><br><span class="line">Push(&amp;S,x):进栈若栈S未满，则将x加入使之成为新栈顶;</span><br><span class="line">Pop(&amp;S,&amp;x):出栈若栈S非空，则弹出栈顶元素，并用x返回;</span><br><span class="line"></span><br><span class="line">GetTop(S,&amp;x):读取栈顶元素。若栈S非空，则用x返回栈顶元素</span><br><span class="line"></span><br><span class="line">其他常用操作：</span><br><span class="line">StackEmpty(S):判断一个栈S是否为空。若S为空，则返回true,否则返回false；</span><br></pre></td></tr></table></figure><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>顺序存储类型定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="keyword">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p><strong>初始化栈</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IniStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;<span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈空</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进栈</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize<span class="number">-1</span>)<span class="comment">//栈满，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S,top = S.top + <span class="number">1</span>;<span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;<span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>出栈</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];<span class="comment">//栈顶元素先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;<span class="comment">//指针在减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的数据删除只是逻辑上被删除了，在内存中还存在。</span></span><br></pre></td></tr></table></figure><p><strong>读取</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];<span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与删除操作相比，读取操作只是少了指针减1的步骤。</span></span><br></pre></td></tr></table></figure><h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p><strong>定义</strong>：两个栈<font color='red'>共享</font>同一片空间</p><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top0;<span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top1;<span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br></pre></td></tr></table></figure><p><strong>初始化栈</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;<span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈满</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FullStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 +<span class="number">1</span> = S.top1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>更加有效的利用存储空间。</li><li>只有当整个存储空间被占满时才发生上溢，减少发生上溢的可能性。</li><li>对存取效率没有什么影响</li></ul><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>链栈的操作与链表类似，<strong>入栈和出栈的操作都在链表的表头进行，头插法</strong></li></ul><h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;<span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>最后出现的左括号<strong>最先</strong>被匹配<font color='red'>（LIFO）</font>。</p><h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>中缀表达式</strong></p><ul><li>运算符在操作数之间<ul><li>eg：a + b</li><li>a + b - c</li><li>a + b - c  * d</li></ul></li></ul><p><strong><font color='red'>后缀表达式</font></strong></p><ul><li>运算符在操作数后面<ul><li>eg： a b +</li><li>a b + c -</li><li>a b +  c d *  - </li></ul></li><li><strong>左优先原则：只要左边的运算符都能先计算，就优先算左边的。</strong></li><li>注意：先弹出的元素是<strong>右操作数</strong></li></ul><p><strong>前缀表达式</strong></p><ul><li>运算符在操作数前面<ul><li>eg: + a b</li><li>-+a b c </li></ul></li><li><strong>右优先原则：只要右边的运算符都能先计算，就优先算右边的</strong></li><li>注意：先弹出的元素是<strong>左操作数</strong></li></ul><h4 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h4><p><strong>手算过程</strong></p><ul><li>确定中缀表达式中的<font color='red'>各个运算符的运算顺序</font>。</li><li>选择下一个运算符，按照<font color='orange'>【左操作数  右操作数 运算符】</font>的方式组合成一个新的操作数。<ul><li>这里由于运算顺序不唯一，因此对应的后缀表达式也不唯一。由于不唯一破坏了算法的确定性，为此我们确定了<strong>左优先原则</strong>。保证后缀表达式唯一。</li></ul></li><li>如果还有运算符没被处理，就继续第二步。</li></ul><p><strong>计算过程</strong></p><ul><li>初始化一个栈，用于保存<font color='red'>暂时还不能确定运算顺序的运算符</font>。</li><li>从左到右处理各个元素，直到末尾。可能遇到三种情况：<ul><li>遇到<font color='red'>操作数</font>。直接加入后缀表达式。</li><li>遇到<font color='red'>界定符</font>。遇到“ ( ”直接入栈；遇到“ ）”则依次弹出栈内运算符并加入后缀表达式，直到弹出“（ ”为止。<font color='cornflowerblue'>注意“ ( ”不加入后缀表达式</font>.</li><li>遇到<font color='red'>运算符</font>。依次弹出栈中<font color='orange'>优先级高于或等于</font>当前运算符的所有运算符，并加入后缀表达式，若碰到”（ “或栈空则停止。之前再把当权运算符入栈。</li></ul></li><li>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</li></ul><h4 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h4><p><strong>手算过程</strong></p><ul><li>从左往右扫描，每遇到一个运算符，就让<font color='orange'>运算符前面的两个操作数</font>执行对应运算，<font color='orange'>合体为一个操作数</font>。</li></ul><p><strong>计算过程</strong></p><ul><li>从左往右扫描下一个元素，直到处理完所有元素。</li><li>若扫描到<font color='orange'>操作数则压入栈</font>,并回到上一步，否则执行下一步。</li><li>若扫到操作数，则弹出两个栈顶元素，<font color='red'>先弹出的栈顶元素为右操作数</font>，执行对应运算，运算结果压回到栈顶，回到第一步。</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>适合“递归”算法：可以把原始问题转换成<font color='red'>属性相同</font>，但<font color='red'>规模较小</font>的问题</li></ul>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/1f4ac2fb/#disqus_thread</comments>
    </item>
    
    <item>
      <title>线性表</title>
      <link>http://yoursite.com/posts/40f24371/</link>
      <guid>http://yoursite.com/posts/40f24371/</guid>
      <pubDate>Tue, 29 Jun 2021 10:00:39 GMT</pubDate>
      <description>
      
        顺序表、链表的操作以及两者不同点
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义（逻辑结构）"><a href="#定义（逻辑结构）" class="headerlink" title="定义（逻辑结构）"></a>定义（逻辑结构）</h3><p>线性表是具有<font color='cornflowerblue'>相同</font>数据类型的n（n≥0）个<font color='red'>数据元素</font>的<font color='red'>有限序列</font>，其中n为<font color='red'>表长</font>，当n = 0时，线性表是一个<font color='red'>空表</font>。若用L命名线性表，则一般表示为：L = (a1,a2,….,ai,ai+1….,an)。</p><ul><li>相同数据类型：每个数据元素所占用的空间一样大。</li><li>序列：有次序。</li><li>有限：数据元素是有限的，如若“所有的整数按递增次序排列，并<font color='red'>不是线性表</font>”。</li><li>描述线性表时，角标是从1开始的</li><li>ai是线性表中“第i个”元素线性表中的<font color='red'>位序</font>，<strong>从1开始</strong></li><li>a1是<font color='red'>表头元素</font>，an是<font color='red'>表尾元素</font>。</li></ul><p><strong>线性表的逻辑特性：除了第一个元素之外，每一个元素有且仅有一个直接前驱。除最后一个元素外，每一个元素有且仅有一个直接后驱</strong></p><h3 id="为什么要实现数据结构的操作"><a href="#为什么要实现数据结构的操作" class="headerlink" title="为什么要实现数据结构的操作"></a>为什么要实现数据结构的操作</h3><ul><li>团队合作编程，你定义的数据结构要让别人能够很方便的使用（封装）</li><li>将常用的操作/运算封装成函数，避免重复工作，降低出错的风险</li></ul><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   初始化表 InitList(&amp;L)</span><br><span class="line">   销毁表 DestoryList(&amp;L)</span><br><span class="line">   插入  ListInsert(&amp;L,i,e)</span><br><span class="line">删除  Listdelete(&amp;L,i,&amp;e)</span><br><span class="line">   按值查找LocateElem(L,e)</span><br><span class="line">   按位查找GetElem(L,i)</span><br><span class="line">   表长 Length(L)</span><br><span class="line">   输出操作 PrintList(L)</span><br><span class="line">   判空操作 Empty(L)</span><br></pre></td></tr></table></figure><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><h3 id="代码问题"><a href="#代码问题" class="headerlink" title="代码问题"></a>代码问题</h3><ul><li>如何判空</li><li>如何判断结点是否在表尾或者表头结点<ul><li>后向/前向遍历的实现核心</li></ul></li><li>如何在表头、表中、表尾插入/删除一个结点<ul><li>插入、删除操作的不易错思路</li></ul></li></ul><h2 id="顺序表（顺序存储）"><a href="#顺序表（顺序存储）" class="headerlink" title="顺序表（顺序存储）"></a>顺序表（顺序存储）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>顺序表</strong>——用<font color='red'>顺序存储</font>的方式实现线性表</p><p>顺序存储:把<font color='red'>逻辑上响铃</font>的元素存储在<font color='red'>物理位置上也相邻</font>的存储单元中，元素之间的关系由存储单元的邻接关系来体现</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li><p>静态分配</p><ul><li>静态分配的实现下，如果数组存满了——》放弃治疗，顺序表的表长刚开始就已经确定了，无法更改。</li></ul></li><li><p>动态分配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;<span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;    <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList; <span class="comment">//顺序表的类型定义</span></span><br><span class="line"><span class="comment">// new delete</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><strong>随机访问</strong>：即可以在O(1)时间内找到第i个元素</li><li><strong>存储密度高</strong>：每个节点只存储数据元素。</li><li><strong>拓展不方便</strong>：即使采用动态分配的方式实现，拓展长度的时间复杂度也比较高</li><li><strong>删除、插入操作不方便，需要移动大量元素。</strong></li></ol><h3 id="基本操作-静态分配"><a href="#基本操作-静态分配" class="headerlink" title="基本操作(静态分配)"></a>基本操作(静态分配)</h3><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length;    <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList; <span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure><p><strong>初始化表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(&amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MaxSize; i ++)&#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;<span class="comment">//将所有数据元素设置为默认初始值</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>; <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入操作</strong></p><ul><li><strong>注意位序、数组下标的关系,位序 = 数组下标 + 1</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表L中的第i个位置上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = L.length;j &gt;= i;j--)<span class="comment">//将第i个元素及以后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e;<span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;<span class="comment">// 长度加1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：T = O(n)</strong> </li></ul><p><strong>删除操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除表L中的第i个位置的元素，并用引用变量e返回，后续元素依次前移一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Listdelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; L.length; j++)</span><br><span class="line">        L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">    L.length--;<span class="comment">//线性表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：T = O(n)</strong> </li></ul><p><strong>按值查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表L中查找给定元素的位序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L.length;i++)</span><br><span class="line">       <span class="keyword">if</span>(L.data[i] == e) <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//下标为i的元素值等于e,返回值器位序 i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：T = O(n)</strong> </li></ul><p><strong>按位查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表L中查找具有给定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length)<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度：T = O(1)</strong> </li></ul><h2 id="链表-链式存储"><a href="#链表-链式存储" class="headerlink" title="链表(链式存储)"></a>链表(链式存储)</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><strong>定义</strong>：每个节点除了存放数据元素之外，还要存储指向下一个节点的指针。</p><p>优缺点</p><ul><li>优点：不要求大片连续空间，改变容量方便。</li><li>缺点：不可随机存取，需要耗费一定空间存放指针。</li></ul><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span><span class="comment">//定义单链表结构点类型</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针域</span></span><br><span class="line">&#125;LNode,^LinkList;</span><br><span class="line"><span class="comment">//强调这是一个单链表--使用LinkList</span></span><br><span class="line"><span class="comment">//强调这是一个结点 --使用LNode *</span></span><br></pre></td></tr></table></figure><h5 id="不带头节点的单链表"><a href="#不带头节点的单链表" class="headerlink" title="不带头节点的单链表"></a>不带头节点的单链表</h5><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;<span class="comment">//空表。暂时还没有任何一个结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断为空</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表L中的第i个位置(位序)上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;<span class="comment">//插入第1个结点的操作与其他结点操作不同。</span></span><br><span class="line">        LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;<span class="comment">//头指针指向新节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;<span class="comment">//指针p指向当前扫描到的节点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;<span class="comment">//当前p指向的是第几个节点</span></span><br><span class="line">    p = L;<span class="comment">//L指向第1个结点（不是头结点）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;<span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="带头节点的单链表"><a href="#带头节点的单链表" class="headerlink" title="带头节点的单链表"></a>带头节点的单链表</h5><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//分配一个头节点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//头节点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头结点看成是第0个结点；</span></span><br></pre></td></tr></table></figure><p><strong>判断为空</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在表L中的第i个位置(位序)上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;<span class="comment">//指针p指向当前扫描到的节点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//当前p指向的是第几个节点</span></span><br><span class="line">    p = L;<span class="comment">//L指向头节点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;<span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)</li></ul><p><strong>指定结点的后插操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后插操作：在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNode</span><span class="params">(LNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>( s == <span class="literal">NULL</span>)<span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;<span class="comment">//用结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//将结点s连接到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(1)</li></ul><p><strong>指定结点的前插操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之后前入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNode</span><span class="params">(LNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>( s == <span class="literal">NULL</span>)<span class="comment">//内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    由于找不到p结点的前一个结点，但为了实现前插操作，这里使用后插操作，将s插入p之后，</span></span><br><span class="line"><span class="comment">    再将s、p的数据进行交换，以达到前插操作的效果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;<span class="comment">//将结点s连接到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data;<span class="comment">//用s、p交换数据</span></span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(1)</li></ul><p><strong>按位序删除</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L.<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;<span class="comment">//指针p指向当前扫描的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//当前p指向的是第几个节点</span></span><br><span class="line">    p = L;<span class="comment">//L指向头结点，头节点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span>( p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;<span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)<span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;<span class="comment">//令q指向被删除结点</span></span><br><span class="line">    e = q-&gt;data;<span class="comment">//用e返回元素的值</span></span><br><span class="line">    p-&gt;next = q-next;<span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q)<span class="comment">//释放结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)</li></ul><p><strong>删除指定结点p</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里p结点不能是最后一个结点，否者p-&gt;next = NULL,而p-&gt;next-data就会出现错误</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;<span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data<span class="comment">//和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;<span class="comment">//将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q)<span class="comment">//释放后继节点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(1)</li></ul><p><strong>按位查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素（带头结点）</span></span><br><span class="line"><span class="function">LNode * <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;<span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123; <span class="comment">// 循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i值不合法，则返回一个NULL</span></span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)</li></ul><p><strong>按值查找</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域 == e的结点</span></span><br><span class="line"><span class="function">LNode * <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; !check(p-data,e))<span class="comment">//check函数：两个ElemType是否相等</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)</li></ul><p><strong>表的长度</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;<span class="comment">//check函数：两个ElemType是否相等</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)</li></ul><h4 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li>初始化一个单链表</li><li>每次取一个数据元素，插入到表尾/表头</li></ol><h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法建立单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;<span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="keyword">int</span> x;<span class="comment">//设置ElemType为整形</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//建立头节点</span></span><br><span class="line">    LNode *s,*r = L;<span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;永远保持r(尾指针)指向最后一个结点</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;<span class="comment">//尾结点设置为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)</li></ul><h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建头结点;</span></span><br><span class="line">    L-next = <span class="literal">NULL</span>;<span class="comment">//初始化为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);<span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//创建新的结点</span></span><br><span class="line">        s.data = x;</span><br><span class="line">        s.next = L-&gt;next;</span><br><span class="line">        L-next = s;<span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>时间复杂度</strong>：O(n)</li><li>应用于链表的逆置</li></ul><h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span><span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ELemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>.*<span class="title">next</span>;</span><span class="comment">//前驱和后继结点</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br></pre></td></tr></table></figure><p><strong>初始化双链表</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));<span class="comment">//分配头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//内存不足，分配失败；</span></span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;<span class="comment">//头结点的prior永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为空</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DNodeList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; s == <span class="literal">NULL</span>)<span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-next != <span class="literal">NULL</span>)<span class="comment">//如果p结点有后继结点</span></span><br><span class="line">        p-next-prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)<span class="comment">//非法参数</span></span><br><span class="line">       DNode *q = p-&gt;next;<span class="comment">//找到p的后继节点</span></span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)<span class="comment">//p没有后续结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-next = q-&gt;next;</span><br><span class="line">   <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)<span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-next-prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span><span class="comment">//定义单链表结点类型</span></span><br><span class="line">    ElemType data;<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;<span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判空</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>是否达到表尾</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(LinkList L,LNode *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">表头结点的prior指向表尾结点；</span><br><span class="line">表尾结点的next指向头结点；</span><br></pre></td></tr></table></figure><p><strong>结构体定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;<span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;<span class="comment">//头结点的next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判空</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>是否达到表尾</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断结点p是否为循环双链表的表尾结点 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L,DNode *p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>静态链表借组数组来描述线性表中的链式存储结构。</li><li>分配一整片<strong>连续</strong>的内存空间，各个结点集中安置。</li></ul><p><strong>优缺点</strong></p><ul><li>优点<ul><li>增删操作不需要大量移动元素</li></ul></li><li>缺点<ul><li>不能随机存取</li><li>只能从头结点开始依次往后查找</li><li><font color='red'>容量固定不可变</font></li></ul></li></ul><h2 id="顺序表与链表对比"><a href="#顺序表与链表对比" class="headerlink" title="顺序表与链表对比"></a>顺序表与链表对比</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul><li>都属于线性表，都是线性结构</li></ul><h3 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构/存储结构"></a>物理结构/存储结构</h3><h4 id="顺序表（顺序存储）-1"><a href="#顺序表（顺序存储）-1" class="headerlink" title="顺序表（顺序存储）"></a>顺序表（顺序存储）</h4><ul><li>优点<ul><li>支持随机存取</li><li>存储密度高</li></ul></li><li>缺点<ul><li>大片连续空间分配不方便</li><li>改变容量不方便</li></ul></li></ul><h4 id="链表（链式存储）"><a href="#链表（链式存储）" class="headerlink" title="链表（链式存储）"></a>链表（链式存储）</h4><ul><li>优点<ul><li>离散的小空间分配方便</li><li>改变容量方便</li></ul></li><li>缺点<ul><li>不可随机存取</li><li>存储密度低</li></ul></li></ul><h3 id="数据的运算-基本操作"><a href="#数据的运算-基本操作" class="headerlink" title="数据的运算/基本操作"></a>数据的运算/基本操作</h3><ul><li><p>按值查找</p><ul><li>顺序表<ul><li>无序——O(n)</li><li>有序——O(log2n)</li></ul></li><li>链表<ul><li>O(n)</li></ul></li></ul></li><li><p>按序查找</p><ul><li>顺序表<ul><li>O(1)</li></ul></li><li>链表<ul><li>O(n)</li></ul></li></ul></li><li><p>插入/删除</p><ul><li>顺序表,<strong>时间开销主要来自于移动元素</strong><ul><li>O(n)</li></ul></li><li>链表<strong>时间开销主要来自于查找元素</strong><ul><li>O(n)</li></ul></li></ul></li></ul><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li>表长难以预估、经常要增加/删除元素  ——链表</li><li>表长可估计，查询（搜索）操作比较多  ——顺序表</li></ul><h3 id="开放性问题答题思路"><a href="#开放性问题答题思路" class="headerlink" title="开放性问题答题思路"></a>开放性问题答题思路</h3><p>eg：实现线性表时，用顺序表还是链表好</p><p>：顺序表和链表的<font color='red'>逻辑结构</font>都是线性结构的，都属于线性表。</p><p>但是二者的<font color='red'>存储结构</font>不同，顺序表采用顺序存储….(特点，带来的优缺点)；链表采用链式存储…(特点，导致的优缺点)。</p><p>由于采用不同的存储方式实现，因此<font color='red'>基本操作</font>的实现效率也不同。<font color='red'>当初始化时</font>，…;<font color='red'>当插入数据元素时</font>，…;<font color='red'>当删除数据元素时</font>，…;当<font color='red'>查找一个数据元素时</font>,…;</p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/40f24371/#disqus_thread</comments>
    </item>
    
    <item>
      <title>高精度运算</title>
      <link>http://yoursite.com/posts/7de295bc/</link>
      <guid>http://yoursite.com/posts/7de295bc/</guid>
      <pubDate>Tue, 22 Jun 2021 04:26:00 GMT</pubDate>
      <description>
      
        高精度加法，高精度减法，大数乘以小数，大数除以小数
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="大整数相加"><a href="#大整数相加" class="headerlink" title="大整数相加"></a>大整数相加</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><h5 id="如何存储"><a href="#如何存储" class="headerlink" title="如何存储"></a>如何存储</h5><p>例如存储123456789，我们把每一位都存在数组中,这里我们数组中的第0位存数字9，这是因为两数相加可能会出现进位的现象，倒过来存储方便于加一位。</p><h5 id="运算：模拟人工加法"><a href="#运算：模拟人工加法" class="headerlink" title="运算：模拟人工加法"></a>运算：模拟人工加法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      1 2 3</span><br><span class="line">    +   8 9 </span><br><span class="line">    --------</span><br><span class="line">      2 1 2</span><br><span class="line">&#x2F;**</span><br><span class="line">  1、3 + 9 &#x3D; 12 》10.所以进一位</span><br><span class="line">  2、2 + 8 +1 &#x3D; 11 &gt; 10,所以进一位</span><br><span class="line">  3、1 + 1 &#x3D; 2 &lt; 10,所以不进位</span><br><span class="line">**&#x2F;</span><br><span class="line">注意：这里有进位</span><br></pre></td></tr></table></figure><h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>() ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a><strong>高精度加法</strong></h5><blockquote><p>给定两个正整数，计算它们的和。</p><p><strong>输入格式</strong></p><p>共两行，每行包含一个整数。</p><p><strong>输出格式</strong></p><p>共一行，包含所求的和。</p><p><strong>数据范围</strong></p><p>1≤整数长度≤1000001≤整数长度≤100000</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;12</span><br><span class="line">&gt;23</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;35</span><br></pre></td></tr></table></figure></blockquote><p><strong>解答代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">//这里用于存储进位</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="comment">//每一次计算的结果都是 A[i]+B[i]+t</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里全部都算完后，t！=0时，我们还需要把t放入到最前面</span></span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">     <span class="comment">//反向存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span> ;i &gt;= <span class="number">0</span>; i --) A.push_back(a[i] -<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span> ;i &gt;= <span class="number">0</span>; i --) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">vector</span> C = add(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大数相减"><a href="#大数相减" class="headerlink" title="大数相减"></a>大数相减</h3><h4 id="运算：模拟人工减法"><a href="#运算：模拟人工减法" class="headerlink" title="运算：模拟人工减法"></a>运算：模拟人工减法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      1 2 3</span><br><span class="line">    -   8 9 </span><br><span class="line">    --------</span><br><span class="line">        3 4</span><br><span class="line">&#x2F;**</span><br><span class="line">  1、3&lt;9,所以需要向上借位</span><br><span class="line">  2、2 - 1 &lt; 8,所以需要向上借位</span><br><span class="line">  3、1 - 1 ≥ 0,所以不需要向上借位</span><br><span class="line">**&#x2F;</span><br><span class="line">注意：这里有借位</span><br></pre></td></tr></table></figure><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><ol><li>为了计算A-B，我们先判断出A，B哪一个数值大，方便计算，并且最高位一定不需要向上借位，这样子就减少了边界情况<ol><li>如果 A &gt; B ，我们就直接A-B</li><li>如果 A &lt; B , 我们就计算 —(A - B);</li></ol></li><li>如果 A[i] - B[i] -t 是否大于等于0<ol><li>大于等于0；就不需要向上借位，直接计算</li><li>小于0，就需要上借位，计算A[i] + 10 - B[i] -t，并且设置 t=0; </li></ol></li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><h5 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h5><blockquote><p>给定两个正整数，计算它们的差，计算结果可能为负数。</p><p><strong>输入格式</strong></p><p>共两行，每行包含一个整数。</p><p><strong>输出格式</strong></p><p>共一行，包含所求的差。</p><p><strong>数据范围</strong></p><p>1≤整数长度≤1051≤整数长度≤105</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;32</span><br><span class="line">&gt;11</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;21</span><br></pre></td></tr></table></figure></blockquote><p><strong>答案</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较 A &gt; B的大小</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span> ;i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//t表示是否借位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t = t - B[i];</span><br><span class="line">        C.push_back( (t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除去前导零</span></span><br><span class="line">    <span class="keyword">while</span>( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span> ) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">bool</span> T = com(A,B);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">if</span>(com(A,B))&#123;</span><br><span class="line">        C = sub(A,B);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        C = sub(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大数乘以小数"><a href="#大数乘以小数" class="headerlink" title="大数乘以小数"></a>大数乘以小数</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>这里我们把小数看成一个整体，而不是一位一位乘，这样就不需要考虑加法的运算</p><h4 id="运算：模拟人工乘法"><a href="#运算：模拟人工乘法" class="headerlink" title="运算：模拟人工乘法"></a>运算：模拟人工乘法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      1 2 3</span><br><span class="line">    *   1 2 </span><br><span class="line">    --------</span><br><span class="line">         </span><br><span class="line">&#x2F;**</span><br><span class="line">1、(3 * 12) % 10 &#x3D; 6</span><br><span class="line">    t &#x3D; (3 * 12) &#x2F;10 &#x3D; 3</span><br><span class="line">    2、(2 * 12 + t) % 10 &#x3D; 7</span><br><span class="line">    t &#x3D; (2 * 12 + t) &#x2F; 10 &#x3D; 2</span><br><span class="line">    3、(1 * 12 + t) % 10 &#x3D; 4</span><br><span class="line">    t &#x3D; (1 * 12 + t) &#x2F; 10 &#x3D; 1</span><br><span class="line">**&#x2F;</span><br><span class="line">注意：这里有进位</span><br></pre></td></tr></table></figure><h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//除去前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><h5 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h5><blockquote><p>给定两个正整数 AA 和 BB，请你计算 A×BA×B 的值。</p><p><strong>输入格式</strong></p><p>共两行，第一行包含整数 AA，第二行包含整数 BB。</p><p><strong>输出格式</strong></p><p>共一行，包含 A×BA×B 的值。</p><p><strong>数据范围</strong></p><p>1≤A的长度≤1000001≤A的长度≤100000,<br>0≤B≤100000≤B≤10000</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;2</span><br><span class="line">&gt;3</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;6</span><br></pre></td></tr></table></figure></blockquote><p><strong>答案</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">//这里是防止出现前导0，如果b=0，那就答案可能出现0000……，我们需要情况讨论，或者在后面处理以下前导0</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        C.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        t = A[i] * b + t;</span><br><span class="line">        C.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t = t/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里不能这样写，如果b = 50，A[i] = 9,那这里的t = 45，如果这样子输入，就只能输入4，而不是全部输入，所以我们需要把t循环输入</span></span><br><span class="line">    <span class="comment">//if(t != 0) C.push_back(t%10);</span></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        C.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t = t/<span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = mul(A,b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- ) <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="大数除以小数"><a href="#大数除以小数" class="headerlink" title="大数除以小数"></a>大数除以小数</h3><h4 id="运算：模拟人工除法"><a href="#运算：模拟人工除法" class="headerlink" title="运算：模拟人工除法"></a>运算：模拟人工除法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">     0 1 1 2</span><br><span class="line">    --------</span><br><span class="line"> 11√ 1 2 3 5</span><br><span class="line">     1</span><br><span class="line">    --------</span><br><span class="line">     1 2</span><br><span class="line">     1 1</span><br><span class="line">     --------</span><br><span class="line">       1 3</span><br><span class="line">       1 1</span><br><span class="line">      -------</span><br><span class="line">         2 5</span><br><span class="line">         2 2</span><br><span class="line">         -----</span><br><span class="line">           3</span><br><span class="line">&#x2F;**</span><br><span class="line">1、r &#x3D; 0 </span><br><span class="line">   (r * 10 +1) &#x2F; 10 &#x3D; 0</span><br><span class="line">       r &#x3D; (r * 10 +1) % 10 &#x3D; 1</span><br><span class="line">    2、(r * 10 +1) &#x2F; 10 &#x3D; 1</span><br><span class="line">       r &#x3D; (r * 10 +1) % 10 &#x3D; 1</span><br><span class="line">    3、(r * 10 +1) &#x2F; 10 &#x3D; 1</span><br><span class="line">       r &#x3D; (r * 10 +1) % 10 &#x3D; 2</span><br><span class="line">    4、(r * 10 +1) &#x2F; 10 &#x3D; 2</span><br><span class="line">       r &#x3D; (r * 10 +1) % 10 &#x3D; 3</span><br><span class="line"> ——————————————————————————————————————————</span><br><span class="line"> 所以答案是 0112，余数为3</span><br></pre></td></tr></table></figure><h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><h5 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h5><blockquote><p>给定两个非负整数 A，BA，B，请你计算 A/BA/B 的商和余数。</p><p><strong>输入格式</strong></p><p>共两行，第一行包含整数 AA，第二行包含整数 BB。</p><p><strong>输出格式</strong></p><p>共两行，第一行输出所求的商，第二行输出所求余数。</p><p><strong>数据范围</strong></p><p>1≤A的长度≤1000001≤A的长度≤100000,<br>1≤B≤100001≤B≤10000,<br>BB 一定不为 00</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;7</span><br><span class="line">&gt;2</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;3</span><br><span class="line">&gt;1</span><br></pre></td></tr></table></figure></blockquote><p><strong>解答</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">   r = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">       r = r*<span class="number">10</span>+A[i];</span><br><span class="line">       C.push_back(r/b);</span><br><span class="line">       r = r%b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   由于下面输入方式是从后往前面输出，而这里我们得到的真正的数值，如 0001111类型的，所以我们需要反转vector</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   reverse(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">   <span class="comment">//除去前导零</span></span><br><span class="line">   <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">   <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="comment">//r为余数</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = div(A,b,r);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- ) <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%d"</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/7de295bc/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
