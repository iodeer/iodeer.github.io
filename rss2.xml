<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>小丁的小屋</title>
    <link>http://yoursite.com/</link>
    
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>最美的相遇，不言过往；最好的离别，不问归期。</description>
    <pubDate>Fri, 18 Jun 2021 13:42:44 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>排序</title>
      <link>http://yoursite.com/posts/a444b428/</link>
      <guid>http://yoursite.com/posts/a444b428/</guid>
      <pubDate>Fri, 18 Jun 2021 13:37:13 GMT</pubDate>
      <description>
      
        快速排序和归并排序
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="主要思想-分治"><a href="#主要思想-分治" class="headerlink" title="主要思想:分治"></a>主要思想:分治</h4><p><strong>特点</strong></p><ul><li>是不稳定的</li><li><strong>时间复杂度：nlogn</strong></li></ul><p><strong>实现步骤：</strong></p><ol><li>确定分界点x，x可以取以下四类值<ol><li>q[l]</li><li>q[(l+r)/2]</li><li>q[r]</li><li>随机</li></ol></li><li><strong>调整区间</strong>：第一个区间的数都小于等于x，第二个区间的数都大于等于x；</li><li>递归处理左右两个区间</li></ol><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断边界，当数组内没有值或者只有一个值时，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//分界点：x取中间值,保证不能取到q[r]</span></span><br><span class="line">    x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//i，j取两侧值，当指针调整的时候，方便循环</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i指针往后移动，找到数组中大于x的值，停止</span></span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="comment">//找到数组中小于x的值，停止</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="comment">//如果两个指针还没有相遇，就交换值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归处理左右两端</span></span><br><span class="line">    </span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断边界，当数组内没有值或者只有一个值时，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//分界点：x取中间值，这里需要向上取整，否则会出现死循环</span></span><br><span class="line">     x = q[l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>];<span class="comment">//或者x = q[r];</span></span><br><span class="line">    <span class="comment">//i，j取两侧值，当指针调整的时候，方便循环</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i指针往后移动，找到数组中大于x的值，停止</span></span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="comment">//找到数组中小于x的值，停止</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="comment">//如果两个指针还没有相遇，就交换值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归处理左右两端</span></span><br><span class="line">    </span><br><span class="line">    quick_sort(q, l, i<span class="number">-1</span>);</span><br><span class="line">    quick_sort(q, i, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">例如q【1，2】</span></span><br><span class="line"><span class="comment">x=1，</span></span><br><span class="line"><span class="comment">初始：quick_sort(q, 0,1);</span></span><br><span class="line"><span class="comment">第一步： q[i] = 1，q[j]=2;这里q[i]&lt;x,i不移动，q[j]&gt;x,j向左移动一位</span></span><br><span class="line"><span class="comment">（i=0，j=0）</span></span><br><span class="line"><span class="comment">左边：quick_sort(q, 0, -1);结束</span></span><br><span class="line"><span class="comment">右边：quick_sort(q, 0,1);死循环</span></span><br><span class="line"><span class="comment">第二步：</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定一个长度为 nn 的整数数列，以及一个整数 kk，请用快速选择算法求出数列从小到大排序后的第 kk 个数。</p><p><strong>输入格式</strong></p><p>第一行包含两个整数 nn 和 kk。</p><p>第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整数数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示数列的第 kk 小数。</p><p><strong>数据范围</strong></p><p>1≤n≤1000001≤n≤100000,<br>1≤k≤n1≤k≤n</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;5 3</span><br><span class="line">&gt;2 4 1 5 3</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;3</span><br></pre></td></tr></table></figure><p><strong>答案</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">int</span> n,k;</span><br><span class="line">&gt;<span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> i = l<span class="number">-1</span>,j = r + <span class="number">1</span>,num = q[(l+r)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">       <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; num);</span><br><span class="line">       <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; num);</span><br><span class="line">       <span class="keyword">if</span>(i&lt;j) swap(q[i],q[j]);</span><br><span class="line">   &#125;</span><br><span class="line">   quick_sort(q,l,j),quick_sort(q,j+<span class="number">1</span>,r);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line">   quick_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>,q[k<span class="number">-1</span>]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="主要思想：分治"><a href="#主要思想：分治" class="headerlink" title="主要思想：分治"></a>主要思想：分治</h4><p><strong>特点</strong>：</p><ul><li>稳定的</li><li><strong>时间复杂度：nlogn</strong></li></ul><p><strong>实现步骤</strong>：</p><ol><li>确定分界点，mid = （l+r）/ 2</li><li>递归排序left，right</li><li><strong>归并—-合二为一</strong><ol><li>两个数组都是排好序的</li><li>两个指针指向左右两数组的第一个值，两值进行比较，小的值填入新数组的第一个值同时该指针往后移动（当两值相等时，往往把第一数组的值放在新数组中）</li><li>两值继续进行比较，小的值填入新数组的第二个值同时该指针往后移动，递归</li><li>直到某一个数组结束，另一个数组还没有结束，我们把这个数组余下的值继续填入。</li></ol></li></ol><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断边界，当数组内没有值或者只有一个值时，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//确定中点</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//递归排序</span></span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="comment">// tmp--》辅助数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line"><span class="comment">//将剩余值填入</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line"><span class="comment">//将辅助数组的数复制到原数组中</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote><p>给定一个长度为 nn 的整数数列，请你计算数列中的逆序对的数量。</p><p>逆序对的定义如下：对于数列的第 ii 个和第 jj 个元素，如果满足 i&lt;ji&lt;j 且 a[i]&gt;a[j]a[i]&gt;a[j]，则其为一个逆序对；否则不是。</p><p><strong>输入格式</strong></p><p>第一行包含整数 nn，表示数列的长度。</p><p>第二行包含 nn 个整数，表示整个数列。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示逆序对的个数。</p><p><strong>数据范围</strong></p><p>1≤n≤1000001≤n≤100000</p><p><strong>输入样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;6</span><br><span class="line">&gt;2 3 4 5 6 1</span><br></pre></td></tr></table></figure><p><strong>输出样例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;5</span><br></pre></td></tr></table></figure><p><strong><font color='red'>答案</font></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">&gt;<span class="keyword">int</span> arr[N];</span><br><span class="line">&gt;<span class="keyword">int</span> temp[N];</span><br><span class="line">&gt;<span class="keyword">int</span> n;</span><br><span class="line">&gt;<span class="keyword">unsigned</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">int</span> mid = ( l + r  ) / <span class="number">2</span>;</span><br><span class="line">   merge_sort(arr, l, mid);</span><br><span class="line">   merge_sort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(arr[i] &lt;= arr[j])</span><br><span class="line">       &#123;</span><br><span class="line">           temp[k++] = arr[i++];</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           temp[k++] = arr[j++];</span><br><span class="line">           num += (mid - i + <span class="number">1</span>);<span class="comment">//注意这里，是直接加的，后面的不需要比较了。</span></span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">while</span> ( i &lt;= mid )</span><br><span class="line">   &#123;</span><br><span class="line">       temp[k++] = arr[i++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> ( j &lt;= r )</span><br><span class="line">   &#123;</span><br><span class="line">       temp[k++] = arr[j++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++)</span><br><span class="line">   &#123;</span><br><span class="line">       arr[i] = temp[j];</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   merge_sort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%ld"</span>,num);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/a444b428/#disqus_thread</comments>
    </item>
    
    <item>
      <title>数据结构概念</title>
      <link>http://yoursite.com/posts/9aeff161/</link>
      <guid>http://yoursite.com/posts/9aeff161/</guid>
      <pubDate>Fri, 18 Jun 2021 01:26:06 GMT</pubDate>
      <description>
      
        xxx
      
      </description>
      
      
      <content:encoded><![CDATA[<h2 id="数据结构学什么"><a href="#数据结构学什么" class="headerlink" title="数据结构学什么"></a>数据结构学什么</h2><ul><li>如何利用程序代码把现实世界的问题<strong>信息化</strong></li><li>如何用计算机高效地处理这些信息从而创造价值</li></ul><blockquote><p><strong>“唯一可以确定的是，明天会使我们所有人大吃一惊”</strong></p></blockquote><h2 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h2><h3 id="数据等基本概念"><a href="#数据等基本概念" class="headerlink" title="数据等基本概念"></a>数据等基本概念</h3><p><strong>数据</strong>： 是<font color='red'>信息的载体</font>,是描述客观事物的数、字符以及所有能输入到计算机中并<font color='red'>被计算机程序识别和处理</font>的符号的集合。数据是计算机程序加工的原料。</p><p>现代计算机— 经常处理<font color='red'>非数值型</font>问题</p><p>对于非数值型问题</p><ul><li>我们关心每个个体的具体信息</li><li>我们还关心个体之间的关系</li></ul><p><strong>数据元素</strong>：描述一个个体的具体信息，是<font color='red'>数据的基本单位</font>，通常作为一个整体进行考虑和处理，一个数据元素可由锘若干<font color='red'>数据项</font>组成</p><p><strong>数据项</strong>：构成数据元素的<font color='red'>不可分割的最小单位</font>。 </p><p><strong>数据对象</strong>：是具有<font color='red'>相同性质</font>的数据元素的集合，是数据的一个子集。</p><p><strong>数据结构</strong>：是相互之间存在一种或多种特定<font color='red'>关系</font>的数据元素的集合。</p><ul><li><strong>同一个数据对象里的数据元素，可以根据关系的不同，组成不同的数据结构</strong></li><li><strong>不同的数据元素，可以组成相同的数据结构</strong></li></ul><h3 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h3><h4 id="逻辑关系"><a href="#逻辑关系" class="headerlink" title="逻辑关系"></a>逻辑关系</h4><p><strong>集合结构</strong></p><p><strong>线性结构（一对一）</strong></p><ul><li>数据元素之间都是一对一的关系</li><li>除了第一个元素，所有元素都有唯一的前驱</li><li>除了最后一个元素，所有的元素都有唯一的后继</li></ul><p><strong>树形结构（一对多）</strong></p><p><strong>图壮结构（多对多）</strong></p><h4 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h4><ul><li>针对某种逻辑结构，结合实际需求，定义<font color='red'>基本运算</font>。</li></ul><p><strong>逻辑关系和数据的运算<font color='red'>定义</font>了一种数据结构</strong></p><h4 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h4><p><strong>如何用计算机实现数据结构</strong></p><ul><li>顺序存储<ul><li><font color='red'>把逻辑上相邻的元素存储在物理位置上也相邻的存储单位中</font>，元素之间的关系由存储单元的邻接关系来体现。</li></ul></li><li>链式存储<ul><li><font color='red'>逻辑上相邻的元素在物理位置上可以不相邻</font>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</li></ul></li><li>索引存储<ul><li>在存储元素信息的同时，还建立附加的<strong>索引表</strong>。索引表中的每项称为索引项，索引项的一般形式是（<strong>关键字，地址</strong>）。</li></ul></li><li>散列存储<ul><li>根据元素的<strong>关键字</strong>直接计算出该元素的存储地址，又称为<font color='red'>哈希（Hash）存储</font>。</li></ul></li></ul><blockquote><p>1、若采用<font color='red'>顺序存储</font>，则各个数据元素在物理上必须是<font color='red'>连续的</font>；<br>     若采用<font color='red'>非顺序存储</font>，则各个数据元素在物理上可以是<font color='red'>离散的</font>；</p><p>2、数据的<font color='red'>存储结构</font>会<font color='red'>影响存储空间分配的方便程度</font>。</p><p>3、数据的<font color='red'>存储结构</font>会<font color='red'>影响对数据运算的速度</font>。</p></blockquote><blockquote><p>1、<font color='red'>运算的定义</font>是针对逻辑结构的，指出运算的功能；</p><p>2、<font color='red'>运算的实现</font>是<font color='red'>针对存储结构</font>的，指出运算的具体操作步骤</p></blockquote><h4 id="数据类型、抽象数据类型"><a href="#数据类型、抽象数据类型" class="headerlink" title="数据类型、抽象数据类型"></a>数据类型、抽象数据类型</h4><p><strong>数据类型</strong>：是一个值的集合和定义在此集合上的一组操作的总称</p><ul><li>原子类型：其值不可再分的数据结构。（例如：基本类型，如int、bool）</li><li>结构类型：其值可以在分解为若干分量（成分）的数据类型。（例如：结构体）</li></ul><p><strong>抽象数据类型</strong>：是抽象数据组织以及与之相关的操作</p><h2 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><h3 id="算法的五个特征"><a href="#算法的五个特征" class="headerlink" title="算法的五个特征"></a>算法的五个特征</h3><h3 id="“好”算法的特质"><a href="#“好”算法的特质" class="headerlink" title="“好”算法的特质"></a>“好”算法的特质</h3>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/9aeff161/#disqus_thread</comments>
    </item>
    
    <item>
      <title>中断-异常</title>
      <link>http://yoursite.com/posts/a76ffb5a/</link>
      <guid>http://yoursite.com/posts/a76ffb5a/</guid>
      <pubDate>Sun, 27 Dec 2020 02:52:58 GMT</pubDate>
      <description>
      
        了解中断的作用，中断是用户态切换到核心的唯一方式。中断的几种类别。
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="一、中断机制的诞生"><a href="#一、中断机制的诞生" class="headerlink" title="一、中断机制的诞生"></a>一、中断机制的诞生</h3><ul><li><p>在单批道处理阶段，各个程序只能串行处理，系统资利用低，为了解决上诉问题，人们发明了操作系统（作为管理者），引入中断机制，实现了多道程序并发执行</p></li><li><p><strong>本质：发生中断就意味着需要操作系统介入，开展管理工作</strong></p></li></ul><h3 id="二、中断的概念和作业"><a href="#二、中断的概念和作业" class="headerlink" title="二、中断的概念和作业"></a>二、中断的概念和作业</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><ul><li>当中断发生时，CPU立即进入<strong>核心态</strong></li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ul><h4 id="2、中断的作用"><a href="#2、中断的作用" class="headerlink" title="2、中断的作用"></a>2、中断的作用</h4><p>​    发生了中断，就意味着需要操作系统介入，发展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU需要从用户态转变成核心态。<strong>中断</strong>可以<strong>使CPU从用户态转变成核心态，使操作系统获得计算机的控制权</strong>.。有了中断，才能实现多道程序并发执行。</p><h4 id="3、用户态、核心态切换的实现"><a href="#3、用户态、核心态切换的实现" class="headerlink" title="3、用户态、核心态切换的实现"></a>3、用户态、核心态切换的实现</h4><ul><li><strong>“用户态—》核心态“</strong>是通过<strong>中断</strong>实现的。并且<strong>中断</strong>是<strong>唯一的</strong>方式</li><li>”核心态—》用户态“的切换是通过<strong>执行一个特权指令</strong>，将程序状态字（PSW）的标志位设置为”用户态“</li></ul><h3 id="三、中断-广义的中断-分类"><a href="#三、中断-广义的中断-分类" class="headerlink" title="三、中断{广义的中断}分类"></a>三、中断{广义的中断}分类</h3><h4 id="1、内中断（异常、例外、陷入）"><a href="#1、内中断（异常、例外、陷入）" class="headerlink" title="1、内中断（异常、例外、陷入）"></a>1、内中断（异常、例外、陷入）</h4><ul><li><p>信号来源：CPU内部与当前执行的指令<strong>有关</strong></p></li><li><p>自愿中断</p><ul><li>指令中断</li></ul></li><li><p>强迫中断</p><ul><li>硬件故障</li><li>软件中断</li></ul></li></ul><h4 id="2、外中断（中断-狭义的中断-）"><a href="#2、外中断（中断-狭义的中断-）" class="headerlink" title="2、外中断（中断{狭义的中断}）"></a>2、外中断（中断{狭义的中断}）</h4><ul><li><p>信号来源：CPU内部与当前执行的指令<strong>有关</strong></p></li><li><p>外设请求</p></li><li><p>人工干预</p></li></ul><h3 id="四、外中断的处理过程"><a href="#四、外中断的处理过程" class="headerlink" title="四、外中断的处理过程"></a>四、外中断的处理过程</h3><p><img src="https://i.loli.net/2020/12/15/N1OuBLW9Zj7YbAy.png" alt="image-20201215203027037"></p><h3 id="五、回顾"><a href="#五、回顾" class="headerlink" title="五、回顾"></a>五、回顾</h3><p><img src="https://i.loli.net/2020/12/15/OEjrGxoAeT5cUM4.png" alt="image-20201215203338519"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/a76ffb5a/#disqus_thread</comments>
    </item>
    
    <item>
      <title>运行机制-体系结构</title>
      <link>http://yoursite.com/posts/31685368/</link>
      <guid>http://yoursite.com/posts/31685368/</guid>
      <pubDate>Sun, 27 Dec 2020 02:52:58 GMT</pubDate>
      <description>
      
        运行机制、内核的两种类别。
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="一、运行机制"><a href="#一、运行机制" class="headerlink" title="一、运行机制"></a>一、运行机制</h3><h4 id="1、指令"><a href="#1、指令" class="headerlink" title="1、指令"></a>1、指令</h4><p>1.概念：处理器（CPU）能识别、执行的最基本命令</p><p>2.分类：</p><ul><li>特权指令：不允许用户程序使用</li><li>非特权指令</li></ul><h4 id="2、处理器状态"><a href="#2、处理器状态" class="headerlink" title="2、处理器状态"></a>2、处理器状态</h4><p>1.分类</p><ul><li>用户态（目态）：次时CPU只能执行非特权指令</li><li>核心态（管态）：特权指令、非特权指令都能执行</li></ul><p>2、怎么判断状态</p><p>用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。如 0为用户态，1为核心态。</p><h4 id="3、两种程序"><a href="#3、两种程序" class="headerlink" title="3、两种程序"></a>3、两种程序</h4><p>1.分类</p><ul><li>内核程序：操作系统的内核程序是系统的管理者。既可以执行特权指令，也可以执行非特权指令，运行在核心态。</li><li>应用程序：为了保证系统的安全运行，普通应用程序只能执行非特权指令，运行在用户态。</li></ul><h3 id="二、内核"><a href="#二、内核" class="headerlink" title="二、内核"></a>二、内核</h3><h4 id="1、图解"><a href="#1、图解" class="headerlink" title="1、图解"></a>1、图解</h4><p><img src="https://i.loli.net/2020/12/05/FZJ1NXgrkG6aMKi.png" alt="image-20201205211540841"></p><h4 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h4><ul><li><p>内核是计算机上配置的<strong>底层软件</strong>，是操作系统最基本、最核心的部分。</p></li><li><p>实现操作系统内核功能的哪些程序就是内核程序</p><p><img src="https://i.loli.net/2020/12/15/94Az5WIhvfPgsyn.png" alt="image-20201215193609256"></p></li></ul><h4 id="3、内核分类"><a href="#3、内核分类" class="headerlink" title="3、内核分类"></a>3、内核分类</h4><ul><li>大内核、微内核</li></ul><p><img src="https://i.loli.net/2020/12/15/SxdQ7uCcHRInYqZ.png" alt="image-20201215193804729"></p><ul><li><p>大内核、微内核的优缺点</p><p><img src="https://i.loli.net/2020/12/15/9tDKGPLcXmofMbw.png" alt="image-20201215194114688"></p></li><li><p>类比</p><p><img src="https://i.loli.net/2020/12/15/hcy6SJYFe7Q9ZDo.png" alt="image-20201215194403334"></p></li></ul><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p><img src="https://i.loli.net/2020/12/15/dDoiBXmfkvrjlQx.png" alt="image-20201215194829134"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/31685368/#disqus_thread</comments>
    </item>
    
    <item>
      <title>系统调用</title>
      <link>http://yoursite.com/posts/4f5d4e8d/</link>
      <guid>http://yoursite.com/posts/4f5d4e8d/</guid>
      <pubDate>Sun, 27 Dec 2020 02:52:58 GMT</pubDate>
      <description>
      
        系统调用的作业；系统调用的五种分类
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="一-什么是系统调用，有何作用"><a href="#一-什么是系统调用，有何作用" class="headerlink" title="一 什么是系统调用，有何作用"></a>一 什么是系统调用，有何作用</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提供服务请求，由操作系统代为完成</p><h4 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h4><p>可以保证系统的稳定性和安全性，防止用户进行非法操作</p><h4 id="3、分类（功能）"><a href="#3、分类（功能）" class="headerlink" title="3、分类（功能）"></a>3、分类（功能）</h4><ul><li>设备管理<ul><li>完成设备的请求/释放/启动等功能</li></ul></li><li>文件管理<ul><li>完成文件的读/写/创建/删除等功能</li></ul></li><li>进程控制<ul><li>完成进程的创建/撤销/阻塞/唤醒/等功能</li></ul></li><li>进程通信<ul><li>完成进程之间的消息传递/信号传递等功能</li></ul></li><li>内存管理<ul><li>完成内存的分配/回收等功能</li></ul></li></ul><h4 id="4、注意"><a href="#4、注意" class="headerlink" title="4、注意"></a>4、注意</h4><p>​    系统调用相关处理涉及到对系统资源的管理、对进程的控制。这些功能需要<strong>执行一些特权指令</strong>才能完成，因此<strong>系统调用的相关处理</strong>，需要<strong>在核心态完成</strong></p><h3 id="二-系统调用和函数库的区别"><a href="#二-系统调用和函数库的区别" class="headerlink" title="二 系统调用和函数库的区别"></a>二 系统调用和函数库的区别</h3><p><img src="https://i.loli.net/2020/12/18/ujoQrK3UiRtsWcw.png" alt="image-20201218111839800"></p><h3 id="三-系统调用背后的过程"><a href="#三-系统调用背后的过程" class="headerlink" title="三 系统调用背后的过程"></a>三 系统调用背后的过程</h3><p><img src="https://i.loli.net/2020/12/18/a563MetRrPnzjZh.png" alt="image-20201218112528140"></p><h3 id="四-知识回顾"><a href="#四-知识回顾" class="headerlink" title="四 知识回顾"></a>四 知识回顾</h3><p><img src="https://i.loli.net/2020/12/18/62QAHhde1g8Gpzf.png" alt="image-20201218112743161"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/4f5d4e8d/#disqus_thread</comments>
    </item>
    
    <item>
      <title>线程概念与多线程模型</title>
      <link>http://yoursite.com/posts/3971d124/</link>
      <guid>http://yoursite.com/posts/3971d124/</guid>
      <pubDate>Sun, 27 Dec 2020 02:52:58 GMT</pubDate>
      <description>
      
        线程的作用；线程的重要属性，三种实现方式，三种模型的优缺点。
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="一、什么是线程，为什么要引入线程"><a href="#一、什么是线程，为什么要引入线程" class="headerlink" title="一、什么是线程，为什么要引入线程"></a>一、什么是线程，为什么要引入线程</h3><p><img src="https://i.loli.net/2020/12/24/o7UagnA9ZLlehpB.png" alt="image-20201224103051529"></p><ul><li>线程是<strong>一个基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</li><li></li></ul><h3 id="二、引入线程机制后，有什么变化"><a href="#二、引入线程机制后，有什么变化" class="headerlink" title="二、引入线程机制后，有什么变化"></a>二、引入线程机制后，有什么变化</h3><p><img src="https://i.loli.net/2020/12/24/W5mpHxk6glcXnrP.png" alt="image-20201224103311213"></p><h3 id="三、线程的重要属性"><a href="#三、线程的重要属性" class="headerlink" title="三、线程的重要属性"></a>三、线程的重要属性</h3><p><img src="https://i.loli.net/2020/12/24/t4VSpF7yecUiY2g.png" alt="image-20201224104737922"></p><h3 id="四、实现方式"><a href="#四、实现方式" class="headerlink" title="四、实现方式"></a>四、实现方式</h3><h4 id="1、用户级线程"><a href="#1、用户级线程" class="headerlink" title="1、用户级线程"></a>1、用户级线程</h4><ul><li><p>用户级线程由应用程序通过线程库来实现的</p></li><li><p>所有的<strong>线程管理工作</strong>都由<strong>应用程序</strong>负责（包括线程切换）</p></li><li><p>用户级线程，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统的干预</p></li><li><p>用户级线程对用户不透明，对操作系统透明</p></li><li><p>用户级线程，就是“从用户视角看到的线程”</p><p><img src="https://i.loli.net/2020/12/24/g86KlfCz3BxHPhM.png" alt="image-20201224110917123"></p></li></ul><h4 id="2、内核级线程"><a href="#2、内核级线程" class="headerlink" title="2、内核级线程"></a>2、内核级线程</h4><ul><li><strong>内核级线程管理工作</strong>由<strong>操作系统内核</strong>完成。</li><li>线程调度、切换等工作都由内核完成，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成</li><li>”内核级线程“就是”从操作系统内核视角才能看到的线程“</li></ul><p><img src="https://i.loli.net/2020/12/24/UyoGcdegKJFWku7.png" alt="image-20201224111539618"></p><h4 id="3、组合模式"><a href="#3、组合模式" class="headerlink" title="3、组合模式"></a>3、组合模式</h4><ul><li>同时支持用户级线程和内核级线程，将n个用户级线程映射到m个内核级线程上（n&gt;=m）;</li><li><strong>内核级线程才是处理机分配的单位</strong></li><li><img src="https://i.loli.net/2020/12/24/jaX4oh6FTmctWRy.png" alt="image-20201224111727851"></li><li></li></ul><h3 id="五、多线程模型"><a href="#五、多线程模型" class="headerlink" title="五、多线程模型"></a>五、多线程模型</h3><h4 id="1、多对一模型"><a href="#1、多对一模型" class="headerlink" title="1、多对一模型"></a>1、多对一模型</h4><p><img src="https://i.loli.net/2020/12/24/QD4V3I7ajKLbvEn.png" alt="image-20201224112057178"></p><h4 id="2、一对一模型"><a href="#2、一对一模型" class="headerlink" title="2、一对一模型"></a>2、一对一模型</h4><p><img src="https://i.loli.net/2020/12/24/XpCsl7TmuntqGEA.png" alt="image-20201224112328130"></p><h4 id="3、多对多模型"><a href="#3、多对多模型" class="headerlink" title="3、多对多模型"></a>3、多对多模型</h4><p><img src="https://i.loli.net/2020/12/24/nZIym2Fghwp9u65.png" alt="image-20201224112443274"></p><h3 id="六、总"><a href="#六、总" class="headerlink" title="六、总"></a>六、总</h3><p><img src="https://i.loli.net/2020/12/24/SJustWoQIp1lE2f.png" alt="image-20201224112624565"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/3971d124/#disqus_thread</comments>
    </item>
    
    <item>
      <title>调度算法(FCFS,SJF,HRRN)</title>
      <link>http://yoursite.com/posts/25b3caf9/</link>
      <guid>http://yoursite.com/posts/25b3caf9/</guid>
      <pubDate>Sun, 27 Dec 2020 02:52:58 GMT</pubDate>
      <description>
      
        先来先服务（FCFS），短作业优先（SJF）、高响应比优先（HRRN）三种算法的优缺点
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="一、算法的研究思路"><a href="#一、算法的研究思路" class="headerlink" title="一、算法的研究思路"></a>一、算法的研究思路</h3><ul><li>算法思想</li><li>算法规则</li><li>这种调度算法是用于作业调度还是进程调度</li><li>抢占式？非抢占式</li><li>优缺点</li><li>是否导致<strong>饥饿</strong><ul><li>饥饿：某进程/作业长期得不到服务</li></ul></li></ul><h3 id="二、先来先服务（FCFS）"><a href="#二、先来先服务（FCFS）" class="headerlink" title="二、先来先服务（FCFS）"></a>二、先来先服务（FCFS）</h3><p>1、算法思想</p><ul><li>主要从“公平”的角度考虑</li></ul><p>2、算法规则</p><ul><li>按照作业/进程到达的先后顺序就绪服务</li></ul><p>3、用于作业/进程调度</p><ul><li>用于作业调度时，考虑的是哪个作业先到达后备队列当中</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列中</li></ul><p>4、是否抢占</p><ul><li>非抢占算法</li></ul><p>5、优缺点</p><ul><li>优点<ul><li>公平</li><li>算法实现简单</li></ul></li><li>缺点<ul><li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说体验感很差</li></ul></li><li>即 FCFS算法<strong>对长作业（进程）有利，对短作业（进程）不利</strong></li></ul><p>6、是否导致饥饿</p><ul><li>不会</li></ul><h3 id="三、短作业优先（SJF）"><a href="#三、短作业优先（SJF）" class="headerlink" title="三、短作业优先（SJF）"></a>三、短作业优先（SJF）</h3><p>1、算法思想</p><ul><li>追求最少的平均等待时间，最少的平均周转时间，最少的平均平均带权周转时间</li></ul><p>2、算法规则</p><ul><li>最短作业/进程优先得到服务（所谓最短是指要求<strong>服务时间最短</strong>）</li></ul><p>3、用于作业/进程调度</p><ul><li>用于作业调度，叫做短作业优先调度算法（SJF）</li><li>用于进程调度，叫做短进程优先调度算法（SPF）</li></ul><p>4、是否抢占</p><ul><li>SJF和SPF是<strong>非抢占式</strong>的算法</li><li><strong>最短剩余时间优先算法（SRTN，shortest Remaing Time Next）</strong></li></ul><p>5、优缺点</p><ul><li>优点<ul><li><strong>“最短的”</strong>平均等待时间，平均周转时间</li></ul></li><li>缺点<ul><li>不公平<ul><li>对于“<strong>短作业有利、对长作业不利</strong>”，可能产生<strong>饥饿现象</strong>，</li><li>作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li></ul></li></ul><p>6、是否导致饥饿</p><ul><li>会导致饥饿，<ul><li>如果由源源不断的短作业/进程到来，可能使得长作业/进程长时间得不到服务，产生<strong>“饥饿”现象</strong>，如果一直得不到服务，则称为<strong>“饿死”</strong></li></ul></li></ul><p>7、注意细节</p><p><img src="https://i.loli.net/2020/12/26/7vdYbnfWrMxwNBD.png" alt="image-20201226173431484"></p><p>8、计算</p><ul><li>非抢占式的短作业优先调度算法</li></ul><p><img src="https://i.loli.net/2020/12/26/C9DEQlL3reqT7XK.png" alt="image-20201226163453336"></p><ul><li>抢占式的短作业优点调度算法</li></ul><p><img src="https://i.loli.net/2020/12/26/RzsOhuCHkGWjP23.png" alt="image-20201226163933556"></p><p><img src="https://i.loli.net/2020/12/26/NKbXQFDMOvhit9p.png" alt="image-20201226164020154"></p><h3 id="四、高响应比优先（HRRN）"><a href="#四、高响应比优先（HRRN）" class="headerlink" title="四、高响应比优先（HRRN）"></a>四、高响应比优先（HRRN）</h3><p>1、算法思想</p><ul><li>综合考虑作业/进程的等待时间和要求服务时间</li></ul><p>2、算法规则</p><ul><li>在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高的</strong>作业/进程为其服务</li><li>响应比 = (等待时间 + 要求服务时间)  / 要求服务时间</li></ul><p>3、用于作业/进程调度</p><ul><li>可用于作业调度</li><li>可用于进程调度</li></ul><p>4、是否抢占</p><ul><li><strong>非抢占式算法</strong><ul><li>只有当前进程/作业主动放弃处理机，才需要调度，才需要计算响应比</li></ul></li></ul><p>5、优缺点</p><ul><li>优点<ul><li>综合考虑了等待时间和运行时间（要求服务时间）</li><li>等待时间相同时，要求服务时间短的优先（SJF的优点）</li><li>要求服务时间相同时，等待时间长的优先（FCFS的优点）</li><li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免的长作业饥饿的问题</li></ul></li></ul><p>6、是否导致饥饿</p><ul><li>不会导致饥饿</li></ul><p>7、计算</p><p><img src="https://i.loli.net/2020/12/26/NlZCXLD7ArREU8p.png" alt="image-20201226174523153"></p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><img src="https://i.loli.net/2020/12/26/E7jOTMYgaVRzpFJ.png" alt="image-20201226175523961"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/25b3caf9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>调度算法的评判标准</title>
      <link>http://yoursite.com/posts/110d173/</link>
      <guid>http://yoursite.com/posts/110d173/</guid>
      <pubDate>Sun, 27 Dec 2020 02:52:58 GMT</pubDate>
      <description>
      
        CPU利用率、系统吞吐量、周转时间、平均周转时间、带权周转时间、平均带权周转时间、等待时间、平均等待时间的计算方式。
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="一、CPU利用率"><a href="#一、CPU利用率" class="headerlink" title="一、CPU利用率"></a>一、CPU利用率</h3><ul><li>CPU“忙碌”的时间占总时间的比例</li><li>利用率 = 忙碌的时间 / 总时间</li></ul><p><img src="https://i.loli.net/2020/12/26/Dzav7BIkj8Z3Spe.png" alt="image-20201226112636011"></p><h3 id="二、系统吞吐量"><a href="#二、系统吞吐量" class="headerlink" title="二、系统吞吐量"></a>二、系统吞吐量</h3><ul><li><strong>系统吞吐量</strong>：单位时间内完成作业的数量</li><li><strong>系统吞吐量</strong> = 总共完成了多少作业 / 总共花了多少时间</li></ul><p><img src="https://i.loli.net/2020/12/26/G7SYZwVAfk28DJF.png" alt="image-20201226112952425"></p><h3 id="三、周转时间"><a href="#三、周转时间" class="headerlink" title="三、周转时间"></a>三、周转时间</h3><ul><li>周转时间：指作业<strong>被提交到系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔</li><li>包括四个部分<ul><li>作业在外存。后备队列上等待作业调度（高级调度）的时间</li><li>进程在就绪队列上等待进程调度（低级调度）的时间</li><li>进程在CPU上执行的时间</li><li>进程等待I/O操作完成的时间</li></ul></li><li><strong>后三个部分在一个作业上在整个处理过程中，可能发生多次。</strong></li></ul><h4 id="1、周转时间、平均周转时间"><a href="#1、周转时间、平均周转时间" class="headerlink" title="1、周转时间、平均周转时间"></a>1、周转时间、平均周转时间</h4><ul><li>（作业）周转时间 = 作业完成时间 — 作业提交时间<ul><li>对于用户来说，更关心自己的单个作业的周转时间</li></ul></li><li>平均周转时间 = 各个作业时间之和 / 作业数<ul><li>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业的周转时间的平均值</li></ul></li></ul><h4 id="2、带权周转时间、平均带权周转时间"><a href="#2、带权周转时间、平均带权周转时间" class="headerlink" title="2、带权周转时间、平均带权周转时间"></a>2、带权周转时间、平均带权周转时间</h4><ul><li>带权周转时间 = 作业周转时间 / 作业实际运行的时间 = （作业完成时间-作业提交的时间） / 作业实际运行的时间<ul><li>带权周转时间越低，用户满意度更高</li><li>带权周转时间必然 &gt;= 1</li><li>带权周转时间与周转时间都是越小越好</li></ul></li><li>平均带权周转时间 = 各个作业带权周转时间之和 / 作业数</li></ul><h3 id="四、等待时间"><a href="#四、等待时间" class="headerlink" title="四、等待时间"></a>四、等待时间</h3><ul><li><strong>等待时间</strong>：指<strong>进程/作业处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低</li><li>对于<strong>进程</strong>来说,，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所有不计入的等待时间</li><li>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong></li></ul><h3 id="五、响应时间"><a href="#五、响应时间" class="headerlink" title="五、响应时间"></a>五、响应时间</h3><ul><li>响应时间：指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间</li></ul><h3 id="六、计算"><a href="#六、计算" class="headerlink" title="六、计算"></a>六、计算</h3><p><img src="https://i.loli.net/2020/12/26/Fv4Sdg6MkT7InNA.png" alt="image-20201226162238234"></p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p><img src="https://i.loli.net/2020/12/26/RO7BiEb5LnhSKpq.png" alt="image-20201226160424754"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/110d173/#disqus_thread</comments>
    </item>
    
    <item>
      <title>进程状态的转换</title>
      <link>http://yoursite.com/posts/ada646f9/</link>
      <guid>http://yoursite.com/posts/ada646f9/</guid>
      <pubDate>Sun, 27 Dec 2020 02:52:58 GMT</pubDate>
      <description>
      
        进程的五种状态以及各状态之前的转换。
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="一、概括"><a href="#一、概括" class="headerlink" title="一、概括"></a>一、概括</h3><p><img src="https://i.loli.net/2020/12/22/EOQtlMj316C72vV.png" alt="image-20201222200250316"></p><h3 id="二、进程的状态"><a href="#二、进程的状态" class="headerlink" title="二、进程的状态"></a>二、进程的状态</h3><h4 id="1、三种基本状态"><a href="#1、三种基本状态" class="headerlink" title="1、三种基本状态"></a>1、三种基本状态</h4><ul><li>运行态<ul><li>占用CPU，并在CPU上运行</li><li>在单核处理机环境下，每一个时刻最多只由一个进程处于运行态（双核环境下由两个进程处于运行态）</li></ul></li><li>就绪态<ul><li>依据具备运行条件，但由于没有空闲的CPU，而暂时不能运行。</li><li>进程已经拥有了除处理机之外的所有需要的资源，一旦获取处理机，就可以立刻进入运行态开始运行</li></ul></li><li>阻塞态<ul><li>因等待一事件而暂时不能运行</li></ul></li></ul><h4 id="2、另外两种状态"><a href="#2、另外两种状态" class="headerlink" title="2、另外两种状态"></a>2、另外两种状态</h4><ul><li>创建状态<ul><li>操作系统需要完成创建进程，操作系统为该进程分配所需要的内存空间等资源，并为其初始化PCB</li></ul></li><li>终止状态<ul><li>进程运行结束，需要撤销进程</li><li>操作系统需要完成撤销进程相关的工作，完成将分配给进程的资源回收，撤销进程PCB等工作</li></ul></li></ul><h3 id="三-进程的转换"><a href="#三-进程的转换" class="headerlink" title="三 进程的转换"></a>三 进程的转换</h3><p><img src="https://i.loli.net/2020/12/22/CFziGAK976WSVQf.png" alt="image-20201222202632115"></p><h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h3><p><img src="https://i.loli.net/2020/12/22/mo21wSXtpCODsYr.png" alt="image-20201222202732624"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/ada646f9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>进程调度的时机、切换与过程、调度方式</title>
      <link>http://yoursite.com/posts/7f586123/</link>
      <guid>http://yoursite.com/posts/7f586123/</guid>
      <pubDate>Sun, 27 Dec 2020 02:52:58 GMT</pubDate>
      <description>
      
        进程在什么时候进行调度、进程切换的注意点、抢占式和非抢占式两种调度方式。
      
      </description>
      
      
      <content:encoded><![CDATA[<h3 id="一、时机"><a href="#一、时机" class="headerlink" title="一、时机"></a>一、时机</h3><h4 id="1、什么时候需要进程调度"><a href="#1、什么时候需要进程调度" class="headerlink" title="1、什么时候需要进程调度"></a>1、什么时候需要进程调度</h4><ul><li>当前运行的进程<strong>主动放弃</strong>处理机(<strong>在有的系统中只允许进程主动放弃处理机</strong>)<ul><li>进程正常终止</li><li>进程发生异常而终止</li></ul></li><li>当前运行的进程<strong>被动放弃</strong>处理机<ul><li>分给进程的时间片用完了</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul><h4 id="2、什么时候不能进行进程调度"><a href="#2、什么时候不能进行进程调度" class="headerlink" title="2、什么时候不能进行进程调度"></a>2、什么时候不能进行进程调度</h4><ul><li>在<strong>处理中断</strong>的过程中。</li><li>进程在<strong>操作系统内核程序临界区</strong>中<ul><li>进程<strong>是可以在</strong>普通临界区中是可以进行调度与切换的</li></ul></li><li>在<strong>原子操作过程中（原语）</strong>。</li></ul><h3 id="二、切换与过程"><a href="#二、切换与过程" class="headerlink" title="二、切换与过程"></a>二、切换与过程</h3><h4 id="1、”狭义的调度“与“切换”的区别"><a href="#1、”狭义的调度“与“切换”的区别" class="headerlink" title="1、”狭义的调度“与“切换”的区别"></a>1、”狭义的调度“与“切换”的区别</h4><ul><li>狭义的进程调度是<strong>从就绪队列中选中一个要运行的进程</strong>（这个进程可以是<strong>刚刚被暂停执行的</strong>，也可以是<strong>另一个进程</strong>，后面一种就需要<strong>进程切换</strong>）</li><li><strong>进程切换是指一个进程让出处理机，然后由另外一个进程使用处理机</strong></li><li><strong>广度的进程调度</strong>包括<strong>选择一个进程和进程切换</strong>两个步骤</li></ul><h4 id="2、进程切换的过程需要什么"><a href="#2、进程切换的过程需要什么" class="headerlink" title="2、进程切换的过程需要什么"></a>2、进程切换的过程需要什么</h4><ul><li>对原来运行进程的数据进行保存</li><li>对新进程的数据进行恢复</li></ul><h4 id="3、注意点"><a href="#3、注意点" class="headerlink" title="3、注意点"></a>3、注意点</h4><ul><li><strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁的</strong>进行<strong>进程调度，切换</strong>。必然会使<strong>整个系统的效率降低</strong>，使系统大部分时间都花在进程切换上，而真正执行进程的时间变短</li></ul><h3 id="三、方式"><a href="#三、方式" class="headerlink" title="三、方式"></a>三、方式</h3><h4 id="1、非剥夺调度方式（非抢占式）"><a href="#1、非剥夺调度方式（非抢占式）" class="headerlink" title="1、非剥夺调度方式（非抢占式）"></a>1、非剥夺调度方式（非抢占式）</h4><ul><li><strong>非剥夺调度方式</strong>，又称<strong>非抢占式</strong>。即，只允许进程主动放弃处理机。在运行状态期间即便又更加紧急的任务到达，当前进程依旧会继续使用处理机，直到该进程终止或者主动要求进入阻塞态。</li><li>优缺点<ul><li>优点<ul><li>实现简单</li><li>系统开销小</li></ul></li><li>缺点<ul><li>无法处理紧急任务</li><li>只适合早期批处理系统</li></ul></li></ul></li></ul><h4 id="2、剥夺调度方式（抢占式）"><a href="#2、剥夺调度方式（抢占式）" class="headerlink" title="2、剥夺调度方式（抢占式）"></a>2、剥夺调度方式（抢占式）</h4><ul><li><strong>剥夺调度方式</strong>，又称<strong>抢占式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或者紧急的进程需要使用处理机时，则立刻停止正在执行的进程，将处理机分配给更紧急重要的进程。</li><li>优缺点<ul><li>优点<ul><li>可以优先处理更紧急的进程</li><li>实现让各进程按时间片轮转执行的功能（通过时钟中断）</li><li>适合于分时操作系统、实时操作系统</li></ul></li></ul></li></ul><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p><img src="https://i.loli.net/2020/12/26/VaJfO2i4bG8rCtH.png" alt="image-20201226111643433"></p>]]></content:encoded>
      
      <comments>http://yoursite.com/posts/7f586123/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
