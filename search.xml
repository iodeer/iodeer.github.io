<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何新建Mybatis</title>
    <url>/posts/8fdbde0d/</url>
    <content><![CDATA[<h3 id="1、搭建环境"><a href="#1、搭建环境" class="headerlink" title="1、搭建环境"></a>1、搭建环境</h3><p>搭建数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table &#96;user&#96;(</span><br><span class="line">    &#96;id&#96; INT(20) NOT null,</span><br><span class="line">    &#96;name&#96; varchar(30) default null,</span><br><span class="line">    &#96;pwd&#96; varchar(30) default null,</span><br><span class="line">     primary key(&#96;id&#96;)</span><br><span class="line">)engine&#x3D;INNODB default charSet&#x3D;utf-8;</span><br><span class="line">Insert INTO &#96;user&#96;(&#96;id&#96;,&#96;name&#96;,&#96;pwd&#96;) values(1,&#39;小丁&#39;,&#39;123&#39;),</span><br><span class="line">    -&gt; (2,&#39;小王&#39;,&#39;456&#39;),</span><br><span class="line">    -&gt; (3,&#39;小莉&#39;,&#39;789&#39;);</span><br></pre></td></tr></table></figure>

<p>新建项目：</p>
<ol>
<li><p>新建一个普通的maven项目</p>
</li>
<li><p>删除src目录</p>
</li>
<li><p>导入maven依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入依赖--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- mybatis--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- mysql驱动--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- junit--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>1</li>
</ul>
</li>
</ol>
<h3 id="2、创建一个模块"><a href="#2、创建一个模块" class="headerlink" title="2、创建一个模块"></a>2、创建一个模块</h3><ul>
<li><p>编写mybatis的核心配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"djc1125"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>编写mybatis工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用mybatis的第一步：获取SqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。</span></span><br><span class="line">    <span class="comment">// SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3、-编写代码"><a href="#3、-编写代码" class="headerlink" title="3、 编写代码"></a>3、 编写代码</h3><ul>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", pwd='"</span> + pwd + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Dao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口实现类(由原来的UserDaoImp转变诚一个Mapper配置文件)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line">&lt;!--namespace 绑定一个对应的Dao/Mapper接口 --&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">"com.djc.dao.UserDao"</span>&gt;</span><br><span class="line">    &lt;!-- 查询语句--&gt;</span><br><span class="line">    &lt;select id=<span class="string">"getUserList"</span> resultType=<span class="string">"com.djc.pojo.User"</span>&gt;</span><br><span class="line">        select * from mybatis.user;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>namespace</p>
<p><strong>namespace中的包名要与Dao/Mapper接口的包名一致！</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="4-、测试"><a href="#4-、测试" class="headerlink" title="4 、测试"></a>4 、测试</h3><p>​    核心配置文件中注册Mappers</p>
<ul>
<li><p>junit测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//1、获取sqlSession对象</span></span><br><span class="line">       SqlSession sqlSession = MybatisUtils.getSqlSession();</span><br><span class="line">       <span class="comment">//执行sql</span></span><br><span class="line">       <span class="comment">//方式一：getMapper</span></span><br><span class="line">       UserDao userDao = sqlSession.getMapper(UserDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line">       <span class="keyword">for</span> (User user : userList) &#123;</span><br><span class="line">           System.out.println(user);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//关闭sqlsession</span></span><br><span class="line">       sqlSession.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="5、在新建项目中可能遇到的问题"><a href="#5、在新建项目中可能遇到的问题" class="headerlink" title="5、在新建项目中可能遇到的问题"></a>5、在新建项目中可能遇到的问题</h3><ul>
<li>配置文件没有注册</li>
<li>绑定接口不对</li>
<li>方法名不对</li>
<li>返回类不对</li>
<li>Maven导出资源问题<ul>
<li>解决（在pom.xml文件中写入以下代码）</li>
</ul>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在buildz中配置resource，来防止我们的资源导出失败的问题--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-笔记 -Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis简介</title>
    <url>/posts/3f7f462b/</url>
    <content><![CDATA[<h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><a id="more"></a>

<h3 id="1-1-什么是Mybatis"><a href="#1-1-什么是Mybatis" class="headerlink" title="1.1 什么是Mybatis"></a>1.1 什么是Mybatis</h3><h3 id="1-2-持久化"><a href="#1-2-持久化" class="headerlink" title="1.2 持久化"></a>1.2 持久化</h3><p>数据持久华</p>
<ul>
<li>持久化就是讲程序的数据在持久层和瞬时状态转化的过程</li>
<li>内存：<strong>断电既失</strong></li>
<li>数据库(jdbc),io文件持久化</li>
</ul>
<p><strong>为什么要持久化</strong></p>
<ul>
<li>有一些对象，不能让它丢掉</li>
<li>内存太贵了</li>
</ul>
<h3 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h3><p>Dao层、Service层、Controller层…</p>
<ul>
<li>完成持久化工作的代码块</li>
<li>层界限十分明显</li>
</ul>
<h3 id="1-4-为什么需要Mybatis"><a href="#1-4-为什么需要Mybatis" class="headerlink" title="1.4 为什么需要Mybatis"></a>1.4 为什么需要Mybatis</h3><ul>
<li>帮助程序员讲数据存入到数据库中</li>
<li>方便</li>
<li>传统的JDBC代码很复杂。简化-》框架。自动化</li>
<li>不用Mybatis也可以，但是使用后，更容易上手。<strong>（技术没有高低之分）</strong></li>
<li>优点<ul>
<li>简单易学</li>
<li>灵活</li>
<li>sql和代码的分离，提高了可维护性。</li>
<li>提供映射标签，支持对象与数据库的orm字段关系映射</li>
<li>提供对象关系映射标签，支持对象关系组建维护</li>
<li>提供xml标签，支持编写动态sql。</li>
</ul>
</li>
</ul>
<p><strong>最重要的一点：使用的人多！</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-笔记 -Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Bean的自动装配</title>
    <url>/posts/c166dc07/</url>
    <content><![CDATA[<h3 id="1、自动装配的介绍"><a href="#1、自动装配的介绍" class="headerlink" title="1、自动装配的介绍"></a>1、自动装配的介绍</h3><ul>
<li>自动装配是Spring满足bean依赖的一种方式</li>
<li>Spring会在上下文中自动寻找，并自动给bean装配属性</li>
</ul>
<p>在Spring中有三种装配的方式</p>
<ol>
<li>在xml中显示配置</li>
<li>在java中显示配置</li>
<li>隐式的自动装配bean【<strong>重要</strong>】</li>
</ol>
<h3 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h3><ol>
<li>环境搭建<ul>
<li>一个人有两个宠物</li>
</ul>
</li>
</ol>
<h3 id="3、自动装配的两种反射方式ByName、byType"><a href="#3、自动装配的两种反射方式ByName、byType" class="headerlink" title="3、自动装配的两种反射方式ByName、byType"></a>3、自动装配的两种反射方式ByName、byType</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    byName：会自动在容器上下文中查找，和自己对象set方法后面值对应的beanid</span></span><br><span class="line"><span class="comment">        弊端：必须保证id和set方法后面值相同</span></span><br><span class="line"><span class="comment">    byType：会自动在容器上下文中查找，和自己对象属性后面值对应的bean</span></span><br><span class="line"><span class="comment">        弊端：必须保证类型的class全局唯一</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.Person"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"djc"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、注解实现自动装配"><a href="#4、注解实现自动装配" class="headerlink" title="4、注解实现自动装配"></a>4、注解实现自动装配</h3><h4 id="1、环境条件："><a href="#1、环境条件：" class="headerlink" title="1、环境条件："></a>1、环境条件：</h4><ul>
<li>jdk1.5 支持注解</li>
<li>Spring2.5支持注解</li>
</ul>
<h4 id="2、官方解释："><a href="#2、官方解释：" class="headerlink" title="2、官方解释："></a>2、官方解释：</h4><p>The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML.</p>
<h4 id="3、使用注解须知"><a href="#3、使用注解须知" class="headerlink" title="3、使用注解须知"></a>3、使用注解须知</h4><ul>
<li><p>导入约束:<strong>xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;约束" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;约束</a></strong></p>
</li>
<li><p>配置注解支持：<strong><a href="context:annotation-config/">context:annotation-config/</a></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="4、注解"><a href="#4、注解" class="headerlink" title="4、注解"></a>4、注解</h4><h5 id="1、-Autowired"><a href="#1、-Autowired" class="headerlink" title="1、@Autowired"></a>1、@Autowired</h5><ul>
<li><p>直接在属性上使用即可</p>
<ul>
<li>配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cat"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.Cat"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dog"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.Dog"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.Person"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启注解支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDog</span><span class="params">(Dog dog)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCat</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cat = cat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"dog="</span> + dog +</span><br><span class="line">                <span class="string">", cat="</span> + cat +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/07/31/B5iC49UtKFOXRJz.png" alt="image-20200731093528396"></p>
<ul>
<li><p>使用@Autowired注解后，实体类中可以不需要set方法就可以完成自动装配</p>
<p><strong>前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合byType</strong></p>
<ul>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">          <span class="meta">@Autowired</span></span><br><span class="line">          <span class="keyword">private</span> Dog dog;</span><br><span class="line">          <span class="meta">@Autowired</span></span><br><span class="line">          <span class="keyword">private</span> Cat cat;</span><br><span class="line">          <span class="keyword">private</span> String name;</span><br><span class="line">      </span><br><span class="line">          <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> dog;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> cat;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> name;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.name = name;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                      <span class="string">"dog="</span> + dog +</span><br><span class="line">                      <span class="string">", cat="</span> + cat +</span><br><span class="line">                      <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                      <span class="string">'&#125;'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果</p>
<p><img src="https://i.loli.net/2020/07/31/oB4mO6u7vURLxri.png" alt="image-20200731093810226"></p>
</li>
<li><p>实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">      <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">          <span class="meta">@Autowired</span></span><br><span class="line">          <span class="keyword">private</span> Dog dog;</span><br><span class="line">          <span class="meta">@Autowired</span></span><br><span class="line">          <span class="keyword">private</span> Cat cat;</span><br><span class="line">          <span class="keyword">private</span> String name;</span><br><span class="line">      </span><br><span class="line">          <span class="function"><span class="keyword">public</span> Dog <span class="title">getDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> dog;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="function"><span class="keyword">public</span> Cat <span class="title">getCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> cat;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> name;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">this</span>.name = name;</span><br><span class="line">          &#125;</span><br><span class="line">      </span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                      <span class="string">"dog="</span> + dog +</span><br><span class="line">                      <span class="string">", cat="</span> + cat +</span><br><span class="line">                      <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                      <span class="string">'&#125;'</span>;</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试结果</p>
<p><img src="https://i.loli.net/2020/07/31/oB4mO6u7vURLxri.png" alt="image-20200731093810226"></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5、拓展"><a href="#5、拓展" class="headerlink" title="5、拓展"></a>5、拓展</h3><ol>
<li><pre><code class="xml">@Nullable 字段标记了这个注解，说明这个字段可以为null
<span class="comment"><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;java</span><br><span class="line">   public class Person &#123;</span><br><span class="line">       &#x2F;&#x2F;如果显示定义了Autowired的required属性为false，说明这个对象可以为null,即对象可以不存在IOC容器，否则不允许为空</span><br><span class="line">       @Autowired(required &#x3D; false)</span><br><span class="line">       private Dog dog;</span><br><span class="line">       @Autowired</span><br><span class="line">       private Cat cat;</span><br><span class="line">       private String name;</span><br></pre></td></tr></table></figure></span></code></pre>
</li>
<li><pre><code>@Qualifier--&gt;指定beanid，通过beanid来自动装配
    如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解[@Autowired]完成的时候，可以使用@Qualifier(value=&quot;xxx&quot;)来配置@Qualifier的使用，指定一个唯一的bean对象注入
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">public class Person &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private Dog dog;</span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(value &#x3D; &quot;catwww&quot;)</span><br><span class="line">    private Cat cat;</span><br><span class="line">    private String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li>
<li><pre><code>@Resource
@Resource(name = &quot;dog22&quot;)--》name的作用相当于@Qualifier
    @Resource在jdk11已经取消了(实验)，尽可能不适用@Resource，方便维护
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">@Resource和@Autowired区别：</span><br><span class="line">	相同点：</span><br><span class="line">		都是用来自动装配的，都可以放在属性字段上</span><br><span class="line">	不同点:</span><br><span class="line">		@Autowired 默认通过byType的方式实现，如果找不到类型，则通过byName方式实现，如果两个都找不到的情况下，就报错</span><br><span class="line">		@Resource 默认通过byName的方式实现，如果找不到类型，则通过byType方式实现，如果两个都找不到的情况下，就报错</span><br><span class="line">		执行顺序不同</span><br><span class="line">			@Autowired 通过</span><br><span class="line">			@Resource</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-笔记 -Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC理论推导</title>
    <url>/posts/ca68ff0d/</url>
    <content><![CDATA[<h3 id="1-、原来实现业务流程"><a href="#1-、原来实现业务流程" class="headerlink" title="1 、原来实现业务流程"></a>1 、原来实现业务流程</h3><ol>
<li>UserDao接口</li>
<li>UserDaoImpl实现类</li>
<li>UserService业务接口</li>
<li>UserServiceImpl业务实现类</li>
</ol>
<p>在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码！如果程序的代码量十分大，修改一次的代价十分昂贵！</p>
<h3 id="2、通过set方法降低耦合"><a href="#2、通过set方法降低耦合" class="headerlink" title="2、通过set方法降低耦合"></a>2、通过set方法降低耦合</h3><p>我们使用一个set接口实现，以及发生了革命性的变化</p>
<p><img src="https://i.loli.net/2020/07/29/Q2UygLKMIdWhtpX.png" alt="image-20200729222813217"></p>
<ul>
<li><strong>之前，程序是主动创建对象，控制权在程序猿手上</strong></li>
<li><strong>使用了set注入后，程序不再拥有主动性，而是变成了被动的接收对象</strong></li>
</ul>
<p>这种思想从本质上解决了问题，我们程序猿不用再去管理对象的创建了。</p>
<p>系统的耦合度大大降低了，可以更加专注的在业务的实现上。<strong>这是IOC的原型</strong></p>
<p><img src="https://i.loli.net/2020/07/29/d4KUb7tLpmD8RQX.png" alt="image-20200729223906856"></p>
<h3 id="3-、IOC本质"><a href="#3-、IOC本质" class="headerlink" title="3 、IOC本质"></a>3 、IOC本质</h3><p><strong>控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法，</strong>也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p>
<p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-笔记 -Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring简介</title>
    <url>/posts/70bfd15e/</url>
    <content><![CDATA[<h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><ul>
<li>Spring–春天—-&gt;给软件行业带来了春天</li>
<li>2002，首次推出了Spring框架的雏形，interface21框架</li>
<li>2004诞生</li>
<li>Rod Jahnson</li>
<li><strong>Spring的理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架</strong></li>
<li>SSH：Struct2 + Spring +Hibernate</li>
<li>SSM：SpringMVC + Spring + Mybatis</li>
</ul>
<p>官网：<a href="https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/overview.html#overview" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/5.2.8.RELEASE/spring-framework-reference/overview.html#overview</a></p>
<p>官方下载地址：<a href="https://repo.spring.io/release/org/springframework/spring/" target="_blank" rel="noopener">https://repo.spring.io/release/org/springframework/spring/</a></p>
<p>GitHub地址：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.8.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、Spring的优点"><a href="#2、Spring的优点" class="headerlink" title="2、Spring的优点"></a>2、Spring的优点</h3><ul>
<li>Spring是一个开源的免费的框架(容器)</li>
<li>是一个轻量级的、非入侵式的框架</li>
<li><strong>控制反转(IOC)、面向切面编程(AOP)</strong></li>
<li><strong>支持事务的处理</strong>，对框架整合的支持</li>
</ul>
<p><strong>==总结：Spring就是一个轻量级的控制反转（IOC）、面向切面编程（AOP）的框架==</strong>1.</p>
<h3 id="3、Spring的组成"><a href="#3、Spring的组成" class="headerlink" title="3、Spring的组成"></a>3、Spring的组成</h3><p><img src="https://i.loli.net/2020/07/29/HGFUmeQ6NDZvpa9.png" alt="image-20200729215227842"></p>
<h3 id="4-、Spring拓展"><a href="#4-、Spring拓展" class="headerlink" title="4 、Spring拓展"></a>4 、Spring拓展</h3><p>介绍：现代化的java开发，就是基于Spring的开发</p>
<p><img src="https://i.loli.net/2020/07/29/ySOud1Tv3foDQgP.png" alt="image-20200729215442631"></p>
<ul>
<li>Spring Boot<ul>
<li>一个快速开发的脚手架。</li>
<li>基于Spring Boot可以快速开发单个微服务</li>
<li>约定大于配置！</li>
</ul>
</li>
<li>Spring Cloud<ul>
<li>基于SpringBoot实现的</li>
</ul>
</li>
</ul>
<p>因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring和SpringMVC，</p>
<p>承上启下的作用！</p>
<h3 id="5、Spring的缺点"><a href="#5、Spring的缺点" class="headerlink" title="5、Spring的缺点"></a>5、Spring的缺点</h3><p><strong>弊端:发展了太久，违背了原来的理念，配置十分繁琐，人称：配置地狱</strong></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-笔记 -Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>中断-异常</title>
    <url>/posts/a76ffb5a/</url>
    <content><![CDATA[<h3 id="一、中断机制的诞生"><a href="#一、中断机制的诞生" class="headerlink" title="一、中断机制的诞生"></a>一、中断机制的诞生</h3><ul>
<li><p>在单批道处理阶段，各个程序只能串行处理，系统资利用低，为了解决上诉问题，人们发明了操作系统（作为管理者），引入中断机制，实现了多道程序并发执行</p>
</li>
<li><p><strong>本质：发生中断就意味着需要操作系统介入，开展管理工作</strong></p>
</li>
</ul>
<h3 id="二、中断的概念和作业"><a href="#二、中断的概念和作业" class="headerlink" title="二、中断的概念和作业"></a>二、中断的概念和作业</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><ul>
<li>当中断发生时，CPU立即进入<strong>核心态</strong></li>
<li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li>
<li>对于不同的中断信号，会进行不同的处理</li>
</ul>
<h4 id="2、中断的作用"><a href="#2、中断的作用" class="headerlink" title="2、中断的作用"></a>2、中断的作用</h4><p>​    发生了中断，就意味着需要操作系统介入，发展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU需要从用户态转变成核心态。<strong>中断</strong>可以<strong>使CPU从用户态转变成核心态，使操作系统获得计算机的控制权</strong>.。有了中断，才能实现多道程序并发执行。</p>
<h4 id="3、用户态、核心态切换的实现"><a href="#3、用户态、核心态切换的实现" class="headerlink" title="3、用户态、核心态切换的实现"></a>3、用户态、核心态切换的实现</h4><ul>
<li><strong>“用户态—》核心态“</strong>是通过<strong>中断</strong>实现的。并且<strong>中断</strong>是<strong>唯一的</strong>方式</li>
<li>”核心态—》用户态“的切换是通过<strong>执行一个特权指令</strong>，将程序状态字（PSW）的标志位设置为”用户态“</li>
</ul>
<h3 id="三、中断-广义的中断-分类"><a href="#三、中断-广义的中断-分类" class="headerlink" title="三、中断{广义的中断}分类"></a>三、中断{广义的中断}分类</h3><h4 id="1、内中断（异常、例外、陷入）"><a href="#1、内中断（异常、例外、陷入）" class="headerlink" title="1、内中断（异常、例外、陷入）"></a>1、内中断（异常、例外、陷入）</h4><ul>
<li><p>信号来源：CPU内部与当前执行的指令<strong>有关</strong></p>
</li>
<li><p>自愿中断</p>
<ul>
<li>指令中断</li>
</ul>
</li>
<li><p>强迫中断</p>
<ul>
<li>硬件故障</li>
<li>软件中断</li>
</ul>
</li>
</ul>
<h4 id="2、外中断（中断-狭义的中断-）"><a href="#2、外中断（中断-狭义的中断-）" class="headerlink" title="2、外中断（中断{狭义的中断}）"></a>2、外中断（中断{狭义的中断}）</h4><ul>
<li><p>信号来源：CPU内部与当前执行的指令<strong>有关</strong></p>
</li>
<li><p>外设请求</p>
</li>
<li><p>人工干预</p>
</li>
</ul>
<h3 id="四、外中断的处理过程"><a href="#四、外中断的处理过程" class="headerlink" title="四、外中断的处理过程"></a>四、外中断的处理过程</h3><p><img src="https://i.loli.net/2020/12/15/N1OuBLW9Zj7YbAy.png" alt="image-20201215203027037"></p>
<h3 id="五、回顾"><a href="#五、回顾" class="headerlink" title="五、回顾"></a>五、回顾</h3><p><img src="https://i.loli.net/2020/12/15/OEjrGxoAeT5cUM4.png" alt="image-20201215203338519"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC创建对象的方式</title>
    <url>/posts/f40a03f2/</url>
    <content><![CDATA[<h3 id="1、使用无参构造创建对象，默认"><a href="#1、使用无参构造创建对象，默认" class="headerlink" title="1、使用无参构造创建对象，默认"></a>1、使用无参构造创建对象，默认</h3><h3 id="2、假设我们要使用有参构造创建对象"><a href="#2、假设我们要使用有参构造创建对象" class="headerlink" title="2、假设我们要使用有参构造创建对象"></a>2、假设我们要使用有参构造创建对象</h3><ul>
<li>下标赋值</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    第一种,下标赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"User"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"dddd"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>类型赋值</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--    第二种方式、通过类型创建对象，，不建议使用--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"User"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"java"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"xxxx"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数名</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--第三种方式，直接通过参数名来设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"User"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Djc"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：在配置文件加载的过程中，容器中管理的对象就已经被初始化了</strong></p>
<p><img src="https://i.loli.net/2020/07/30/IrKp3Nu5v142HGL.png" alt="image-20200730102652165"></p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-笔记 -Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>依赖注入</title>
    <url>/posts/caca8281/</url>
    <content><![CDATA[<h3 id="1、-构造器注入"><a href="#1、-构造器注入" class="headerlink" title="1、 构造器注入"></a>1、 构造器注入</h3><p>前面已经讲了，这里就不再阐述了。</p>
<h3 id="2、-通过set方法注入-重点"><a href="#2、-通过set方法注入-重点" class="headerlink" title="2、 通过set方法注入(重点)"></a>2、 通过set方法注入(重点)</h3><ul>
<li>依赖注入：Set注入！<ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象中的属性，由容器来注入</li>
</ul>
</li>
</ul>
<p><strong>【环境搭建】</strong></p>
<ol>
<li><p>复杂类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.djc.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Address&#123;"</span> +</span><br><span class="line">                <span class="string">"address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>真实测试对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Integer&gt; score;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br></pre></td></tr></table></figure>
</li>
<li><p>beans.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.Address"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">value</span>=<span class="string">"jx"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.Student"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第一种注入，普通值注入，value--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"小丁"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第二种注入、Bean注入 ，ref--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第三种注入，数组注入，--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"books"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第四种注入，list注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbies"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>听歌<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>打豆豆<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>睡觉<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第五种注入，map注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"score"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"数学"</span> <span class="attr">value</span>=<span class="string">"30"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"语文"</span> <span class="attr">value</span>=<span class="string">"40"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第六种注入，set注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"games"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>王者<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第七种注入，null注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wife"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        第八种注入，Properties注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"学号"</span>&gt;</span>00000<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"性别"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Student student = (Student) context.getBean(<span class="string">"student"</span>);</span><br><span class="line">        System.out.println(student.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">    Student&#123;</span><br><span class="line">        name&#x3D;&#39;小丁&#39;,</span><br><span class="line">        address&#x3D;Address&#123;address&#x3D;&#39;jx&#39;&#125;,</span><br><span class="line">        books&#x3D;[红楼梦, 三国演义, 西游记, 水浒传],</span><br><span class="line">        hobbies&#x3D;[听歌, 打豆豆, 睡觉],</span><br><span class="line">        score&#x3D;&#123;数学&#x3D;30, 语文&#x3D;40&#125;,</span><br><span class="line">        games&#x3D;[LOL, 王者],</span><br><span class="line">        wife&#x3D;&#39;null&#39;,</span><br><span class="line">        info&#x3D;&#123;学号&#x3D;00000, 性别&#x3D;男&#125;&#125;</span><br><span class="line"></span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="3、-拓展方式注入"><a href="#3、-拓展方式注入" class="headerlink" title="3、 拓展方式注入"></a>3、 拓展方式注入</h3><p>我们可以使用p命名空间、c命名空间进行注入</p>
<p>官方解释</p>
<p><img src="https://i.loli.net/2020/07/30/4aurqKz69dMIpRZ.png" alt="image-20200730163251917"></p>
<p>使用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    p命名空间注入，可以直接注入属性的值,properties</span></span><br><span class="line"><span class="comment">    需要无参构造</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.User"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:name</span>=<span class="string">"xx"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">p:age</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    c命名空间注入，通过构造注入，construct-args</span></span><br><span class="line"><span class="comment">    需要有参构造</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.User"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:name</span>=<span class="string">"ddd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:age</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"userBean.xml"</span>);</span><br><span class="line">      User user = context.getBean(<span class="string">"user2"</span>,User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      System.out.println(user);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/07/30/zfDIqsaCGtNSm7O.png" alt="image-20200730163326819"></p>
<p><strong>注意点</strong></p>
<ul>
<li><p>p命名空间和c命名空间不能直接使用，需要导入约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:p="http://www.springframework.org/schema/p"</span><br><span class="line">xmlns:c="http://www.springframework.org/schema/c"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4、-Bean的作用域"><a href="#4、-Bean的作用域" class="headerlink" title="4、 Bean的作用域"></a>4、 Bean的作用域</h3><p><img src="https://i.loli.net/2020/07/30/pE7cs8HUinG4etR.png" alt="image-20200730163830609"></p>
<ol>
<li><p>单例模式(Spring 默认机制)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.User"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:name</span>=<span class="string">"ddd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:age</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">scope</span>=<span class="string">"singleton"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>原型模式:每次从容器中get的时候，都会产生一个新对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.User"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:name</span>=<span class="string">"ddd"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">c:age</span>=<span class="string">"20"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">scope</span>=<span class="string">"prototype"</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>其余的request、session、application这些只能在web开发中使用到</p>
</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-笔记 -Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring常用配置</title>
    <url>/posts/971b5adf/</url>
    <content><![CDATA[<h3 id="1-、别名"><a href="#1-、别名" class="headerlink" title="1 、别名"></a>1 、别名</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  别名：如果添加了别名，我们也可以使用别名来获取对象，id一样有可以--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">"User"</span> <span class="attr">alias</span>=<span class="string">"userNew"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2、Bean的配置"><a href="#2、Bean的配置" class="headerlink" title="2、Bean的配置"></a>2、Bean的配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id:bean的唯一标识符，也就是相当于我们学的对象名</span></span><br><span class="line"><span class="comment">    class：bean对象所对应的全限定名 ： 包名 + 类型</span></span><br><span class="line"><span class="comment">    name:也是别名，而且name更高级，可以同时取多个别名(通过空格、逗号分隔、分号)</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxx"</span> <span class="attr">class</span>=<span class="string">"com.djc.pojo.User"</span> <span class="attr">name</span>=<span class="string">"user,user2 uuu"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、Import"><a href="#3、Import" class="headerlink" title="3、Import"></a>3、Import</h3><p>这个import，一般用于团队开发，它可以将多个配置文件 导入合并为一个。</p>
<p>假设:现在项目中有多人开发，在三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为一个。使用的时候，直接使用总的就可以了。</p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>-笔记 -Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>处理机调度、层次概念</title>
    <url>/posts/c21ce3f9/</url>
    <content><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>处理机调度：从就绪队列中<strong>按照一定的算法选择一个进程</strong>并将<strong>处理机分配给他</strong>运行，以实现进程的并发执行</p>
<h3 id="二、三个层次"><a href="#二、三个层次" class="headerlink" title="二、三个层次"></a>二、三个层次</h3><h4 id="1、高级调度（作业调度）"><a href="#1、高级调度（作业调度）" class="headerlink" title="1、高级调度（作业调度）"></a>1、高级调度（作业调度）</h4><ul>
<li>按一定的原则<strong>从外存上</strong>处于后备队列的作业中挑选一个（或多个）作业，将他们分配内存等必要资源，并建立<strong>相应的进程（建立PCB）</strong>，以使<strong>它们获得竞争处理机的权利</strong>.</li>
<li>高级调度是外存与内存之间的调度，每个作业只调入一次，调出一次。<strong>作业调入时建立PCB，作业调出时才销毁PCB，</strong></li>
<li>高级调度主要是指<strong>作业调入的问题</strong>，因为只有调入的时机才需要操作系统来确定，但调出的时机必然是作业运行结束后才调出，</li>
</ul>
<h4 id="2、中级调度（内存调度）"><a href="#2、中级调度（内存调度）" class="headerlink" title="2、中级调度（内存调度）"></a>2、中级调度（内存调度）</h4><ul>
<li>引入虚拟存储技术后，可以将暂时不能运行的进程调至到外存等待，等到它重新具备运行条件后且内存又稍有空闲后，再重新调入到内存中，目的是<strong>提高内存效率和系统吞吐量</strong></li>
<li>暂时调到外存等待的进程的状态为“<strong>挂起状态</strong>”，<ul>
<li><strong>PCB并不会一起调到外存</strong>，而是会<strong>常驻内存</strong></li>
<li>被挂起的进程PCB会放到<strong>挂起队列</strong>中</li>
</ul>
</li>
<li><strong>中级调度就是决定将哪一个挂起状态的进程重新调入进程</strong><ul>
<li>一个进程可能多次被调入调出内存，所以<strong>中级调度</strong>发生的频率要比高级调度要<strong>更高</strong></li>
</ul>
</li>
</ul>
<h4 id="3、低级调度（进程调度）"><a href="#3、低级调度（进程调度）" class="headerlink" title="3、低级调度（进程调度）"></a>3、低级调度（进程调度）</h4><ul>
<li><strong>低级调度（进程调度）：按照某一种算法和策略从就绪队列中选取一个进程，将处理机分配给它</strong></li>
<li>进程调度是操作系统中<strong>最基本的一种调度</strong></li>
<li>进程调度的<strong>频率很高</strong>，一般几十毫秒一次</li>
</ul>
<h3 id="三、三层调度的联系对比"><a href="#三、三层调度的联系对比" class="headerlink" title="三、三层调度的联系对比"></a>三、三层调度的联系对比</h3><p><img src="https://i.loli.net/2020/12/26/5UKe1HpBxQyGZAj.png" alt="image-20201226104000403"></p>
<h3 id="四、补充知识"><a href="#四、补充知识" class="headerlink" title="四、补充知识"></a>四、补充知识</h3><h4 id="1、进程的“挂状态”"><a href="#1、进程的“挂状态”" class="headerlink" title="1、进程的“挂状态”"></a>1、进程的“挂状态”</h4><ul>
<li>就绪挂起</li>
<li>堵塞挂起</li>
</ul>
<h4 id="2、七状态模型"><a href="#2、七状态模型" class="headerlink" title="2、七状态模型"></a>2、七状态模型</h4><p><img src="https://i.loli.net/2020/12/26/MDmwtQdg3pWeiJA.png" alt="image-20201226103617756"></p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><img src="https://i.loli.net/2020/12/26/eVFG9HcDZ8EWdbM.png" alt="image-20201226104129845"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的四个特征</title>
    <url>/posts/d04bd5bc/</url>
    <content><![CDATA[<h3 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h3><p><img src="https://i.loli.net/2020/12/05/qeNlfD3iR8P6wLz.png" alt="image-20201205153539331"></p>
<h3 id="二、并发"><a href="#二、并发" class="headerlink" title="二、并发"></a>二、并发</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。这些事件<strong>宏观上是同时发生</strong>的，但是<strong>微观上是交替发生</strong>的</p>
<p><strong>易于混淆</strong>的概念：<strong>并行</strong>：指两个或多个事件<strong>同一时刻</strong>发生</p>
<h4 id="2、操作系统的并发性"><a href="#2、操作系统的并发性" class="headerlink" title="2、操作系统的并发性"></a>2、操作系统的并发性</h4><p>​    操作系统的并发性：指计算机系统同时存在着多个运行着的程序</p>
<h3 id="三、共享"><a href="#三、共享" class="headerlink" title="三、共享"></a>三、共享</h3><h4 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h4><p>​    共享：即<strong>资源共享</strong>，是指系统内的资源可供内存中多个并发执行的进程共同使用。</p>
<p><img src="https://i.loli.net/2020/12/05/PbZ4SJHftFU5Gqp.png" alt="image-20201205155800371"></p>
<p>​    </p>
<h3 id="四、虚拟"><a href="#四、虚拟" class="headerlink" title="四、虚拟"></a>四、虚拟</h3><h4 id="1、概念-2"><a href="#1、概念-2" class="headerlink" title="1、概念"></a>1、概念</h4><p><strong>虚拟</strong>：指把一个物理上的实体变成若干个逻辑上的对应物，物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的</p>
<p><img src="https://i.loli.net/2020/12/05/Aj7WMiY1uRqQUt5.png" alt="image-20201205160547807"></p>
<h4 id="2、注意"><a href="#2、注意" class="headerlink" title="2、注意"></a>2、注意</h4><ul>
<li><strong><em>没有并发性，就没有虚拟性</em></strong></li>
</ul>
<h3 id="五、异步"><a href="#五、异步" class="headerlink" title="五、异步"></a>五、异步</h3><h4 id="1、概念-3"><a href="#1、概念-3" class="headerlink" title="1、概念"></a>1、概念</h4><p><strong>异步：</strong>在多道程序环境下，运行多个程序并发执行，但<strong>由于资源有限</strong>，进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进，这就是进程的异步性。</p>
<h4 id="2、注意-1"><a href="#2、注意-1" class="headerlink" title="2、注意"></a>2、注意</h4><ul>
<li><strong><em>只有系统拥有并发性，才有可能导致异步性</em></strong></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统发展和分类</title>
    <url>/posts/2ce96af5/</url>
    <content><![CDATA[<h3 id="一、手工操作阶段"><a href="#一、手工操作阶段" class="headerlink" title="一、手工操作阶段"></a>一、手工操作阶段</h3><h3 id="二、批处理阶段"><a href="#二、批处理阶段" class="headerlink" title="二、批处理阶段"></a>二、批处理阶段</h3><h4 id="1、单道批处理阶段"><a href="#1、单道批处理阶段" class="headerlink" title="1、单道批处理阶段"></a>1、单道批处理阶段</h4><p>引入<strong>脱机输入/输出技术</strong>（用磁带完成），并<strong>监督程序</strong>负责控制作业的输入、输出。</p>
<p><strong>优点</strong>：缓解了一定程序的人机速度矛盾，资源利用率有所提高</p>
<p><strong>缺点</strong>：<strong>内存中仅能由一道程序运行</strong>，只有该程序运行结束后才能调入下一道程序，<strong>CPU有大量的时间是空闲等待I/O完成</strong>，资源利用依然低。</p>
<h4 id="2、多批道处理系统"><a href="#2、多批道处理系统" class="headerlink" title="2、多批道处理系统"></a>2、多批道处理系统</h4><p><strong>操作系统正式诞生</strong>，并引入了<strong>中断技术</strong>，由操作系统负责管理这些程序的执行，各个程序并发执行。</p>
<p><strong>优点</strong>：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源，<strong>资源利用率大幅度提升</strong>，CPU和其他资源保持“忙碌”状态，系统吞吐量增大</p>
<p><strong>缺点</strong>：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p>
<h3 id="三、分时操作系统"><a href="#三、分时操作系统" class="headerlink" title="三、分时操作系统"></a>三、分时操作系统</h3><p>：计算机以<strong>时间片</strong>为单位轮转为<strong>各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互</p>
<p><strong>优点</strong>：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>
<p><strong>缺点</strong>：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</p>
<h3 id="四、实时操作系统"><a href="#四、实时操作系统" class="headerlink" title="四、实时操作系统"></a>四、实时操作系统</h3><p><strong>优点</strong>：<strong>能够优先响应一些紧急任务</strong>，某些紧急任务不需要时间片排队。</p>
<p>在实时操作系统的控制下，计算机系统接受到外部信号后及时进行处理，并且要<strong>在严格的时限内处理完事件。</strong></p>
<p>实时操作系统的主要特点是<strong>及时性和可靠性</strong></p>
<h3 id="五、思维导图"><a href="#五、思维导图" class="headerlink" title="五、思维导图"></a>五、思维导图</h3><p><img src="https://i.loli.net/2020/12/05/EnZ5Vka3DG7pzgN.png" alt="image-20201205204558085"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/posts/4f5d4e8d/</url>
    <content><![CDATA[<h3 id="一-什么是系统调用，有何作用"><a href="#一-什么是系统调用，有何作用" class="headerlink" title="一 什么是系统调用，有何作用"></a>一 什么是系统调用，有何作用</h3><h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><p>应用程序通过<strong>系统调用</strong>请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提供服务请求，由操作系统代为完成</p>
<h4 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h4><p>可以保证系统的稳定性和安全性，防止用户进行非法操作</p>
<h4 id="3、分类（功能）"><a href="#3、分类（功能）" class="headerlink" title="3、分类（功能）"></a>3、分类（功能）</h4><ul>
<li>设备管理<ul>
<li>完成设备的请求/释放/启动等功能</li>
</ul>
</li>
<li>文件管理<ul>
<li>完成文件的读/写/创建/删除等功能</li>
</ul>
</li>
<li>进程控制<ul>
<li>完成进程的创建/撤销/阻塞/唤醒/等功能</li>
</ul>
</li>
<li>进程通信<ul>
<li>完成进程之间的消息传递/信号传递等功能</li>
</ul>
</li>
<li>内存管理<ul>
<li>完成内存的分配/回收等功能</li>
</ul>
</li>
</ul>
<h4 id="4、注意"><a href="#4、注意" class="headerlink" title="4、注意"></a>4、注意</h4><p>​    系统调用相关处理涉及到对系统资源的管理、对进程的控制。这些功能需要<strong>执行一些特权指令</strong>才能完成，因此<strong>系统调用的相关处理</strong>，需要<strong>在核心态完成</strong></p>
<h3 id="二-系统调用和函数库的区别"><a href="#二-系统调用和函数库的区别" class="headerlink" title="二 系统调用和函数库的区别"></a>二 系统调用和函数库的区别</h3><p><img src="https://i.loli.net/2020/12/18/ujoQrK3UiRtsWcw.png" alt="image-20201218111839800"></p>
<h3 id="三-系统调用背后的过程"><a href="#三-系统调用背后的过程" class="headerlink" title="三 系统调用背后的过程"></a>三 系统调用背后的过程</h3><p><img src="https://i.loli.net/2020/12/18/a563MetRrPnzjZh.png" alt="image-20201218112528140"></p>
<h3 id="四-知识回顾"><a href="#四-知识回顾" class="headerlink" title="四 知识回顾"></a>四 知识回顾</h3><p><img src="https://i.loli.net/2020/12/18/62QAHhde1g8Gpzf.png" alt="image-20201218112743161"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>运行机制-体系结构</title>
    <url>/posts/31685368/</url>
    <content><![CDATA[<h3 id="一、运行机制"><a href="#一、运行机制" class="headerlink" title="一、运行机制"></a>一、运行机制</h3><h4 id="1、指令"><a href="#1、指令" class="headerlink" title="1、指令"></a>1、指令</h4><p>1.概念：处理器（CPU）能识别、执行的最基本命令</p>
<p>2.分类：</p>
<ul>
<li>特权指令：不允许用户程序使用</li>
<li>非特权指令</li>
</ul>
<h4 id="2、处理器状态"><a href="#2、处理器状态" class="headerlink" title="2、处理器状态"></a>2、处理器状态</h4><p>1.分类</p>
<ul>
<li>用户态（目态）：次时CPU只能执行非特权指令</li>
<li>核心态（管态）：特权指令、非特权指令都能执行</li>
</ul>
<p>2、怎么判断状态</p>
<p>用程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态。如 0为用户态，1为核心态。</p>
<h4 id="3、两种程序"><a href="#3、两种程序" class="headerlink" title="3、两种程序"></a>3、两种程序</h4><p>1.分类</p>
<ul>
<li>内核程序：操作系统的内核程序是系统的管理者。既可以执行特权指令，也可以执行非特权指令，运行在核心态。</li>
<li>应用程序：为了保证系统的安全运行，普通应用程序只能执行非特权指令，运行在用户态。</li>
</ul>
<h3 id="二、内核"><a href="#二、内核" class="headerlink" title="二、内核"></a>二、内核</h3><h4 id="1、图解"><a href="#1、图解" class="headerlink" title="1、图解"></a>1、图解</h4><p><img src="https://i.loli.net/2020/12/05/FZJ1NXgrkG6aMKi.png" alt="image-20201205211540841"></p>
<h4 id="2、概念"><a href="#2、概念" class="headerlink" title="2、概念"></a>2、概念</h4><ul>
<li><p>内核是计算机上配置的<strong>底层软件</strong>，是操作系统最基本、最核心的部分。</p>
</li>
<li><p>实现操作系统内核功能的哪些程序就是内核程序</p>
<p><img src="https://i.loli.net/2020/12/15/94Az5WIhvfPgsyn.png" alt="image-20201215193609256"></p>
</li>
</ul>
<h4 id="3、内核分类"><a href="#3、内核分类" class="headerlink" title="3、内核分类"></a>3、内核分类</h4><ul>
<li>大内核、微内核</li>
</ul>
<p><img src="https://i.loli.net/2020/12/15/SxdQ7uCcHRInYqZ.png" alt="image-20201215193804729"></p>
<ul>
<li><p>大内核、微内核的优缺点</p>
<p><img src="https://i.loli.net/2020/12/15/9tDKGPLcXmofMbw.png" alt="image-20201215194114688"></p>
</li>
<li><p>类比</p>
<p><img src="https://i.loli.net/2020/12/15/hcy6SJYFe7Q9ZDo.png" alt="image-20201215194403334"></p>
</li>
</ul>
<h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p><img src="https://i.loli.net/2020/12/15/dDoiBXmfkvrjlQx.png" alt="image-20201215194829134"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>调度算法(FCFS,SJF,HRRN)</title>
    <url>/posts/25b3caf9/</url>
    <content><![CDATA[<h3 id="一、算法的研究思路"><a href="#一、算法的研究思路" class="headerlink" title="一、算法的研究思路"></a>一、算法的研究思路</h3><ul>
<li>算法思想</li>
<li>算法规则</li>
<li>这种调度算法是用于作业调度还是进程调度</li>
<li>抢占式？非抢占式</li>
<li>优缺点</li>
<li>是否导致<strong>饥饿</strong><ul>
<li>饥饿：某进程/作业长期得不到服务</li>
</ul>
</li>
</ul>
<h3 id="二、先来先服务（FCFS）"><a href="#二、先来先服务（FCFS）" class="headerlink" title="二、先来先服务（FCFS）"></a>二、先来先服务（FCFS）</h3><p>1、算法思想</p>
<ul>
<li>主要从“公平”的角度考虑</li>
</ul>
<p>2、算法规则</p>
<ul>
<li>按照作业/进程到达的先后顺序就绪服务</li>
</ul>
<p>3、用于作业/进程调度</p>
<ul>
<li>用于作业调度时，考虑的是哪个作业先到达后备队列当中</li>
<li>用于进程调度时，考虑的是哪个进程先到达就绪队列中</li>
</ul>
<p>4、是否抢占</p>
<ul>
<li>非抢占算法</li>
</ul>
<p>5、优缺点</p>
<ul>
<li>优点<ul>
<li>公平</li>
<li>算法实现简单</li>
</ul>
</li>
<li>缺点<ul>
<li>排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说体验感很差</li>
</ul>
</li>
<li>即 FCFS算法<strong>对长作业（进程）有利，对短作业（进程）不利</strong></li>
</ul>
<p>6、是否导致饥饿</p>
<ul>
<li>不会</li>
</ul>
<h3 id="三、短作业优先（SJF）"><a href="#三、短作业优先（SJF）" class="headerlink" title="三、短作业优先（SJF）"></a>三、短作业优先（SJF）</h3><p>1、算法思想</p>
<ul>
<li>追求最少的平均等待时间，最少的平均周转时间，最少的平均平均带权周转时间</li>
</ul>
<p>2、算法规则</p>
<ul>
<li>最短作业/进程优先得到服务（所谓最短是指要求<strong>服务时间最短</strong>）</li>
</ul>
<p>3、用于作业/进程调度</p>
<ul>
<li>用于作业调度，叫做短作业优先调度算法（SJF）</li>
<li>用于进程调度，叫做短进程优先调度算法（SPF）</li>
</ul>
<p>4、是否抢占</p>
<ul>
<li>SJF和SPF是<strong>非抢占式</strong>的算法</li>
<li><strong>最短剩余时间优先算法（SRTN，shortest Remaing Time Next）</strong></li>
</ul>
<p>5、优缺点</p>
<ul>
<li>优点<ul>
<li><strong>“最短的”</strong>平均等待时间，平均周转时间</li>
</ul>
</li>
<li>缺点<ul>
<li>不公平<ul>
<li>对于“<strong>短作业有利、对长作业不利</strong>”，可能产生<strong>饥饿现象</strong>，</li>
<li>作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>6、是否导致饥饿</p>
<ul>
<li>会导致饥饿，<ul>
<li>如果由源源不断的短作业/进程到来，可能使得长作业/进程长时间得不到服务，产生<strong>“饥饿”现象</strong>，如果一直得不到服务，则称为<strong>“饿死”</strong></li>
</ul>
</li>
</ul>
<p>7、注意细节</p>
<p><img src="https://i.loli.net/2020/12/26/7vdYbnfWrMxwNBD.png" alt="image-20201226173431484"></p>
<p>8、计算</p>
<ul>
<li>非抢占式的短作业优先调度算法</li>
</ul>
<p><img src="https://i.loli.net/2020/12/26/C9DEQlL3reqT7XK.png" alt="image-20201226163453336"></p>
<ul>
<li>抢占式的短作业优点调度算法</li>
</ul>
<p><img src="https://i.loli.net/2020/12/26/RzsOhuCHkGWjP23.png" alt="image-20201226163933556"></p>
<p><img src="https://i.loli.net/2020/12/26/NKbXQFDMOvhit9p.png" alt="image-20201226164020154"></p>
<h3 id="四、高响应比优先（HRRN）"><a href="#四、高响应比优先（HRRN）" class="headerlink" title="四、高响应比优先（HRRN）"></a>四、高响应比优先（HRRN）</h3><p>1、算法思想</p>
<ul>
<li>综合考虑作业/进程的等待时间和要求服务时间</li>
</ul>
<p>2、算法规则</p>
<ul>
<li>在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高的</strong>作业/进程为其服务</li>
<li>响应比 = (等待时间 + 要求服务时间)  / 要求服务时间</li>
</ul>
<p>3、用于作业/进程调度</p>
<ul>
<li>可用于作业调度</li>
<li>可用于进程调度</li>
</ul>
<p>4、是否抢占</p>
<ul>
<li><strong>非抢占式算法</strong><ul>
<li>只有当前进程/作业主动放弃处理机，才需要调度，才需要计算响应比</li>
</ul>
</li>
</ul>
<p>5、优缺点</p>
<ul>
<li>优点<ul>
<li>综合考虑了等待时间和运行时间（要求服务时间）</li>
<li>等待时间相同时，要求服务时间短的优先（SJF的优点）</li>
<li>要求服务时间相同时，等待时间长的优先（FCFS的优点）</li>
<li>对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免的长作业饥饿的问题</li>
</ul>
</li>
</ul>
<p>6、是否导致饥饿</p>
<ul>
<li>不会导致饥饿</li>
</ul>
<p>7、计算</p>
<p><img src="https://i.loli.net/2020/12/26/NlZCXLD7ArREU8p.png" alt="image-20201226174523153"></p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><img src="https://i.loli.net/2020/12/26/E7jOTMYgaVRzpFJ.png" alt="image-20201226175523961"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程控制</title>
    <url>/posts/d9c2550/</url>
    <content><![CDATA[<h3 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一 基本概念"></a>一 基本概念</h3><h4 id="1、什么是进程控制"><a href="#1、什么是进程控制" class="headerlink" title="1、什么是进程控制"></a>1、什么是进程控制</h4><p>​    进程控制的主要功能就是对系统中的所有进程进行有效的管理，它具有创建新进程、撤销已有进程、实现进程转换等功能</p>
<h4 id="2、如何实现进程控制"><a href="#2、如何实现进程控制" class="headerlink" title="2、如何实现进程控制"></a>2、如何实现进程控制</h4><p>​    <img src="https://i.loli.net/2020/12/22/xw6di8GcAoj9zN7.png" alt="image-20201222203441542"></p>
<ul>
<li><strong>为了避免PCB内的标志位与PCB所处的队列不一致，</strong>使用<strong>原语来实现基础控制</strong>，原语的特点是<strong>执行期间不允许中断</strong>，只能一气呵成。这种不可被中断的操作即<strong>原子操作</strong></li>
<li>原语采用“<strong>关中断</strong>指令”和“<strong>开中断</strong>操作”实现。<strong>关/开中断指令</strong>的权限非常大，所以只允许在<strong>核心态</strong>下执行的<strong>特权指令</strong></li>
<li>原语的目的<ul>
<li>更新PCB中的信息<ul>
<li>所有的进程控制原语一定都会修改进程状态标志</li>
<li>剥夺当前允许进程的CPU使用权必然需要保存其运行环境</li>
<li>某进程开始运行前必然要恢复运行状态</li>
</ul>
</li>
<li>将PCB插入到合适的队列中</li>
<li>分配/回收资源</li>
</ul>
</li>
</ul>
<h3 id="二-进程控制相关的原语"><a href="#二-进程控制相关的原语" class="headerlink" title="二 进程控制相关的原语"></a>二 进程控制相关的原语</h3><h4 id="1、进程的创建"><a href="#1、进程的创建" class="headerlink" title="1、进程的创建"></a>1、进程的创建</h4><p><img src="https://i.loli.net/2020/12/22/yoM1Fb96GhBfqOQ.png" alt="image-20201222205630647"></p>
<h4 id="2、进程的终止"><a href="#2、进程的终止" class="headerlink" title="2、进程的终止"></a>2、进程的终止</h4><p><img src="https://i.loli.net/2020/12/22/2SA34PLszkRBeKG.png" alt="image-20201222205844888"></p>
<h4 id="3、进程的阻塞、唤醒"><a href="#3、进程的阻塞、唤醒" class="headerlink" title="3、进程的阻塞、唤醒"></a>3、进程的阻塞、唤醒</h4><p><img src="https://i.loli.net/2020/12/22/E7rFRDTq3fBviCK.png" alt="image-20201222210009333"></p>
<h4 id="4、进程的切换"><a href="#4、进程的切换" class="headerlink" title="4、进程的切换"></a>4、进程的切换</h4><p><img src="https://i.loli.net/2020/12/22/QaUOc8WrXDRjJAs.png" alt="image-20201222210112018"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>线程概念与多线程模型</title>
    <url>/posts/3971d124/</url>
    <content><![CDATA[<h3 id="一、什么是线程，为什么要引入线程"><a href="#一、什么是线程，为什么要引入线程" class="headerlink" title="一、什么是线程，为什么要引入线程"></a>一、什么是线程，为什么要引入线程</h3><p><img src="https://i.loli.net/2020/12/24/o7UagnA9ZLlehpB.png" alt="image-20201224103051529"></p>
<ul>
<li>线程是<strong>一个基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。</li>
<li></li>
</ul>
<h3 id="二、引入线程机制后，有什么变化"><a href="#二、引入线程机制后，有什么变化" class="headerlink" title="二、引入线程机制后，有什么变化"></a>二、引入线程机制后，有什么变化</h3><p><img src="https://i.loli.net/2020/12/24/W5mpHxk6glcXnrP.png" alt="image-20201224103311213"></p>
<h3 id="三、线程的重要属性"><a href="#三、线程的重要属性" class="headerlink" title="三、线程的重要属性"></a>三、线程的重要属性</h3><p><img src="https://i.loli.net/2020/12/24/t4VSpF7yecUiY2g.png" alt="image-20201224104737922"></p>
<h3 id="四、实现方式"><a href="#四、实现方式" class="headerlink" title="四、实现方式"></a>四、实现方式</h3><h4 id="1、用户级线程"><a href="#1、用户级线程" class="headerlink" title="1、用户级线程"></a>1、用户级线程</h4><ul>
<li><p>用户级线程由应用程序通过线程库来实现的</p>
</li>
<li><p>所有的<strong>线程管理工作</strong>都由<strong>应用程序</strong>负责（包括线程切换）</p>
</li>
<li><p>用户级线程，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统的干预</p>
</li>
<li><p>用户级线程对用户不透明，对操作系统透明</p>
</li>
<li><p>用户级线程，就是“从用户视角看到的线程”</p>
<p><img src="https://i.loli.net/2020/12/24/g86KlfCz3BxHPhM.png" alt="image-20201224110917123"></p>
</li>
</ul>
<h4 id="2、内核级线程"><a href="#2、内核级线程" class="headerlink" title="2、内核级线程"></a>2、内核级线程</h4><ul>
<li><strong>内核级线程管理工作</strong>由<strong>操作系统内核</strong>完成。</li>
<li>线程调度、切换等工作都由内核完成，因此<strong>内核级线程的切换</strong>必然需要在<strong>核心态</strong>下才能完成</li>
<li>”内核级线程“就是”从操作系统内核视角才能看到的线程“</li>
</ul>
<p><img src="https://i.loli.net/2020/12/24/UyoGcdegKJFWku7.png" alt="image-20201224111539618"></p>
<h4 id="3、组合模式"><a href="#3、组合模式" class="headerlink" title="3、组合模式"></a>3、组合模式</h4><ul>
<li>同时支持用户级线程和内核级线程，将n个用户级线程映射到m个内核级线程上（n&gt;=m）;</li>
<li><strong>内核级线程才是处理机分配的单位</strong></li>
<li><img src="https://i.loli.net/2020/12/24/jaX4oh6FTmctWRy.png" alt="image-20201224111727851"></li>
<li></li>
</ul>
<h3 id="五、多线程模型"><a href="#五、多线程模型" class="headerlink" title="五、多线程模型"></a>五、多线程模型</h3><h4 id="1、多对一模型"><a href="#1、多对一模型" class="headerlink" title="1、多对一模型"></a>1、多对一模型</h4><p><img src="https://i.loli.net/2020/12/24/QD4V3I7ajKLbvEn.png" alt="image-20201224112057178"></p>
<h4 id="2、一对一模型"><a href="#2、一对一模型" class="headerlink" title="2、一对一模型"></a>2、一对一模型</h4><p><img src="https://i.loli.net/2020/12/24/XpCsl7TmuntqGEA.png" alt="image-20201224112328130"></p>
<h4 id="3、多对多模型"><a href="#3、多对多模型" class="headerlink" title="3、多对多模型"></a>3、多对多模型</h4><p><img src="https://i.loli.net/2020/12/24/nZIym2Fghwp9u65.png" alt="image-20201224112443274"></p>
<h3 id="六、总"><a href="#六、总" class="headerlink" title="六、总"></a>六、总</h3><p><img src="https://i.loli.net/2020/12/24/SJustWoQIp1lE2f.png" alt="image-20201224112624565"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>调度算法的评判标准</title>
    <url>/posts/110d173/</url>
    <content><![CDATA[<h3 id="一、CPU利用率"><a href="#一、CPU利用率" class="headerlink" title="一、CPU利用率"></a>一、CPU利用率</h3><ul>
<li>CPU“忙碌”的时间占总时间的比例</li>
<li>利用率 = 忙碌的时间 / 总时间</li>
</ul>
<p><img src="https://i.loli.net/2020/12/26/Dzav7BIkj8Z3Spe.png" alt="image-20201226112636011"></p>
<h3 id="二、系统吞吐量"><a href="#二、系统吞吐量" class="headerlink" title="二、系统吞吐量"></a>二、系统吞吐量</h3><ul>
<li><strong>系统吞吐量</strong>：单位时间内完成作业的数量</li>
<li><strong>系统吞吐量</strong> = 总共完成了多少作业 / 总共花了多少时间</li>
</ul>
<p><img src="https://i.loli.net/2020/12/26/G7SYZwVAfk28DJF.png" alt="image-20201226112952425"></p>
<h3 id="三、周转时间"><a href="#三、周转时间" class="headerlink" title="三、周转时间"></a>三、周转时间</h3><ul>
<li>周转时间：指作业<strong>被提交到系统开始</strong>，到<strong>作业完成为止</strong>的这段时间间隔</li>
<li>包括四个部分<ul>
<li>作业在外存。后备队列上等待作业调度（高级调度）的时间</li>
<li>进程在就绪队列上等待进程调度（低级调度）的时间</li>
<li>进程在CPU上执行的时间</li>
<li>进程等待I/O操作完成的时间</li>
</ul>
</li>
<li><strong>后三个部分在一个作业上在整个处理过程中，可能发生多次。</strong></li>
</ul>
<h4 id="1、周转时间、平均周转时间"><a href="#1、周转时间、平均周转时间" class="headerlink" title="1、周转时间、平均周转时间"></a>1、周转时间、平均周转时间</h4><ul>
<li>（作业）周转时间 = 作业完成时间 — 作业提交时间<ul>
<li>对于用户来说，更关心自己的单个作业的周转时间</li>
</ul>
</li>
<li>平均周转时间 = 各个作业时间之和 / 作业数<ul>
<li>对于操作系统来说，更关心系统的整体表现，因此更关心所有作业的周转时间的平均值</li>
</ul>
</li>
</ul>
<h4 id="2、带权周转时间、平均带权周转时间"><a href="#2、带权周转时间、平均带权周转时间" class="headerlink" title="2、带权周转时间、平均带权周转时间"></a>2、带权周转时间、平均带权周转时间</h4><ul>
<li>带权周转时间 = 作业周转时间 / 作业实际运行的时间 = （作业完成时间-作业提交的时间） / 作业实际运行的时间<ul>
<li>带权周转时间越低，用户满意度更高</li>
<li>带权周转时间必然 &gt;= 1</li>
<li>带权周转时间与周转时间都是越小越好</li>
</ul>
</li>
<li>平均带权周转时间 = 各个作业带权周转时间之和 / 作业数</li>
</ul>
<h3 id="四、等待时间"><a href="#四、等待时间" class="headerlink" title="四、等待时间"></a>四、等待时间</h3><ul>
<li><strong>等待时间</strong>：指<strong>进程/作业处于等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低</li>
<li>对于<strong>进程</strong>来说,，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所有不计入的等待时间</li>
<li>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong></li>
</ul>
<h3 id="五、响应时间"><a href="#五、响应时间" class="headerlink" title="五、响应时间"></a>五、响应时间</h3><ul>
<li>响应时间：指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间</li>
</ul>
<h3 id="六、计算"><a href="#六、计算" class="headerlink" title="六、计算"></a>六、计算</h3><p><img src="https://i.loli.net/2020/12/26/Fv4Sdg6MkT7InNA.png" alt="image-20201226162238234"></p>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p><img src="https://i.loli.net/2020/12/26/RO7BiEb5LnhSKpq.png" alt="image-20201226160424754"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程的定义、组成、组织方式、特征</title>
    <url>/posts/ffb9b075/</url>
    <content><![CDATA[<h3 id="一-定义"><a href="#一-定义" class="headerlink" title="一 定义"></a>一 定义</h3><p><img src="https://i.loli.net/2020/12/22/uvnZYEo3WKlBm6C.png" alt="image-20201222192549537"></p>
<p><img src="https://i.loli.net/2020/12/22/32eqBhHiUxsRnjy.png" alt="image-20201222192851223"></p>
<h4 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h4><ul>
<li><p><strong>程序段、数据段、PCB</strong>三部分组成了<strong>进程实体（进程映像）</strong>，</p>
<p>一般情况下，我们把进程实体简称为进程。</p>
</li>
<li><p>PCB是进程存在的<strong>唯一标志</strong></p>
</li>
<li><p>定义：</p>
<ul>
<li>进程是程序的一次<strong>执行过程</strong></li>
<li>进程是一个程序及其数据在处理机上顺序执行时所<strong>发生的活动</strong></li>
<li>进程是具有独立功能的程序在数据集合上<strong>运行的过程</strong>，它是系统进行资源分配和调度的一个独立单位</li>
</ul>
</li>
</ul>
<h3 id="二-组成"><a href="#二-组成" class="headerlink" title="二 组成"></a>二 组成</h3><ul>
<li><p>进程（进程实体）是由<strong>程序段、数据段、PCB</strong>三部分组成的</p>
<ul>
<li>程序段：程序代码即存放在此</li>
<li>数据段：程序运行时使用、产生的运算数据。</li>
<li>PCB：操作系统通过PCB来管理进程。因此PCB中应该包含操作系统对其进行管理所需的各种信息。</li>
</ul>
</li>
<li><p>PCB</p>
<p><img src="https://i.loli.net/2020/12/22/jkAaglLvhU4ZEIx.png" alt="image-20201222194431273"></p>
</li>
<li><p>总</p>
<p><img src="https://i.loli.net/2020/12/22/xX6gib1SY74NsLl.png" alt="image-20201222194604517"></p>
</li>
</ul>
<h3 id="三-组织方式"><a href="#三-组织方式" class="headerlink" title="三 组织方式"></a>三 组织方式</h3><ul>
<li><p>两种方式</p>
<p><img src="https://i.loli.net/2020/12/22/FbePLshoJr3dU1t.png" alt="image-20201222194722777"></p>
</li>
<li><p>链接方式（队列）</p>
<ul>
<li>执行指针<ul>
<li>指向当前处于运行态（执行态）的进程</li>
<li>单CPU计算机中，同一时刻只会有一个处于运行态的进程</li>
</ul>
</li>
<li>就绪队列指针<ul>
<li>指向当下处于就绪态的进程</li>
<li>指向的是一个链式PCB，通常会将优先级高的进程放在队头</li>
</ul>
</li>
<li>阻塞队列指针<ul>
<li>指向当前处于阻塞的进程，很多操作系统还会根据阻塞原因不同，分成不同的阻塞队列</li>
</ul>
</li>
</ul>
</li>
<li><p>索引方式（索引表）</p>
<ul>
<li>执行指针</li>
<li>就绪表指针</li>
<li>阻塞表指针</li>
</ul>
</li>
</ul>
<h3 id="四-特征"><a href="#四-特征" class="headerlink" title="四 特征"></a>四 特征</h3><ul>
<li>动态性<ul>
<li>进程是程序的一次执行过程，是动态地产生、变化和消亡</li>
<li>动态性是进程最基本的特征</li>
</ul>
</li>
<li>并发性<ul>
<li>内存存在多个进程实体，各个进程可并发执行</li>
</ul>
</li>
<li>独立性<ul>
<li>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>进程是资源调度、接受调度的基本单位</li>
</ul>
</li>
<li>异步性<ul>
<li>各个进程按照各自独立的、不可预知的速度向前推进</li>
<li>操作系统要提供“进程同步机制”来解决异步问题</li>
<li>异步性会导致并发程序执行结果的不确定性</li>
</ul>
</li>
<li>结构性<ul>
<li>每个进程都配置一个PCB</li>
<li>从结构上看，进程由程序段、数据段、PCB组成的</li>
</ul>
</li>
</ul>
<h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五 总结"></a>五 总结</h3><p><img src="https://i.loli.net/2020/12/22/7ZcXxpruak6qKjU.png" alt="image-20201222200132634"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程状态的转换</title>
    <url>/posts/ada646f9/</url>
    <content><![CDATA[<h3 id="一、概括"><a href="#一、概括" class="headerlink" title="一、概括"></a>一、概括</h3><p><img src="https://i.loli.net/2020/12/22/EOQtlMj316C72vV.png" alt="image-20201222200250316"></p>
<h3 id="二、进程的状态"><a href="#二、进程的状态" class="headerlink" title="二、进程的状态"></a>二、进程的状态</h3><h4 id="1、三种基本状态"><a href="#1、三种基本状态" class="headerlink" title="1、三种基本状态"></a>1、三种基本状态</h4><ul>
<li>运行态<ul>
<li>占用CPU，并在CPU上运行</li>
<li>在单核处理机环境下，每一个时刻最多只由一个进程处于运行态（双核环境下由两个进程处于运行态）</li>
</ul>
</li>
<li>就绪态<ul>
<li>依据具备运行条件，但由于没有空闲的CPU，而暂时不能运行。</li>
<li>进程已经拥有了除处理机之外的所有需要的资源，一旦获取处理机，就可以立刻进入运行态开始运行</li>
</ul>
</li>
<li>阻塞态<ul>
<li>因等待一事件而暂时不能运行</li>
</ul>
</li>
</ul>
<h4 id="2、另外两种状态"><a href="#2、另外两种状态" class="headerlink" title="2、另外两种状态"></a>2、另外两种状态</h4><ul>
<li>创建状态<ul>
<li>操作系统需要完成创建进程，操作系统为该进程分配所需要的内存空间等资源，并为其初始化PCB</li>
</ul>
</li>
<li>终止状态<ul>
<li>进程运行结束，需要撤销进程</li>
<li>操作系统需要完成撤销进程相关的工作，完成将分配给进程的资源回收，撤销进程PCB等工作</li>
</ul>
</li>
</ul>
<h3 id="三-进程的转换"><a href="#三-进程的转换" class="headerlink" title="三 进程的转换"></a>三 进程的转换</h3><p><img src="https://i.loli.net/2020/12/22/CFziGAK976WSVQf.png" alt="image-20201222202632115"></p>
<h3 id="四-总结"><a href="#四-总结" class="headerlink" title="四 总结"></a>四 总结</h3><p><img src="https://i.loli.net/2020/12/22/mo21wSXtpCODsYr.png" alt="image-20201222202732624"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程通信</title>
    <url>/posts/53ad465c/</url>
    <content><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ul>
<li>进程通信就是<strong>进程之间的消息传递</strong></li>
<li>进程是分配系统资源的基本单位，因此各进程拥有的<strong>内存地址空间是相互独立的</strong></li>
<li>为了保存安全，<strong>一个进程不能直接访问另外一个进程地址空间</strong></li>
<li>进程通信的<strong>三种方法</strong><ul>
<li>共享存储</li>
<li>消息传递</li>
<li>管道通信</li>
</ul>
</li>
</ul>
<h3 id="二、共享存储"><a href="#二、共享存储" class="headerlink" title="二、共享存储"></a>二、共享存储</h3><p><img src="https://i.loli.net/2020/12/24/y1KZ8WzR6FCYm2n.png" alt="image-20201224100458183"></p>
<h3 id="三、消息传递"><a href="#三、消息传递" class="headerlink" title="三、消息传递"></a>三、消息传递</h3><p><img src="https://i.loli.net/2020/12/24/EqkdhtyYgBus3AI.png" alt="image-20201224101158127"></p>
<h3 id="四、管道通信"><a href="#四、管道通信" class="headerlink" title="四、管道通信"></a>四、管道通信</h3><p><img src="https://i.loli.net/2020/12/24/Tag7bNRrhxMcY1P.png" alt="image-20201224100913574"></p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p><img src="https://i.loli.net/2020/12/24/V2ovCkfQgOZ48Nq.png" alt="image-20201224101327317"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/posts/1f4ac2fb/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a><strong>定义</strong></h3><ul>
<li><font color='red'>只允许在一端进行或删除操作</font>的<font color='orange'>线性表</font>.</li>
<li>重要术语<ul>
<li>栈顶：允许插入和删除的一端——栈顶元素</li>
<li>栈底：不允许插入和删除的一端——栈底元素</li>
<li>空栈</li>
</ul>
</li>
<li>特点：<strong>后进先出</strong></li>
<li>数学特性：n各不同的元素出栈，出栈元素不同排列的个数为1/(1+n) * Cn(2n)。</li>
</ul>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InitStack(&amp;S):初始化栈。		构造一个空栈S,分配内存空间;</span><br><span class="line">DestroyStack(&amp;L):销毁栈		销毁并释放栈S所占用的内存空间;	</span><br><span class="line"></span><br><span class="line">Push(&amp;S,x):进栈		若栈S未满，则将x加入使之成为新栈顶;</span><br><span class="line">Pop(&amp;S,&amp;x):出栈		若栈S非空，则弹出栈顶元素，并用x返回;</span><br><span class="line"></span><br><span class="line">GetTop(S,&amp;x):读取栈顶元素。	若栈S非空，则用x返回栈顶元素</span><br><span class="line"></span><br><span class="line">其他常用操作：</span><br><span class="line">StackEmpty(S):判断一个栈S是否为空。若S为空，则返回true,否则返回false；</span><br></pre></td></tr></table></figure>

<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>顺序存储类型定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 50			<span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];		<span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="keyword">int</span> top;				<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<p><strong>初始化栈</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IniStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;			<span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)		<span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>			<span class="comment">//不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>进栈</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize<span class="number">-1</span>)		<span class="comment">//栈满，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    S,top = S.top + <span class="number">1</span>;			<span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;			<span class="comment">//新元素入栈</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出栈</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈操作</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)		<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];		<span class="comment">//栈顶元素先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;		<span class="comment">//指针在减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的数据删除只是逻辑上被删除了，在内存中还存在。</span></span><br></pre></td></tr></table></figure>

<p><strong>读取</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)		<span class="comment">//栈空，报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = S.data[S.top];		<span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//与删除操作相比，读取操作只是少了指针减1的步骤。</span></span><br></pre></td></tr></table></figure>

<h3 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h3><p><strong>定义</strong>：两个栈<font color='red'>共享</font>同一片空间</p>
<h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top0;		<span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> top1;		<span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br></pre></td></tr></table></figure>

<p><strong>初始化栈</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;			<span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top1 = MaxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>栈满</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FullStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 +<span class="number">1</span> = S.top1;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>更加有效的利用存储空间。</li>
<li>只有当整个存储空间被占满时才发生上溢，减少发生上溢的可能性。</li>
<li>对存取效率没有什么影响</li>
</ul>
<h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>链栈的操作与链表类似，<strong>入栈和出栈的操作都在链表的表头进行，头插法</strong></li>
</ul>
<h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span>&#123;</span></span><br><span class="line">    ElemType data;			<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Linknode</span> *<span class="title">next</span>;</span>		<span class="comment">//指针域</span></span><br><span class="line">&#125; *LiStack;				<span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure>

<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h3><p>最后出现的左括号<strong>最先</strong>被匹配<font color='red'>（LIFO）</font>。</p>
<h3 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>中缀表达式</strong></p>
<ul>
<li>运算符在操作数之间<ul>
<li>eg：a + b</li>
<li>a + b - c</li>
<li>a + b - c  * d</li>
</ul>
</li>
</ul>
<p><strong><font color='red'>后缀表达式</font></strong></p>
<ul>
<li>运算符在操作数后面<ul>
<li>eg： a b +</li>
<li>a b + c -</li>
<li>a b +  c d *  - </li>
</ul>
</li>
<li><strong>左优先原则：只要左边的运算符都能先计算，就优先算左边的。</strong></li>
<li>注意：先弹出的元素是<strong>右操作数</strong></li>
</ul>
<p><strong>前缀表达式</strong></p>
<ul>
<li>运算符在操作数前面<ul>
<li>eg: + a b</li>
<li>-+a b c </li>
</ul>
</li>
<li><strong>右优先原则：只要右边的运算符都能先计算，就优先算右边的</strong></li>
<li>注意：先弹出的元素是<strong>左操作数</strong></li>
</ul>
<h4 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h4><p><strong>手算过程</strong></p>
<ul>
<li>确定中缀表达式中的<font color='red'>各个运算符的运算顺序</font>。</li>
<li>选择下一个运算符，按照<font color='orange'>【左操作数  右操作数 运算符】</font>的方式组合成一个新的操作数。<ul>
<li>这里由于运算顺序不唯一，因此对应的后缀表达式也不唯一。由于不唯一破坏了算法的确定性，为此我们确定了<strong>左优先原则</strong>。保证后缀表达式唯一。</li>
</ul>
</li>
<li>如果还有运算符没被处理，就继续第二步。</li>
</ul>
<p><strong>计算过程</strong></p>
<ul>
<li>初始化一个栈，用于保存<font color='red'>暂时还不能确定运算顺序的运算符</font>。</li>
<li>从左到右处理各个元素，直到末尾。可能遇到三种情况：<ul>
<li>遇到<font color='red'>操作数</font>。直接加入后缀表达式。</li>
<li>遇到<font color='red'>界定符</font>。遇到“ ( ”直接入栈；遇到“ ）”则依次弹出栈内运算符并加入后缀表达式，直到弹出“（ ”为止。<font color='cornflowerblue'>注意“ ( ”不加入后缀表达式</font>.</li>
<li>遇到<font color='red'>运算符</font>。依次弹出栈中<font color='orange'>优先级高于或等于</font>当前运算符的所有运算符，并加入后缀表达式，若碰到”（ “或栈空则停止。之前再把当权运算符入栈。</li>
</ul>
</li>
<li>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</li>
</ul>
<h4 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h4><p><strong>手算过程</strong></p>
<ul>
<li>从左往右扫描，每遇到一个运算符，就让<font color='orange'>运算符前面的两个操作数</font>执行对应运算，<font color='orange'>合体为一个操作数</font>。</li>
</ul>
<p><strong>计算过程</strong></p>
<ul>
<li>从左往右扫描下一个元素，直到处理完所有元素。</li>
<li>若扫描到<font color='orange'>操作数则压入栈</font>,并回到上一步，否则执行下一步。</li>
<li>若扫到操作数，则弹出两个栈顶元素，<font color='red'>先弹出的栈顶元素为右操作数</font>，执行对应运算，运算结果压回到栈顶，回到第一步。</li>
</ul>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul>
<li>适合“递归”算法：可以把原始问题转换成<font color='red'>属性相同</font>，但<font color='red'>规模较小</font>的问题</li>
</ul>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>特殊矩阵</title>
    <url>/posts/2fce5ec8/</url>
    <content><![CDATA[<h3 id="普通矩阵的存储"><a href="#普通矩阵的存储" class="headerlink" title="普通矩阵的存储"></a>普通矩阵的存储</h3><ul>
<li>可以<font color='orange'>用二维数组</font>存储。</li>
<li>注意：描述矩阵元素时，<font color='red'>行列号通常从1开始</font>；而描述数组时通常下标从0开始。（具体看题目给的条件，注意审题）</li>
</ul>
<h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a><strong>对称矩阵</strong></h3><p><strong>概念：</strong>若n阶<font color='orange'>方针</font>中任意一个元素a i,j 都有<font color='orange'> a[i] [j] = a[j] [i]</font>，则该矩阵为<font color='orange'>对称矩阵</font>。</p>
<p><strong>压缩存储策略：只存储主对角线 + 下三角区</strong></p>
<ul>
<li>按<font color='orange'>行优先</font>原则将各个元素存入一维数组中。</li>
<li>数组大小应该为：*<em>((n+1)</em>n)/2 **</li>
<li>在使用的时候，我们可以实现一个“映射”函数：<strong><font color='red'>矩阵下标 —&gt; 一位数组下标</font></strong><ul>
<li>按<font color='orange'>行优先</font>原则,a i j是第 (i * (i - 1))/2 + j 个元素，在数组中的下标是第<font color='red'> (i * (i - 1))/2 + j - 1</font>个位置。</li>
</ul>
</li>
</ul>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><ul>
<li><font color='orange'>下三角矩阵</font>：除了主对角线和下三角区，其余的元素都相同。</li>
<li><font color='orange'>上三角矩阵</font>：除了主对角线和上三角区，其余的元素都相同。</li>
</ul>
<p><strong>压缩存储策略</strong></p>
<ul>
<li>按<font color='orange'>行优先</font>原则将橙色区元素存入一维数组中。并在<font color='orange'>最后一个位置存储常量c</font></li>
<li>数组大小应该为：<strong>((n+1)*n)/2  + 1</strong></li>
<li>在使用的时候，我们可以实现一个“映射”函数：<strong><font color='red'>矩阵下标 —&gt; 一位数组下标</font></strong>.<ul>
<li>按<font color='orange'>行优先</font>原则,a i j是第 (i * (i - 1))/2 + j 个元素，在数组中的下标是第<font color='red'> (i * (i - 1))/2 + j - 1</font>个位置。</li>
<li>如果 i &lt; j 则x = a[*<em>((n+1)</em>n)/2];</li>
</ul>
</li>
</ul>
<h3 id="三对角矩阵的压缩存储"><a href="#三对角矩阵的压缩存储" class="headerlink" title="三对角矩阵的压缩存储"></a>三对角矩阵的压缩存储</h3><p><strong>概念：</strong>当<font color='orange'>| i - j| &gt; 1 时，有a i j = 0;</font></p>
<p><strong>压缩存储策略</strong>：</p>
<ul>
<li><p>按<font color='orange'>行优先</font>原则，只存储带状部分</p>
</li>
<li><p>数组大小：3n - 2 </p>
</li>
<li><p>在使用的时候，我们可以实现一个“映射”函数：<strong><font color='red'>矩阵下标 —&gt; 一位数组下标</font></strong>.</p>
<ul>
<li><p>i j差值大于 1  则 x = 0;</p>
</li>
<li><p>前面i-1行共有 3（i-1）-1 个元素</p>
<p>a i j 是第i行 第j - i +2个元素</p>
<p>a i j 是第2i + j  - 2个元素</p>
</li>
</ul>
</li>
</ul>
<h3 id="稀疏矩阵"><a href="#稀疏矩阵" class="headerlink" title="稀疏矩阵"></a>稀疏矩阵</h3><p><strong>概念：</strong>非零元素远远少于矩阵元素的个数</p>
<p><strong>压缩存储策略</strong></p>
<ul>
<li>顺序存储 ——三元组【行，列 ，值】，只存储非零数。<ul>
<li>失去随机存取的特性</li>
</ul>
</li>
<li>链式存储——十字链表法</li>
</ul>
<h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ul>
<li>存储上三角、下三角。</li>
<li>行优先、列优先。</li>
<li>矩阵元素的下标从0？1？开始</li>
<li>数组下标从0？1？开始</li>
</ul>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构概念</title>
    <url>/posts/9aeff161/</url>
    <content><![CDATA[<h2 id="数据结构学什么"><a href="#数据结构学什么" class="headerlink" title="数据结构学什么"></a>数据结构学什么</h2><ul>
<li>如何利用程序代码把现实世界的问题<strong>信息化</strong></li>
<li>如何用计算机高效地处理这些信息从而创造价值</li>
</ul>
<blockquote>
<p><strong>“唯一可以确定的是，明天会使我们所有人大吃一惊”</strong></p>
</blockquote>
<h2 id="数据结构基本概念"><a href="#数据结构基本概念" class="headerlink" title="数据结构基本概念"></a>数据结构基本概念</h2><h3 id="数据等基本概念"><a href="#数据等基本概念" class="headerlink" title="数据等基本概念"></a>数据等基本概念</h3><p><strong>数据</strong>： 是<font color='red'>信息的载体</font>,是描述客观事物的数、字符以及所有能输入到计算机中并<font color='red'>被计算机程序识别和处理</font>的符号的集合。数据是计算机程序加工的原料。</p>
<p>现代计算机— 经常处理<font color='red'>非数值型</font>问题</p>
<p>对于非数值型问题</p>
<ul>
<li>我们关心每个个体的具体信息</li>
<li>我们还关心个体之间的关系</li>
</ul>
<p><strong>数据元素</strong>：描述一个个体的具体信息，是<font color='red'>数据的基本单位</font>，通常作为一个整体进行考虑和处理，一个数据元素可由锘若干<font color='red'>数据项</font>组成</p>
<p><strong>数据项</strong>：构成数据元素的<font color='red'>不可分割的最小单位</font>。 </p>
<p><strong>数据对象</strong>：是具有<font color='red'>相同性质</font>的数据元素的集合，是数据的一个子集。</p>
<p><strong>数据结构</strong>：是相互之间存在一种或多种特定<font color='red'>关系</font>的数据元素的集合。</p>
<ul>
<li><strong>同一个数据对象里的数据元素，可以根据关系的不同，组成不同的数据结构</strong></li>
<li><strong>不同的数据元素，可以组成相同的数据结构</strong></li>
</ul>
<h3 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h3><h4 id="逻辑关系"><a href="#逻辑关系" class="headerlink" title="逻辑关系"></a>逻辑关系</h4><p><strong>集合结构</strong></p>
<p><strong>线性结构（一对一）</strong></p>
<ul>
<li>数据元素之间都是一对一的关系</li>
<li>除了第一个元素，所有元素都有唯一的前驱</li>
<li>除了最后一个元素，所有的元素都有唯一的后继</li>
</ul>
<p><strong>树形结构（一对多）</strong></p>
<p><strong>图壮结构（多对多）</strong></p>
<h4 id="数据的运算"><a href="#数据的运算" class="headerlink" title="数据的运算"></a>数据的运算</h4><ul>
<li>针对某种逻辑结构，结合实际需求，定义<font color='red'>基本运算</font>。</li>
</ul>
<p><strong>逻辑关系和数据的运算<font color='red'>定义</font>了一种数据结构</strong></p>
<h4 id="物理结构（存储结构）"><a href="#物理结构（存储结构）" class="headerlink" title="物理结构（存储结构）"></a>物理结构（存储结构）</h4><p><strong>如何用计算机实现数据结构</strong></p>
<ul>
<li>顺序存储<ul>
<li><font color='red'>把逻辑上相邻的元素存储在物理位置上也相邻的存储单位中</font>，元素之间的关系由存储单元的邻接关系来体现。</li>
</ul>
</li>
<li>链式存储<ul>
<li><font color='red'>逻辑上相邻的元素在物理位置上可以不相邻</font>，借助指示元素存储地址的指针来表示元素之间的逻辑关系。</li>
</ul>
</li>
<li>索引存储<ul>
<li>在存储元素信息的同时，还建立附加的<strong>索引表</strong>。索引表中的每项称为索引项，索引项的一般形式是（<strong>关键字，地址</strong>）。</li>
</ul>
</li>
<li>散列存储<ul>
<li>根据元素的<strong>关键字</strong>直接计算出该元素的存储地址，又称为<font color='red'>哈希（Hash）存储</font>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>1、若采用<font color='red'>顺序存储</font>，则各个数据元素在物理上必须是<font color='red'>连续的</font>；<br>     若采用<font color='red'>非顺序存储</font>，则各个数据元素在物理上可以是<font color='red'>离散的</font>；</p>
<p>2、数据的<font color='red'>存储结构</font>会<font color='red'>影响存储空间分配的方便程度</font>。</p>
<p>3、数据的<font color='red'>存储结构</font>会<font color='red'>影响对数据运算的速度</font>。</p>
</blockquote>
<blockquote>
<p>1、<font color='red'>运算的定义</font>是针对逻辑结构的，指出运算的功能；</p>
<p>2、<font color='red'>运算的实现</font>是<font color='red'>针对存储结构</font>的，指出运算的具体操作步骤</p>
</blockquote>
<h4 id="数据类型、抽象数据类型"><a href="#数据类型、抽象数据类型" class="headerlink" title="数据类型、抽象数据类型"></a>数据类型、抽象数据类型</h4><p><strong>数据类型</strong>：是一个值的集合和定义在此集合上的一组操作的总称</p>
<ul>
<li>原子类型：其值不可再分的数据结构。（例如：基本类型，如int、bool）</li>
<li>结构类型：其值可以在分解为若干分量（成分）的数据类型。（例如：结构体）</li>
</ul>
<p><strong>抽象数据类型</strong>：是抽象数据组织以及与之相关的操作</p>
<h2 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h2><h3 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h3><p><strong>程序 = 数据结构 + 算法</strong></p>
<p><strong>算法</strong>：是对<font color='red'>特定问题求解步骤的一种描述</font>，它是指令的<font color='red'>有限</font>序列，其中的苗条指令表示一个或多个操作</p>
<h3 id="算法的五个特征"><a href="#算法的五个特征" class="headerlink" title="算法的五个特征"></a>算法的五个特征</h3><ol>
<li><strong>有穷性</strong>：一个算法必须总在执行<strong>有穷步之后结束</strong>，且每一步都可在在有穷时间内完成<ul>
<li><font color='orange'>算法</font>必须是<font color='red'>有穷的</font>，而<font color='orange'>程序</font>可以是<font color='red'>无穷的</font></li>
</ul>
</li>
<li><strong>确定性</strong>：算法中每条指令必须有确切的含义，对于<font color='red'>相同的输入</font>只能得出<font color='red'>相同的输出</font>。</li>
<li><strong>可行性</strong>：算法中描述的操作都可以通过已经实现的<font color='red'>基本运算执行有限次</font>来实现。</li>
<li><strong>输入</strong>：一个算法有<font color='red'>零个或多个输入</font>，这些输入取自于某个特定的对象的集合。</li>
<li><strong>输出</strong>：一个算法有<font color='red'>一个或多个输出</font>，这些输出是与输入有着某种特定关系的量。</li>
</ol>
<h3 id="“好”算法的特质"><a href="#“好”算法的特质" class="headerlink" title="“好”算法的特质"></a>“好”算法的特质</h3><ol>
<li><strong>正确性</strong>：算法应该能正确地解决求解问题。</li>
<li><strong>可读性</strong>：算法应该具有良好的可读性，以帮助人们理解</li>
<li><strong>健壮性</strong>：输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>
<li><font color='red'>高效率</font>与<font color='red'>低存储需求</font><ul>
<li>高效率：花的时间少，时间复杂度低</li>
<li>低存储需求：不费内存，空间复杂度低。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度的时机、切换与过程、调度方式</title>
    <url>/posts/7f586123/</url>
    <content><![CDATA[<h3 id="一、时机"><a href="#一、时机" class="headerlink" title="一、时机"></a>一、时机</h3><h4 id="1、什么时候需要进程调度"><a href="#1、什么时候需要进程调度" class="headerlink" title="1、什么时候需要进程调度"></a>1、什么时候需要进程调度</h4><ul>
<li>当前运行的进程<strong>主动放弃</strong>处理机(<strong>在有的系统中只允许进程主动放弃处理机</strong>)<ul>
<li>进程正常终止</li>
<li>进程发生异常而终止</li>
</ul>
</li>
<li>当前运行的进程<strong>被动放弃</strong>处理机<ul>
<li>分给进程的时间片用完了</li>
<li>有更高优先级的进程进入就绪队列</li>
</ul>
</li>
</ul>
<h4 id="2、什么时候不能进行进程调度"><a href="#2、什么时候不能进行进程调度" class="headerlink" title="2、什么时候不能进行进程调度"></a>2、什么时候不能进行进程调度</h4><ul>
<li>在<strong>处理中断</strong>的过程中。</li>
<li>进程在<strong>操作系统内核程序临界区</strong>中<ul>
<li>进程<strong>是可以在</strong>普通临界区中是可以进行调度与切换的</li>
</ul>
</li>
<li>在<strong>原子操作过程中（原语）</strong>。</li>
</ul>
<h3 id="二、切换与过程"><a href="#二、切换与过程" class="headerlink" title="二、切换与过程"></a>二、切换与过程</h3><h4 id="1、”狭义的调度“与“切换”的区别"><a href="#1、”狭义的调度“与“切换”的区别" class="headerlink" title="1、”狭义的调度“与“切换”的区别"></a>1、”狭义的调度“与“切换”的区别</h4><ul>
<li>狭义的进程调度是<strong>从就绪队列中选中一个要运行的进程</strong>（这个进程可以是<strong>刚刚被暂停执行的</strong>，也可以是<strong>另一个进程</strong>，后面一种就需要<strong>进程切换</strong>）</li>
<li><strong>进程切换是指一个进程让出处理机，然后由另外一个进程使用处理机</strong></li>
<li><strong>广度的进程调度</strong>包括<strong>选择一个进程和进程切换</strong>两个步骤</li>
</ul>
<h4 id="2、进程切换的过程需要什么"><a href="#2、进程切换的过程需要什么" class="headerlink" title="2、进程切换的过程需要什么"></a>2、进程切换的过程需要什么</h4><ul>
<li>对原来运行进程的数据进行保存</li>
<li>对新进程的数据进行恢复</li>
</ul>
<h4 id="3、注意点"><a href="#3、注意点" class="headerlink" title="3、注意点"></a>3、注意点</h4><ul>
<li><strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁的</strong>进行<strong>进程调度，切换</strong>。必然会使<strong>整个系统的效率降低</strong>，使系统大部分时间都花在进程切换上，而真正执行进程的时间变短</li>
</ul>
<h3 id="三、方式"><a href="#三、方式" class="headerlink" title="三、方式"></a>三、方式</h3><h4 id="1、非剥夺调度方式（非抢占式）"><a href="#1、非剥夺调度方式（非抢占式）" class="headerlink" title="1、非剥夺调度方式（非抢占式）"></a>1、非剥夺调度方式（非抢占式）</h4><ul>
<li><strong>非剥夺调度方式</strong>，又称<strong>非抢占式</strong>。即，只允许进程主动放弃处理机。在运行状态期间即便又更加紧急的任务到达，当前进程依旧会继续使用处理机，直到该进程终止或者主动要求进入阻塞态。</li>
<li>优缺点<ul>
<li>优点<ul>
<li>实现简单</li>
<li>系统开销小</li>
</ul>
</li>
<li>缺点<ul>
<li>无法处理紧急任务</li>
<li>只适合早期批处理系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2、剥夺调度方式（抢占式）"><a href="#2、剥夺调度方式（抢占式）" class="headerlink" title="2、剥夺调度方式（抢占式）"></a>2、剥夺调度方式（抢占式）</h4><ul>
<li><strong>剥夺调度方式</strong>，又称<strong>抢占式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或者紧急的进程需要使用处理机时，则立刻停止正在执行的进程，将处理机分配给更紧急重要的进程。</li>
<li>优缺点<ul>
<li>优点<ul>
<li>可以优先处理更紧急的进程</li>
<li>实现让各进程按时间片轮转执行的功能（通过时钟中断）</li>
<li>适合于分时操作系统、实时操作系统</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p><img src="https://i.loli.net/2020/12/26/VaJfO2i4bG8rCtH.png" alt="image-20201226111643433"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>-笔记 -操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>串</title>
    <url>/posts/58d9577e/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>定义：</strong>即<font color='red'>字符串</font>，是由零个或多个<font color='red'>字符</font>组成的有限序列。一般标记为 S = “    a xx sda an”。</p>
<ul>
<li>其中 S是<font color='red'>串名</font>，</li>
<li>字符的个数n称为<font color='red'>串的长度</font><ul>
<li>n = 0时的串称为<font color='red'>空串</font>。</li>
</ul>
</li>
</ul>
<p><strong>术语</strong></p>
<ul>
<li>子串：串中任意多个<font color='red'>连续的</font>字符组成的的子序列称为该串的子串。<ul>
<li>空串也是字串</li>
</ul>
</li>
<li>主串：包含子串的串。</li>
<li>字符在主串中的位置：字符在串中的序号，<strong>从1开始</strong>。</li>
<li>字串在主串中的位置：字串在第一个字符在主串中的位置。<strong>从1开始</strong></li>
<li>空格串：由一个或多个空格组成的串，长度是串中空格字符的个数，<strong>空格串不是空串</strong>。</li>
</ul>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>串的逻辑结构和线性表极为相似，区别仅在于<strong>串的数据对象限定为字符集</strong>，<strong>基本操作对象通常是以<font color='red'>字串</font>作为操作对象</strong>。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">StrAssign(&amp;T , chars): 赋值操作。把串T赋值给chars</span><br><span class="line">StrCopy(&amp;T, S): 复制操作。由串S复制得到串T。</span><br><span class="line">StrEmpty(S): 判空操作。若S为空串，则返回True，否则返回False。</span><br><span class="line">StrLength(S): 求串长。返回串S的元素个数。</span><br><span class="line">ClearString(&amp;S): 求空操作。将S清为空串。</span><br><span class="line">DestroyString(&amp;S): 销毁串。将串S销毁(回收存储空间).</span><br><span class="line">Concat(&amp;S,S1,S2): 串联结。用T返回由S1和S2链接而成的新串。</span><br><span class="line">SubString(&amp;Sub,S,pos,len):求子串。用Sub返回串S的第pos个字符起长度为len的子串。</span><br><span class="line">Index(S,T): 定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</span><br><span class="line">StrCompare(S,T):比较操作，若S&gt;T,则返回值&gt;0;若S&#x3D;T,则返回值&#x3D;0； 若S&lt;T,则返回值&lt;0.</span><br></pre></td></tr></table></figure>

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><strong>定长顺序存储—结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255		<span class="comment">//预定义最长串长为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[MAXLEN];	<span class="comment">//每个分量存储一个字符,静态数组</span></span><br><span class="line">    <span class="keyword">int</span> length;			<span class="comment">//串的实际长度</span></span><br><span class="line">&#125;SString;</span><br><span class="line"><span class="comment">//为了使数组的下标与串的位置相等，数组从下标1开始。ch[0]是空的</span></span><br></pre></td></tr></table></figure>

<p><strong>堆分配存储—结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLEN 255		<span class="comment">//预定义最长串长为255</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ch;		<span class="comment">//按串长分配存储区。ch指向串的基地址。</span></span><br><span class="line">    <span class="keyword">int</span> length;		<span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;			<span class="comment">//动态数组实现，堆分配实现</span></span><br><span class="line"></span><br><span class="line">HString S;</span><br><span class="line">S.ch = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(MAXLEN * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));		<span class="comment">//需要手动free</span></span><br><span class="line">S-&gt;length = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>链式存储——结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch;		<span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode,* <span class="keyword">String</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	char类型一个字节，struct StringNode * 占四个字节</span></span><br><span class="line"><span class="comment">	这样的结构体存储密度低。</span></span><br><span class="line"><span class="comment">	为了改进该存储结构，提高存储密度，我们把每个结构体存储的数据提高</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">4</span>];		<span class="comment">//每个结点存1个字符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StringNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StringNode,* <span class="keyword">String</span>;</span><br></pre></td></tr></table></figure>

<h2 id="基本操作（基于静态数组）"><a href="#基本操作（基于静态数组）" class="headerlink" title="基本操作（基于静态数组）"></a>基本操作（基于静态数组）</h2><p><strong>求子串</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SubString(&amp;Sub,S,pos,len):求子串。用Sub返回串S的第pos个字符起长度为len的子串。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SubString</span><span class="params">(SString &amp;Sub,SString S,<span class="keyword">int</span> pos,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//子串范围越界</span></span><br><span class="line">    <span class="keyword">if</span>(pos + len <span class="number">-1</span> &gt; S.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; pos + len; i++)&#123;</span><br><span class="line">        Sub.ch[i - pos + <span class="number">1</span>] = S.ch[i];</span><br><span class="line">        Sub.length = len;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>串比较</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//StrCompare(S,T):比较操作，若S&gt;T,则返回值&gt;0;若S=T,则返回值=0； 若S&lt;T,则返回值&lt;0.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StrCompare</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= S.length &amp;&amp; i&lt;=T.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] != T.ch[i])</span><br><span class="line">            <span class="keyword">return</span> S.ch[i] - T.ch[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扫描过的所有字符都相同，则长度长的串更大</span></span><br><span class="line">    <span class="keyword">return</span> S.length - T.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>定位操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Index(S,T): 定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = StrLength(S),m = StrLength(T);</span><br><span class="line">    SString sub;	<span class="comment">//用于暂存子串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n-m+<span class="number">1</span>)&#123;</span><br><span class="line">        SubString(sub, S, i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T) != <span class="number">0</span>) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i ;<span class="comment">//返回子串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">//S中不存在与T相等的子串。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><strong>定义：</strong>在主串中找到与模式串相同的子串，并返回其所在位置。</p>
<ul>
<li>子串：主串的一部分，一定存在。</li>
<li>模式串：不一定能在主串中找到。</li>
</ul>
<h3 id="朴素模式匹配算法"><a href="#朴素模式匹配算法" class="headerlink" title="朴素模式匹配算法"></a>朴素模式匹配算法</h3><ul>
<li><p><strong><font color='red'>暴力求解</font></strong></p>
</li>
<li><p>假定<strong>主串长度为n，模式串长度为m</strong></p>
</li>
<li><p>概念：将主串中<strong><font color='red'>所有长度为m的子串依次与模式串对比</font></strong>，直到找到一个完全匹配的子串，或者所有子串都不匹配。</p>
<ul>
<li>最多有<strong>n-m+1</strong>个子串</li>
</ul>
</li>
<li><p><strong>最坏时间复杂度：O(nm)</strong></p>
<p><strong>最好时间复杂度：O(n)</strong></p>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用基本操作实现算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n = StrLength(S),m = StrLength(T);</span><br><span class="line">    SString sub;	<span class="comment">//用于暂存子串</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= n-m+<span class="number">1</span>)&#123;		<span class="comment">//最多对比n-m+1个子串</span></span><br><span class="line">        SubString(sub, S, i,m);</span><br><span class="line">        <span class="keyword">if</span>(StrCompare(sub,T) != <span class="number">0</span>) i++;		<span class="comment">//如果不匹配，就尝试匹配下一个子串</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> i ;<span class="comment">//返回子串在主串中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">//S中不存在与T相等的子串，匹配失败。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不使用基本操作实现算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">int</span><span class="params">(SString S,SString T)</span></span>&#123;</span><br><span class="line">  	<span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(S.ch[i] == T.ch[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;	<span class="comment">//子串匹配比较</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;	<span class="comment">//匹配失败，指针后退重新开始匹配</span></span><br><span class="line">            i = i - j + <span class="number">2</span> ;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length) 	<span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><ul>
<li><strong><font color='red'>最坏时间复杂度 O(m+n)</font></strong><ul>
<li><strong>next数组时间复杂度：O(m)</strong></li>
<li><strong>模式匹配过程最坏时间复杂度：O(n)   //主串不回溯</strong></li>
</ul>
</li>
</ul>
<h4 id="手算next数组"><a href="#手算next数组" class="headerlink" title="手算next数组"></a>手算next数组</h4><ul>
<li><strong><font color='red'>next[1]都无脑写0</font></strong></li>
<li><strong><font color='red'>next[2]都无脑写1</font></strong></li>
<li><strong><font color='red'>其他next</font></strong>：在不匹配的位置前，划一根分界限，模式串一步一步往后退，<strong>直到分界线之前“能对上”，或者模式串完全跨越分界线为止</strong>。此时j指向哪里，next数组就是多少。</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//next[] 当匹配失败时，j指针需要回溯到多少位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Index_KMP</span><span class="params">(SString S,SString T,<span class="keyword">int</span> next[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>,j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt; T.length)&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        	1、当j==0时，也就是在匹配过程中，模式串和子串第一个字符就匹配失败，需要换下一个子串并且模式串的指针后退到第一个字符的位置，但在next数组中，对于以上的情况，把j设置为0，所有我们碰到j==0时，我们需要把j++，并且i++，与匹配成功时的操作相同。</span></span><br><span class="line"><span class="comment">        	2、子串和模式串的某一字符匹配成功时，移动到下一个字符，进行匹配，直到完全匹配或者匹配失败的全款</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">if</span>(j == <span class="number">0</span> || S.ch[i] == T.ch[j])&#123;	</span><br><span class="line">            i++;</span><br><span class="line">            j++;		<span class="comment">//继续比较后面的字符</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];	<span class="comment">//匹配失败时，主串指针i不回溯，模式串指针向右移动</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j &gt; T.length) 	<span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-T.length;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表</title>
    <url>/posts/40f24371/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="定义（逻辑结构）"><a href="#定义（逻辑结构）" class="headerlink" title="定义（逻辑结构）"></a>定义（逻辑结构）</h3><p>线性表是具有<font color='cornflowerblue'>相同</font>数据类型的n（n≥0）个<font color='red'>数据元素</font>的<font color='red'>有限序列</font>，其中n为<font color='red'>表长</font>，当n = 0时，线性表是一个<font color='red'>空表</font>。若用L命名线性表，则一般表示为：L = (a1,a2,….,ai,ai+1….,an)。</p>
<ul>
<li>相同数据类型：每个数据元素所占用的空间一样大。</li>
<li>序列：有次序。</li>
<li>有限：数据元素是有限的，如若“所有的整数按递增次序排列，并<font color='red'>不是线性表</font>”。</li>
<li>描述线性表时，角标是从1开始的</li>
<li>ai是线性表中“第i个”元素线性表中的<font color='red'>位序</font>，<strong>从1开始</strong></li>
<li>a1是<font color='red'>表头元素</font>，an是<font color='red'>表尾元素</font>。</li>
</ul>
<p><strong>线性表的逻辑特性：除了第一个元素之外，每一个元素有且仅有一个直接前驱。除最后一个元素外，每一个元素有且仅有一个直接后驱</strong></p>
<h3 id="为什么要实现数据结构的操作"><a href="#为什么要实现数据结构的操作" class="headerlink" title="为什么要实现数据结构的操作"></a>为什么要实现数据结构的操作</h3><ul>
<li>团队合作编程，你定义的数据结构要让别人能够很方便的使用（封装）</li>
<li>将常用的操作/运算封装成函数，避免重复工作，降低出错的风险</li>
</ul>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   初始化表 InitList(&amp;L)</span><br><span class="line">   销毁表 DestoryList(&amp;L)</span><br><span class="line">   插入  ListInsert(&amp;L,i,e)</span><br><span class="line">删除  Listdelete(&amp;L,i,&amp;e)</span><br><span class="line">   按值查找	LocateElem(L,e)</span><br><span class="line">   按位查找	GetElem(L,i)</span><br><span class="line">   表长 Length(L)</span><br><span class="line">   输出操作 PrintList(L)</span><br><span class="line">   判空操作 Empty(L)</span><br></pre></td></tr></table></figure>

<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><h3 id="代码问题"><a href="#代码问题" class="headerlink" title="代码问题"></a>代码问题</h3><ul>
<li>如何判空</li>
<li>如何判断结点是否在表尾或者表头结点<ul>
<li>后向/前向遍历的实现核心</li>
</ul>
</li>
<li>如何在表头、表中、表尾插入/删除一个结点<ul>
<li>插入、删除操作的不易错思路</li>
</ul>
</li>
</ul>
<h2 id="顺序表（顺序存储）"><a href="#顺序表（顺序存储）" class="headerlink" title="顺序表（顺序存储）"></a>顺序表（顺序存储）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>顺序表</strong>——用<font color='red'>顺序存储</font>的方式实现线性表</p>
<p>顺序存储:把<font color='red'>逻辑上响铃</font>的元素存储在<font color='red'>物理位置上也相邻</font>的存储单元中，元素之间的关系由存储单元的邻接关系来体现</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul>
<li><p>静态分配</p>
<ul>
<li>静态分配的实现下，如果数组存满了——》放弃治疗，顺序表的表长刚开始就已经确定了，无法更改。</li>
</ul>
</li>
<li><p>动态分配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *data;		<span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> MaxSize;	<span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> length;    <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList; 	<span class="comment">//顺序表的类型定义</span></span><br><span class="line"><span class="comment">// new delete</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol>
<li><strong>随机访问</strong>：即可以在O(1)时间内找到第i个元素</li>
<li><strong>存储密度高</strong>：每个节点只存储数据元素。</li>
<li><strong>拓展不方便</strong>：即使采用动态分配的方式实现，拓展长度的时间复杂度也比较高</li>
<li><strong>删除、插入操作不方便，需要移动大量元素。</strong></li>
</ol>
<h3 id="基本操作-静态分配"><a href="#基本操作-静态分配" class="headerlink" title="基本操作(静态分配)"></a>基本操作(静态分配)</h3><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxSize = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MaxSize];  <span class="comment">//用静态的“数组”存放数据元素</span></span><br><span class="line">    <span class="keyword">int</span> length;    <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList; 	<span class="comment">//顺序表的类型定义</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建一个空的线性表L，分配内存空间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(&amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; MaxSize; i ++)&#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;		<span class="comment">//将所有数据元素设置为默认初始值</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>; <span class="comment">//顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入操作</strong></p>
<ul>
<li><strong>注意位序、数组下标的关系,位序 = 数组下标 + 1</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在表L中的第i个位置上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(Sqlist &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>)			<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L.length &gt;= MaxSize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;						<span class="comment">//当前存储空间已满，不能插入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = L.length;j &gt;= i;j--)	<span class="comment">//将第i个元素及以后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j<span class="number">-1</span>];</span><br><span class="line">    L.data[i<span class="number">-1</span>] = e;					<span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;							<span class="comment">// 长度加1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度：T = O(n)</strong> </li>
</ul>
<p><strong>删除操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除表L中的第i个位置的元素，并用引用变量e返回，后续元素依次前移一个位置</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Listdelete</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> i,<span class="keyword">int</span> &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length)	<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.data[i<span class="number">-1</span>];			<span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i;j &lt; L.length; j++)</span><br><span class="line">        L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">    L.length--;					<span class="comment">//线性表长度减1	</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度：T = O(n)</strong> </li>
</ul>
<p><strong>按值查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在表L中查找给定元素的位序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateElem</span><span class="params">(SqList L,<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; L.length;i++)</span><br><span class="line">       <span class="keyword">if</span>(L.data[i] == e) <span class="keyword">return</span> i+<span class="number">1</span>;	<span class="comment">//下标为i的元素值等于e,返回值器位序 i+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;							<span class="comment">//退出循环，说明查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度：T = O(n)</strong> </li>
</ul>
<p><strong>按位查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在表L中查找具有给定位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">GetElem</span><span class="params">(SqList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.length)	<span class="comment">//判断i的范围是否有效</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L.data[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度：T = O(1)</strong> </li>
</ul>
<h2 id="链表-链式存储"><a href="#链表-链式存储" class="headerlink" title="链表(链式存储)"></a>链表(链式存储)</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p><strong>定义</strong>：每个节点除了存放数据元素之外，还要存储指向下一个节点的指针。</p>
<p>优缺点</p>
<ul>
<li>优点：不要求大片连续空间，改变容量方便。</li>
<li>缺点：不可随机存取，需要耗费一定空间存放指针。</li>
</ul>
<h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>			<span class="comment">//定义单链表结构点类型</span></span><br><span class="line">    ElemType data;				<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>			<span class="comment">//指针域</span></span><br><span class="line">&#125;LNode,^LinkList;</span><br><span class="line"><span class="comment">//强调这是一个单链表			--使用LinkList</span></span><br><span class="line"><span class="comment">//强调这是一个结点			 --使用LNode *</span></span><br></pre></td></tr></table></figure>

<h5 id="不带头节点的单链表"><a href="#不带头节点的单链表" class="headerlink" title="不带头节点的单链表"></a>不带头节点的单链表</h5><p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = <span class="literal">NULL</span>;	<span class="comment">//空表。暂时还没有任何一个结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断为空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在表L中的第i个位置(位序)上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)		<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)&#123;		<span class="comment">//插入第1个结点的操作与其他结点操作不同。</span></span><br><span class="line">        LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = L;</span><br><span class="line">        L = s;	<span class="comment">//头指针指向新节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p;		<span class="comment">//指针p指向当前扫描到的节点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;		<span class="comment">//当前p指向的是第几个节点</span></span><br><span class="line">    p = L;			<span class="comment">//L指向第1个结点（不是头结点）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;		<span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    	j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)		<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;		<span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="带头节点的单链表"><a href="#带头节点的单链表" class="headerlink" title="带头节点的单链表"></a>带头节点的单链表</h5><p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));		<span class="comment">//分配一个头节点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)			<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;			<span class="comment">//头节点之后暂时还没有节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头结点看成是第0个结点；</span></span><br></pre></td></tr></table></figure>

<p><strong>判断为空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在表L中的第i个位置(位序)上插入指定元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(LinkList &amp;L,<span class="keyword">int</span> i,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)		<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;		<span class="comment">//指针p指向当前扫描到的节点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;		<span class="comment">//当前p指向的是第几个节点</span></span><br><span class="line">    p = L;			<span class="comment">//L指向头节点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;		<span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    	j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)		<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;		<span class="comment">//将结点s连到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)</li>
</ul>
<p><strong>指定结点的后插操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后插操作：在p结点之后插入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNode</span><span class="params">(LNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>( s == <span class="literal">NULL</span>)	<span class="comment">//	内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;data = e;		<span class="comment">//用结点s保存数据元素e</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;		<span class="comment">//将结点s连接到p之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(1)</li>
</ul>
<p><strong>指定结点的前插操作</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前插操作：在p结点之后前入元素e</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNode</span><span class="params">(LNode *p,ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    <span class="keyword">if</span>( s == <span class="literal">NULL</span>)	<span class="comment">//	内存分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    	由于找不到p结点的前一个结点，但为了实现前插操作，这里使用后插操作，将s插入p之后，</span></span><br><span class="line"><span class="comment">    	再将s、p的数据进行交换，以达到前插操作的效果</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;		<span class="comment">//将结点s连接到p之后</span></span><br><span class="line">    s-&gt;data = p-&gt;data;		<span class="comment">//用s、p交换数据</span></span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(1)</li>
</ul>
<p><strong>按位序删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(LinkList &amp;L.<span class="keyword">int</span> i,ElemType &amp;e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *p;	<span class="comment">//指针p指向当前扫描的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;	<span class="comment">//当前p指向的是第几个节点</span></span><br><span class="line">    p = L;		<span class="comment">//L指向头结点，头节点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span>( p != <span class="literal">NULL</span> &amp;&amp; j &lt; i<span class="number">-1</span>)&#123;	<span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">        p = p-next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)	<span class="comment">//i值不合法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span>)		<span class="comment">//第i-1个结点之后已无其他结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;		<span class="comment">//令q指向被删除结点</span></span><br><span class="line">    e = q-&gt;data;			<span class="comment">//用e返回元素的值</span></span><br><span class="line">    p-&gt;next = q-next;		<span class="comment">//将*q结点从链中“断开”</span></span><br><span class="line">    <span class="built_in">free</span>(q)					<span class="comment">//释放结点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;			<span class="comment">//删除成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)</li>
</ul>
<p><strong>删除指定结点p</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里p结点不能是最后一个结点，否者p-&gt;next = NULL,而p-&gt;next-data就会出现错误</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeleteNode</span><span class="params">(LNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LNode *q = p-&gt;next;		<span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">    p-&gt;data = p-&gt;next-&gt;data		<span class="comment">//和后继结点交换数据域</span></span><br><span class="line">    p-&gt;next = q-&gt;next;		<span class="comment">//将*q结点从链中断开</span></span><br><span class="line">    <span class="built_in">free</span>(q)					<span class="comment">//释放后继节点的存储空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(1)</li>
</ul>
<p><strong>按位查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素（带头结点）</span></span><br><span class="line"><span class="function">LNode * <span class="title">GetElem</span><span class="params">(LinkList L,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    LNode *p;		<span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;		<span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">    p = L;			<span class="comment">//L指向头结点，头结点是第0个结点（不存数据）</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)&#123; <span class="comment">// 	循环找到第i个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    	j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i值不合法，则返回一个NULL</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)</li>
</ul>
<p><strong>按值查找</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域 == e的结点</span></span><br><span class="line"><span class="function">LNode * <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span></span>&#123;</span><br><span class="line">    LNode *p = L-&gt;next;</span><br><span class="line">    <span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; !check(p-data,e))	<span class="comment">//check函数：两个ElemType是否相等</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;	<span class="comment">//找到后返回该结点指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)</li>
</ul>
<p><strong>表的长度</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    LNode *p = L;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;	<span class="comment">//check函数：两个ElemType是否相等</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    	len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)</li>
</ul>
<h4 id="单链表的建立"><a href="#单链表的建立" class="headerlink" title="单链表的建立"></a>单链表的建立</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>初始化一个单链表</li>
<li>每次取一个数据元素，插入到表尾/表头</li>
</ol>
<h5 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法建立单链表</span></span><br><span class="line"><span class="function">LinkList <span class="title">List_TailInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;	<span class="comment">//正向建立单链表</span></span><br><span class="line">    <span class="keyword">int</span> x;								<span class="comment">//设置ElemType为整形</span></span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));	<span class="comment">//建立头节点</span></span><br><span class="line">    LNode *s,*r = L;						<span class="comment">//r为表尾指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);			<span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        r-&gt;next = s;</span><br><span class="line">        r = s;		永远保持r(尾指针)指向最后一个结点</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next = <span class="literal">NULL</span>;			<span class="comment">//尾结点设置为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)</li>
</ul>
<h5 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">    LNode *s;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    L = (LinkList) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));	<span class="comment">//创建头结点;</span></span><br><span class="line">    L-next = <span class="literal">NULL</span>;				<span class="comment">//初始化为空链表</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);				<span class="comment">//输入结点的值</span></span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">9999</span>)&#123;</span><br><span class="line">        s = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));	<span class="comment">//创建新的结点</span></span><br><span class="line">        s.data = x;</span><br><span class="line">        s.next = L-&gt;next;</span><br><span class="line">        L-next = s;		<span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度</strong>：O(n)</li>
<li>应用于链表的逆置</li>
</ul>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span>		<span class="comment">//定义双链表结点类型</span></span><br><span class="line">    ELemType data;			<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>.*<span class="title">next</span>;</span>			<span class="comment">//前驱和后继结点</span></span><br><span class="line">&#125;DNode,*DLinklist;</span><br></pre></td></tr></table></figure>

<p><strong>初始化双链表</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = (DNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));	<span class="comment">//分配头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//内存不足，分配失败；</span></span><br><span class="line">    L-&gt;prior = <span class="literal">NULL</span>;	<span class="comment">//头结点的prior永远指向NULL</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;		<span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DNodeList L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p,DNode *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; s == <span class="literal">NULL</span>)	<span class="comment">//非法参数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(p-next != <span class="literal">NULL</span>)		<span class="comment">//如果p结点有后继结点</span></span><br><span class="line">        p-next-prior = s;</span><br><span class="line">    s-&gt;prior = p;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继节点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InsertNextDNode</span><span class="params">(DNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)	<span class="comment">//非法参数</span></span><br><span class="line">       DNode *q = p-&gt;next;	<span class="comment">//找到p的后继节点</span></span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)		<span class="comment">//p没有后续结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p-next = q-&gt;next;</span><br><span class="line">   	<span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)	<span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">        q-next-prior = p;</span><br><span class="line">    <span class="built_in">free</span>(q);		<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span>		<span class="comment">//定义单链表结点类型</span></span><br><span class="line">    ElemType data;			<span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>		<span class="comment">//指针指向下一个节点</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br></pre></td></tr></table></figure>



<p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitList</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line">	L = (LNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));	<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)		<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;next = L;		<span class="comment">//头结点next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>判空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(LinkList L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>是否达到表尾</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(LinkList L,LNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表头结点的prior指向表尾结点；</span><br><span class="line">表尾结点的next指向头结点；</span><br></pre></td></tr></table></figure>

<p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode,*DLinkList;</span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span></span>&#123;</span><br><span class="line">    L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));	<span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)	<span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    L-&gt;prior = L;	<span class="comment">//头结点的prior指向头结点</span></span><br><span class="line">    L-&gt;next = L;	<span class="comment">//头结点的next指向头结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断循环双链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">(DLinkList L)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>是否达到表尾</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断结点p是否为循环双链表的表尾结点 </span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isTail</span><span class="params">(DLinkList L,DNode *p)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>静态链表借组数组来描述线性表中的链式存储结构。</li>
<li>分配一整片<strong>连续</strong>的内存空间，各个结点集中安置。</li>
</ul>
<p><strong>优缺点</strong></p>
<ul>
<li>优点<ul>
<li>增删操作不需要大量移动元素</li>
</ul>
</li>
<li>缺点<ul>
<li>不能随机存取</li>
<li>只能从头结点开始依次往后查找</li>
<li><font color='red'>容量固定不可变</font></li>
</ul>
</li>
</ul>
<h2 id="顺序表与链表对比"><a href="#顺序表与链表对比" class="headerlink" title="顺序表与链表对比"></a>顺序表与链表对比</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul>
<li>都属于线性表，都是线性结构</li>
</ul>
<h3 id="物理结构-存储结构"><a href="#物理结构-存储结构" class="headerlink" title="物理结构/存储结构"></a>物理结构/存储结构</h3><h4 id="顺序表（顺序存储）-1"><a href="#顺序表（顺序存储）-1" class="headerlink" title="顺序表（顺序存储）"></a>顺序表（顺序存储）</h4><ul>
<li>优点<ul>
<li>支持随机存取</li>
<li>存储密度高</li>
</ul>
</li>
<li>缺点<ul>
<li>大片连续空间分配不方便</li>
<li>改变容量不方便</li>
</ul>
</li>
</ul>
<h4 id="链表（链式存储）"><a href="#链表（链式存储）" class="headerlink" title="链表（链式存储）"></a>链表（链式存储）</h4><ul>
<li>优点<ul>
<li>离散的小空间分配方便</li>
<li>改变容量方便</li>
</ul>
</li>
<li>缺点<ul>
<li>不可随机存取</li>
<li>存储密度低</li>
</ul>
</li>
</ul>
<h3 id="数据的运算-基本操作"><a href="#数据的运算-基本操作" class="headerlink" title="数据的运算/基本操作"></a>数据的运算/基本操作</h3><ul>
<li><p>按值查找</p>
<ul>
<li>顺序表<ul>
<li>无序——O(n)</li>
<li>有序——O(log2n)</li>
</ul>
</li>
<li>链表<ul>
<li>O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p>按序查找</p>
<ul>
<li>顺序表<ul>
<li>O(1)</li>
</ul>
</li>
<li>链表<ul>
<li>O(n)</li>
</ul>
</li>
</ul>
</li>
<li><p>插入/删除</p>
<ul>
<li>顺序表,<strong>时间开销主要来自于移动元素</strong><ul>
<li>O(n)</li>
</ul>
</li>
<li>链表<strong>时间开销主要来自于查找元素</strong><ul>
<li>O(n)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul>
<li>表长难以预估、经常要增加/删除元素  ——链表</li>
<li>表长可估计，查询（搜索）操作比较多  ——顺序表</li>
</ul>
<h3 id="开放性问题答题思路"><a href="#开放性问题答题思路" class="headerlink" title="开放性问题答题思路"></a>开放性问题答题思路</h3><p>eg：实现线性表时，用顺序表还是链表好</p>
<p>：顺序表和链表的<font color='red'>逻辑结构</font>都是线性结构的，都属于线性表。</p>
<p>但是二者的<font color='red'>存储结构</font>不同，顺序表采用顺序存储….(特点，带来的优缺点)；链表采用链式存储…(特点，导致的优缺点)。</p>
<p>由于采用不同的存储方式实现，因此<font color='red'>基本操作</font>的实现效率也不同。<font color='red'>当初始化时</font>，…;<font color='red'>当插入数据元素时</font>，…;<font color='red'>当删除数据元素时</font>，…;当<font color='red'>查找一个数据元素时</font>,…;</p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/posts/b6c47025/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>队列</strong>是<strong><font color='orange'>只允许在一端进行插入，在另一端删除</font></strong>的<font color='red'>线性表</font>。</p>
<p><strong>特点：先进先出（FIFO）</strong></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li>队头：允许删除元素的一端</li>
<li>队尾：允许插入元素的一端</li>
<li>空队列：</li>
</ul>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InitQueue(&amp;Q): 初始化队列，构造一个空队列Q.</span><br><span class="line">DestroyQueue(&amp;Q): 销毁队列。销毁并释放队列Q所占用的内存空间</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">EnQueue(&amp;Q,x): 入队。若队列Q未满，将x加入，⑩之成为新的队尾。</span><br><span class="line">DeQueue(&amp;Q,&amp;x): 出队。若队列Q未满，删除对头元素，并用x返回。</span><br><span class="line"></span><br><span class="line">GetHead(Q,&amp;x): 读队头元素。若队列Q非空，则将队头元素赋值给x。</span><br></pre></td></tr></table></figure>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li>要判断清楚rear指向的是最后一个元素还是最后一个元素的下一个位置</li>
<li>确定判空的条件<ul>
<li>牺牲一个存储单元——循环队列</li>
<li>增加size变量记录队列长度</li>
<li>增加tag = 0/1用于标记最近的一次操作 出队/入队</li>
</ul>
</li>
</ul>
<h2 id="队列的顺序存储"><a href="#队列的顺序存储" class="headerlink" title="队列的顺序存储"></a>队列的顺序存储</h2><h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10			<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data[MaxSize];		<span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">    <span class="keyword">int</span> front,rear;			<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    <span class="comment">//这里front指向队头元素，rear指向队尾元素的下一个位置 	</span></span><br><span class="line">&#125; SqQueue;		<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，队头、队尾指针指向0；</span></span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判空</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队，只能从队尾入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(队列已满)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear] = x;		<span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = Q.rear + <span class="number">1</span>;	<span class="comment">//队尾指针后移</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查询元素</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得队头元素的值，用x返回</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h4><p><strong>入队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队，只能从队尾入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (Q.rear+<span class="number">1</span>) % MaxSize == Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//队满则报错</span></span><br><span class="line">    Q.data[Q.rear] = x;		<span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>)%MaxSize;	<span class="comment">//队尾指针加一取模</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出队</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队（删除一个队头元素，并用x返回）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)		<span class="comment">//判断队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    x = Q.data(Q.front);</span><br><span class="line">    Q.front = (Q,front + <span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>队列中元素中的个数：(Q.rear - Q.front + MaxSize ) %MaxSize;</li>
</ul>
<h2 id="队列的链式存储"><a href="#队列的链式存储" class="headerlink" title="队列的链式存储"></a>队列的链式存储</h2><p><strong>后插法</strong></p>
<h3 id="基本操作-3"><a href="#基本操作-3" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span>		<span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>			<span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front , *rear;		<span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>

<p><strong>初始化（带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化队列(带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判空(带头结点)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入队(带头结点)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s.next = <span class="literal">NULL</span>;</span><br><span class="line">    s.data = x;</span><br><span class="line">    Q.rear-&gt;next = s;	<span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    Q.rear = s;		<span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出队（带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队，不带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)		</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front-&gt;next;</span><br><span class="line">    x = p.data;		<span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front-&gt;next = p.next;		<span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)			<span class="comment">//若此次是最后一个结点出队，则需要修改rear指针</span></span><br><span class="line">        Q.rear = Q.front;</span><br><span class="line">    <span class="built_in">free</span>(p);	<span class="comment">//释放结点空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>初始化(不带头结点)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向NULL</span></span><br><span class="line">    Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    Q.rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判空（不带头结点）</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断队列是否为空(不带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>入队(不带头结点)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新元素入队,不带头结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q,ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == <span class="literal">NULL</span>)&#123;	<span class="comment">//不带头结点的队列，第一个元素入队时需要特别处理</span></span><br><span class="line">        Q.front = s;		<span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;		<span class="comment">//新结点插入到rear之后</span></span><br><span class="line">    	Q.rear = s;		<span class="comment">//修改表尾指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>出队(不带头结点)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//队头元素出队(不带头结点)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q,ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//空队</span></span><br><span class="line">    LinkNode *p = Q.front;		<span class="comment">//p指向此次出队的结点</span></span><br><span class="line">    x = p-&gt;data;		<span class="comment">//用变量x返回队头元素</span></span><br><span class="line">    Q.front = p-&gt;next;		<span class="comment">//修改front指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)&#123;		<span class="comment">//此次是最后一个结点出队，出对后则队列为空队列</span></span><br><span class="line">        Q.front = <span class="literal">NULL</span>;</span><br><span class="line">    	Q.rear = <span class="literal">NULL</span>;		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);		<span class="comment">//释放空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>允许从<font color='red'>两端插入、两端删除</font>的线性表</strong></p>
<p><strong>输入受限的双端队列：</strong>只允许从<font color='red'>一端插入、两端删除</font>的线性表。</p>
<p><strong>输入受限的双端队列：</strong>只允许从<font color='red'>两端插入、一端删除</font>的线性表。</p>
<p><strong><font color='red'>在栈中合法的输出序列，在双端队列中必定合法</font></strong></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="树的层次遍历"><a href="#树的层次遍历" class="headerlink" title="树的层次遍历"></a>树的层次遍历</h3><h3 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h3>]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/posts/7b216a3b/</url>
    <content><![CDATA[<h2 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h2><ul>
<li>空树：结点数为0的树</li>
<li>非空树的特性<ul>
<li>有且仅有一个根节点</li>
<li>没有后继的结点称为“叶子结点”，（或终端结点）</li>
<li>有后继的结点称为“分支结点‘  （或非终端结点）</li>
<li>除了根节点之外，任何一个结点都<font color='red'>有且仅有一个前驱</font></li>
<li>每个结点可有0个或者多个后继。没有后继的结点叫做叶子结点</li>
</ul>
</li>
<li>当n&gt;1时，其余结点可分为m( m &gt; 0)个<font color='red'>互不相交的有限集合</font>，其中每个集合本身又是一棵树，并且称为根节点的<strong><font color='red'>子树。</font></strong></li>
<li>树是一种<strong><font color='red'>递归定义</font></strong>的数据结构</li>
</ul>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="结点之间的关系描述"><a href="#结点之间的关系描述" class="headerlink" title="结点之间的关系描述"></a>结点之间的关系描述</h4><ul>
<li>祖先结点：从该结点出发，前驱及其前驱上面的所有结点都是该结点的祖先节点。</li>
<li>子孙结点：从该结点出发，后继及其后继下面的所有结点都是该结点的子孙结点。</li>
<li>双亲结点（父节点）：该节点的直接前驱就是父节点。</li>
<li>孩子结点：该节点的直接后继就是该节点的孩子结点</li>
<li>兄弟结点：父节点的所有后继节点（除本结点）称为该节点的兄弟结点。</li>
<li>路径：<font color='red'>只能从上往下</font></li>
<li>路径长度：经过了几条边。</li>
</ul>
<h4 id="结点、树的属性描述"><a href="#结点、树的属性描述" class="headerlink" title="结点、树的属性描述"></a>结点、树的属性描述</h4><p><strong>属性</strong></p>
<ul>
<li>结点的层次（深度）——从上往下数，<strong><font color='red'>默认从1开始</font></strong></li>
<li>结点的高度——从下往上数</li>
<li>数的高度——总共多少层</li>
<li>结点的度——有几个孩子（分支）</li>
<li>树的度：树种结点的最大度称为树的度。</li>
</ul>
<p><strong>有序树：</strong>从逻辑上看，树中结点的各子树<strong><font color='red'>从左至右是有次序的</font></strong>，不能互换。</p>
<p><strong>无序树：</strong>从逻辑上看，树中结点的各子树<strong><font color='red'>从左至右是无次序的</font></strong>，可以互换。</p>
<p><strong>森林：</strong>m( m &gt; 0 )颗互不相交的树的集合。</p>
<h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><ul>
<li><strong>树中的结点等于所有结点的度数之和加1。</strong></li>
<li><strong>度为m的树中上之多有m^(i - 1)个结点。</strong></li>
<li><strong>高度为h的m叉树至多有(m^(h) - 1) / (m - 1)</strong></li>
<li><strong>具有n个结点的m叉树的最小高度为㏒(m)(n(m - 1) + 1){向上取整}</strong></li>
</ul>
<p>树的度与m叉树的区别</p>
<ul>
<li>树的度为m：<ul>
<li>任意结点的度 ≤ m (最多m个孩子)</li>
<li>各个结点的度的最大值，至少有一个结点度 = m</li>
<li>一定是非空树，至少有m+1个结点</li>
</ul>
</li>
<li>m叉树：<ul>
<li>任意结点的度 ≤ m（最多m个孩子）</li>
<li>允许所有结点的度 ≤ m，不一定存在一个结点度 = m。</li>
<li>可以是空树</li>
</ul>
</li>
</ul>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><h4 id="双亲表示法-顺序存储"><a href="#双亲表示法-顺序存储" class="headerlink" title="双亲表示法(顺序存储)"></a>双亲表示法(顺序存储)</h4><p><strong>定义</strong>：这种存储方式采用一组<strong>连续空间</strong>来存储每个结点，每个结点中保存指向双亲的“指针“。</p>
<ul>
<li><strong>优点：</strong>查指定结点的双亲很方便</li>
<li><strong>缺点：</strong>查找指定结点的孩子只能从头遍历</li>
</ul>
<p><strong>与二叉树的顺序存储对比</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">二叉树的顺序存储中，一定要把二叉树的结点编号与完全二叉树对应起来。</span><br><span class="line">	结点编号不仅反应了存储位置，也隐含了结点之间的逻辑关系</span><br><span class="line"></span><br><span class="line">而树的顺序存储结构中，数组下标仅仅代表结点的编号，下标中所存的内容指示了结点之间的关系。</span><br></pre></td></tr></table></figure>

<p><strong>存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100		<span class="comment">//树中最多结点数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>				<span class="comment">//树的结点定义</span></span><br><span class="line">    ElemType data;			<span class="comment">//数据元素</span></span><br><span class="line">    <span class="keyword">int</span> parent;				<span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>			<span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];		<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="keyword">int</span> n;			<span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<h4 id="孩子表示法-顺序-链式存储"><a href="#孩子表示法-顺序-链式存储" class="headerlink" title="孩子表示法(顺序+链式存储)"></a>孩子表示法(顺序+链式存储)</h4><p><strong>定义：</strong>将每个结点的孩子结点都用<font color='red'>单链表</font>连接起来形成一个线性结构，也就是一共有n个孩子链表，叶子结点的链表围为空链表</p>
<ul>
<li><strong>优点：</strong>寻找子结点很直接</li>
<li><strong>缺点：</strong>查询父节点需要遍历n个结点的孩子链表</li>
</ul>
<p><strong>存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100		<span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> child;		<span class="comment">//孩子结点在数组中的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>		<span class="comment">//下一次孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">firstChild</span>;</span>		<span class="comment">//第一个孩子</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> n,r;	<span class="comment">//结点树和根的位置</span></span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure>



<h4 id="孩子兄弟表示法-链式存储"><a href="#孩子兄弟表示法-链式存储" class="headerlink" title="孩子兄弟表示法(链式存储)"></a>孩子兄弟表示法(链式存储)</h4><p><strong>定义：</strong>每个结点包括三部分(结点值、指向结点的第一个孩子结点的指针、指向结点下一个兄弟结点的指针)</p>
<ul>
<li><strong>优点：</strong>方便的实现树转换为二叉树的操作，易于查询结点的孩子等</li>
<li>从当前结点查询其窗前结点比较麻烦<ul>
<li>为此我们可以每个结点增加一个父节点域指向父节点。</li>
</ul>
</li>
</ul>
<p><strong>存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;			<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span>		<span class="comment">//第一个孩子和右兄弟指针</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure>

<h3 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h3><h4 id="树—-gt-二叉树"><a href="#树—-gt-二叉树" class="headerlink" title="树—&gt;二叉树"></a>树—&gt;二叉树</h4><p><strong>规则</strong>：每个结点左指针指向它的第一个孩子，右指针指向它在树种的相邻右兄弟，=》<strong>左孩子右兄弟</strong></p>
<p><strong>画法</strong></p>
<ol>
<li>在兄弟节点之间加一连线。</li>
<li>对每个结点，只保留它与第一个孩子的连线，而与其他孩子的连线全部抹掉</li>
<li>以树根为轴心，顺时针旋转45°</li>
</ol>
<h4 id="森林—-gt-二叉树"><a href="#森林—-gt-二叉树" class="headerlink" title="森林—&gt;二叉树"></a>森林—&gt;二叉树</h4><p><strong>规则：</strong>先把森林中的每棵树转换成二叉树，由于任何一颗和树对应的二叉树的右子树必空，所有将第二课树视为第一棵树的右兄弟，第三棵树视为第二棵树的右兄弟…</p>
<p><strong>画法</strong></p>
<ol>
<li>将森林中的每棵树转换成对应的<strong>孩子兄弟表示法</strong>二叉树</li>
<li>每棵树的根也可视为兄弟关系，在每棵树的根之间加一根线</li>
<li>以第一棵树的轴心顺时针旋转45°</li>
</ol>
<h3 id="树、森林的遍历"><a href="#树、森林的遍历" class="headerlink" title="树、森林的遍历"></a>树、森林的遍历</h3><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h4><h5 id="先根遍历"><a href="#先根遍历" class="headerlink" title="先根遍历"></a>先根遍历</h5><p><strong>定义：</strong>若树非空，先访问根节点，再依次对每颗子树进行先根遍历</p>
<p><strong><font color='orange'>树的先根遍历序列与这棵树相应二叉树的<font color='red'>先</font>序序列相同</font></strong></p>
<h5 id="后根遍历"><a href="#后根遍历" class="headerlink" title="后根遍历"></a>后根遍历</h5><p><strong>定义：</strong>若树非空，先依次对每颗子树进行后根遍历，最后访问根节点。</p>
<p><strong><font color='orange'>树的后根遍历序列与这棵树相应二叉树的<font color='red'>中</font>序序列相同</font></strong></p>
<h5 id="层序遍历-队列实现"><a href="#层序遍历-队列实现" class="headerlink" title="层序遍历(队列实现)"></a>层序遍历(队列实现)</h5><ol>
<li>若树非空，则根结点入队</li>
<li>若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队</li>
<li>重复步骤2直到队列为空</li>
</ol>
<h4 id="森林的遍历"><a href="#森林的遍历" class="headerlink" title="森林的遍历"></a>森林的遍历</h4><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p><strong>就是各树的先根遍历</strong></p>
<p>若森林非空，则按如下规则进行遍历：</p>
<ol>
<li>访问僧林中第一棵树的根节点</li>
<li>先序遍历第一棵树中根节点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ol>
<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p><strong>就是各个树的后根遍历</strong></p>
<p>若森林非空，则按如下规则进行遍历：</p>
<ol>
<li>中序遍历第一棵树中根节点的子树森林</li>
<li>访问僧林中第一棵树的根节点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林。</li>
</ol>
<h2 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>二叉树是n(n ≥ 0)个结点的有限集合</p>
<ul>
<li>或者为<font color='red'>空二叉树</font>，即n = 0；</li>
<li>或者由一个<font color='red'>根节点</font>和两个互不相交的被称为根的<font color='red'>左子树</font>和<font color='red'>右子树</font>组成。左子树和右子树右分别是一颗二叉树</li>
<li>特点<ul>
<li>每个结点至多只有两颗子树。</li>
<li>左右子树不能颠倒（二叉树是<font color='red'>有序树</font>）。</li>
</ul>
</li>
</ul>
<h3 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h3><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><strong>定义：</strong>一个高度为h，且含有2∧(h) - 1个结点的二叉树。</p>
<p><strong>特点</strong></p>
<ol>
<li>只有最后一层有叶子节点</li>
<li>不存在度为1的结点</li>
<li>按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为 i /2{向下取整}(如果有的话)</li>
</ol>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><strong>定义:</strong>当且仅当<strong>其每个结点都与高度h的满二叉树中编号1~n的结点一一对应</strong>时，称为完全二叉树。</p>
<p><strong>特点</strong></p>
<ol>
<li><p>只有最后两层可能有叶子结点。</p>
</li>
<li><p><strong>最多只有一个度为1的结点，且该结点只有左孩子而无右孩子</strong>。</p>
</li>
<li><p>按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为 i /2{向下取整}(如果有的话)</p>
</li>
<li><p>i ≤ (n / 2){向下取整}为分支结点， i &gt;  (n / 2){向下取整}为分支结点</p>
</li>
<li><p>若n为<strong>奇数</strong>，则每个分支结点都有左孩子和右孩子；</p>
<p>若n为<strong>偶数</strong>，则最大编号的分支节点（编号为 ( n / 2 ) ）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。</p>
</li>
</ol>
<h4 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h4><p><strong>定义：</strong>一颗二叉树或者是空二叉树，或者具有如下性质的二叉树：</p>
<ul>
<li><strong><font color='red'>左子树</font></strong>上所有的结点的<strong><font color='orange'>关键字</font></strong>均<strong><font color='orange'>小于根节点</font></strong>的关键字。</li>
<li><strong><font color='red'>右子树</font></strong>上所有的结点的<strong><font color='orange'>关键字</font></strong>均<strong><font color='orange'>大于根节点</font></strong>的关键字。</li>
<li>左子树和右子树又各是一颗二叉排序树。</li>
</ul>
<h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><strong>定义：</strong>树上任一结点的<font color='orange'>左子树</font>和<font color='orange'>右子树</font>的<font color='orange'>深度之差不超过1</font>.</p>
<h3 id="常考性质"><a href="#常考性质" class="headerlink" title="常考性质"></a>常考性质</h3><h4 id="考点一"><a href="#考点一" class="headerlink" title="考点一"></a>考点一</h4><p> <strong>设非空二叉树中度为0，1和2的结点个数分别由n0，n1和n2，则<font color='red'>n0 = n2 +1</font>(叶子结点比二分支结点多一个)</strong></p>
<p><strong>证明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设树中结点总数为n，则</span><br><span class="line">	1、n &#x3D; n0 + n1 + n2</span><br><span class="line">	2、n &#x3D; n1 + 2n2 + 1</span><br><span class="line">&#x3D;&#x3D;&gt; n0 &#x3D; n2 +1</span><br></pre></td></tr></table></figure>

<h4 id="考点二"><a href="#考点二" class="headerlink" title="考点二"></a>考点二</h4><p><strong>二叉树中第i层上之多有2^(i - 1)个结点。</strong></p>
<h4 id="靠点三"><a href="#靠点三" class="headerlink" title="靠点三"></a>靠点三</h4><p><strong>高度为h的二叉树至多有2^(h) - 1（满二叉树）</strong></p>
<h4 id="考点四"><a href="#考点四" class="headerlink" title="考点四"></a>考点四</h4><p><strong>对于完全二叉树，可以由的结点数n推出度为0、1、2的结点数为n0、n1和n2</strong></p>
<p><strong>推论</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">完全二叉树最多只有一个度为1的结点，即 n1 &#x3D; 0 或 1</span><br><span class="line">由考点一得出 n0 &#x3D; n2 + 1</span><br><span class="line">所有 n0 + n2 &#x3D; 2n2 + 1 &#x3D;&gt;奇数</span><br><span class="line">当完全二叉树有2k个(偶数)个结点，则必有  n1 &#x3D; 1,n0 &#x3D; k,n2 &#x3D; k-1</span><br><span class="line">当完全二叉树有2k+1个(奇数)个结点，则必有 n1 &#x3D; 0; n0 &#x3D; k + 1;n2 &#x3D; k</span><br></pre></td></tr></table></figure>

<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><ul>
<li>顺序存储适合使用在<strong>完全二叉树或者满二叉树</strong></li>
<li>把二叉树的结点编号与完全二叉树对应起来</li>
</ul>
<p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    ElemType value;		<span class="comment">//结点中的数据元素</span></span><br><span class="line">    <span class="keyword">bool</span> isEmpty;		<span class="comment">//结点是否为空</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TreeNode t[MaxSize];</span><br><span class="line"><span class="comment">//定义一个长度为MaxSize的数组t，按照从上至下，从左至右的顺序依次存储 完全二叉树或者满二叉树 中的各个节点</span></span><br></pre></td></tr></table></figure>

<h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;			<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchidld</span>,*<span class="title">rchild</span>;</span>		<span class="comment">//左、右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>

<ul>
<li>n个结点的二叉链表有<strong>n+1</strong>个空指针域</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p><strong>遍历：</strong>按照某种次序把所有结点都访问一遍。</p>
<p><strong>三种遍历方式：</strong>(序：按照根结点在何时被访问)</p>
<ul>
<li>先序遍历(NLR)</li>
<li>中序遍历(LNR)</li>
<li>后序遍历(LRN)</li>
</ul>
<h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><p><strong>步骤</strong></p>
<ul>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空，则<ol>
<li>访问根节点</li>
<li>访问左子树</li>
<li>访问右子树</li>
</ol>
</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(T);		<span class="comment">//访问根节点</span></span><br><span class="line">        PreOrder(T-&gt;lchild);		<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PreOrder(T-&gt;rchild);		<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度：O(n)</strong></li>
<li><strong>空间复杂度：O(h)</strong></li>
</ul>
<h3 id="中序遍历-LNR"><a href="#中序遍历-LNR" class="headerlink" title="中序遍历(LNR)"></a>中序遍历(LNR)</h3><p><strong>步骤</strong></p>
<ul>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空，则<ol>
<li>访问左子树</li>
<li>访问根节点</li>
<li>访问右子树</li>
</ol>
</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InOrder(T-&gt;lchild);		<span class="comment">//递归遍历左子树</span></span><br><span class="line">        visit(T);		<span class="comment">//访问根节点</span></span><br><span class="line">        InOrder(T-&gt;rchild);		<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度：O(n)</strong></li>
<li><strong>空间复杂度：O(h)</strong></li>
</ul>
<h3 id="后序遍历-LRN"><a href="#后序遍历-LRN" class="headerlink" title="后序遍历(LRN)"></a>后序遍历(LRN)</h3><p><strong>步骤</strong></p>
<ul>
<li>若二叉树为空，则什么都不做</li>
<li>若二叉树非空，则<ol>
<li>访问左子树</li>
<li>访问右子树</li>
<li>访问根节点</li>
</ol>
</li>
</ul>
<p><strong>实现</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostOrder(T-&gt;lchild);		<span class="comment">//递归遍历左子树</span></span><br><span class="line">        PostOrder(T-&gt;rchild);		<span class="comment">//递归遍历右子树</span></span><br><span class="line">        visit(T);		<span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>时间复杂度：O(n)</strong></li>
<li><strong>空间复杂度：O(h)</strong></li>
</ul>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><ol>
<li>初始化一个辅助<font color='orange'>队列</font></li>
<li>根节点入队</li>
<li>若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾(如果有的话)。</li>
<li>重复3直至队列为空。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    LinkQueue Q;		<span class="comment">//链队列</span></span><br><span class="line">    InitQueue(Q);		<span class="comment">//初始化辅助队列</span></span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q,T);		<span class="comment">//将根节点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;	<span class="comment">//队列不空则循环</span></span><br><span class="line">        DeQueue(Q,p);	<span class="comment">//队头结点出队</span></span><br><span class="line">        visit(p);		<span class="comment">//访问出队结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q,p-&gt;lchirld);		<span class="comment">//左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            EnQueue(Q.p-&gt;rchild);		<span class="comment">//右孩子入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历序列构造二叉树"><a href="#遍历序列构造二叉树" class="headerlink" title="遍历序列构造二叉树"></a>遍历序列构造二叉树</h3><ul>
<li><p>对于不同的二叉树，使用中序遍历，可能得到一个相同的中序遍历序列。</p>
<p><strong>若只是给出一颗二叉树的前/中/后/层    序遍历序列中的一种，不能唯一确定一颗二叉树。</strong></p>
</li>
</ul>
<p><strong>确定唯一的二叉树的三种方法序列组合</strong></p>
<ul>
<li>前序 + 中序 遍历序列</li>
<li>后序 + 中序 遍历序列</li>
<li>层序 + 中序 遍历序列</li>
</ul>
<h4 id="前序-中序-遍历序列"><a href="#前序-中序-遍历序列" class="headerlink" title="前序 + 中序 遍历序列"></a>前序 + 中序 遍历序列</h4><ul>
<li>前序遍历序列： <strong>根节点</strong>         <font color='red'>左子树的前序遍历序列</font>        <font color='orange'>右子树的前序遍历序列</font></li>
<li>中序遍历序列：  <font color='red'>左子树的中序遍历序列</font>         <strong>根节点</strong>        <font color='orange'>右子树的中序遍历序列</font></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">前序:	A D B C E</span><br><span class="line">中序:	B D C A E  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1、由于前序遍历序列第一个出现的结点肯定是根节点，所有可以根据前序遍历序列确定根节点A</span><br><span class="line">2、在中序遍历序列中，A结点左边的结点就是左子树的结点(B D C)，A结点右边的结点就是右子树的结点(E)</span><br><span class="line">	前序遍历序列中左子树(D B C),右子树的结点(E)</span><br><span class="line">3、对于左、右子树重复1、2步骤</span><br><span class="line">	确定D为根节点，B是左子树，C是右子树</span><br><span class="line">	……</span><br></pre></td></tr></table></figure>

<h4 id="后序-中序-遍历序列"><a href="#后序-中序-遍历序列" class="headerlink" title="后序 + 中序 遍历序列"></a>后序 + 中序 遍历序列</h4><ul>
<li><p>后序遍历序列： <font color='red'>左子树的前序遍历序列</font>        <font color='orange'>右子树的前序遍历序列</font>        <strong>根节点</strong> </p>
</li>
<li><p>中序遍历序列：  <font color='red'>左子树的中序遍历序列</font>         <strong>根节点</strong>        <font color='orange'>右子树的中序遍历序列</font></p>
<pre><code>eg:
后序:    A D B C E
中序:    B D C A E 

1、由于后序遍历序列最后一个出现的结点肯定是根节点，所有可以根据后序遍历序列确定根节点E
2、在中序遍历序列中，E结点左边的结点就是左子树的结点(B D C A)，E结点右边的结点就是右子树的结点()
    后序遍历序列中左子树(A D B C),右子树的结点()
3、对于左、右子树重复1、2步骤
    确定C为根节点，(B D)是左子树，A是右子树
    ……</code></pre></li>
</ul>
<h4 id="层序-中序-遍历序列"><a href="#层序-中序-遍历序列" class="headerlink" title="层序 + 中序 遍历序列"></a>层序 + 中序 遍历序列</h4><ul>
<li>层序遍历序列： <strong>根节点</strong>    <font color='red'>左子树的根</font>        <font color='orange'>右子树的根</font></li>
<li>中序遍历序列：  <font color='red'>左子树的中序遍历序列</font>         <strong>根节点</strong>        <font color='orange'>右子树的中序遍历序列</font></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eg</span><br><span class="line">层序:		D A B E F C G H I</span><br><span class="line">中序:		E A F D H C B G I</span><br><span class="line"></span><br><span class="line">1、由于层序遍历序列第一个出现的结点肯定是根节点，所有可以根据层序遍历序列确定根节点D</span><br><span class="line">2、在中序遍历序列中，D结点左边的结点就是左子树的结点(E A F)，D结点右边的结点就是右子树的结点(H C B G I)</span><br><span class="line">3、第二层的左子树根节点是A，右子树的根节点是B</span><br><span class="line">	在中序遍历序列中，A结点左边的结点就是左子树的结点(E)，A结点右边的结点就是右子树的结点(F)</span><br><span class="line">	在中序遍历序列中，B结点左边的结点就是左子树的结点(H C)，B结点右边的结点就是右子树的结点(G I)</span><br><span class="line">4、第三层的根节点E F C G </span><br><span class="line">	……</span><br></pre></td></tr></table></figure>

<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>作用</strong>：引入线索二叉树是为了<strong>加快查找结点的结点前驱和后继的速度。</strong></p>
<h4 id="术语-1"><a href="#术语-1" class="headerlink" title="术语"></a>术语</h4><ul>
<li><strong>线索：</strong>指向前驱、后继的指针称为“线索”。</li>
<li><strong>线索化：</strong>将一个二叉链表的空指针指向遍历序列的前驱和后继。</li>
</ul>
<h4 id="三种线索二叉树"><a href="#三种线索二叉树" class="headerlink" title="三种线索二叉树"></a>三种线索二叉树</h4><ul>
<li><strong>中序线索二叉树：</strong>以中序遍历序列为依据进行“线索化‘。</li>
<li><strong>先序线索二叉树：</strong>以先序遍历序列为依据进行“线索化‘。</li>
<li><strong>后序线索二叉树：</strong>以后序遍历序列为依据进行“线索化‘。</li>
</ul>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>存储结构</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线索二叉树的结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;		<span class="comment">//数据元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span>		<span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="keyword">int</span> ltag,rtag;				<span class="comment">//左右线索标志</span></span><br><span class="line">&#125;ThreadNode,*ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	tag == 1 表示指针指向的是“线索”</span></span><br><span class="line"><span class="comment">	tag == 0 表示指针指向的是孩子</span></span><br><span class="line"><span class="comment">	ltag:</span></span><br><span class="line"><span class="comment">		0：lchild域指向结点的左孩子</span></span><br><span class="line"><span class="comment">		1：lchild域指向结点的前驱</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	rtag:</span></span><br><span class="line"><span class="comment">		0：rchild域指向结点的右孩子</span></span><br><span class="line"><span class="comment">		1：rchild域指向结点的后继</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>

<h3 id="手算画出线索二叉树"><a href="#手算画出线索二叉树" class="headerlink" title="手算画出线索二叉树"></a>手算画出线索二叉树</h3><ol>
<li>确定线索二叉树的类型——中序、先序、后序</li>
<li>按照对应遍历规则，确定各个节点的访问顺序，并写上编号</li>
<li>将 n+1 个空链域连上前驱、后继。</li>
</ol>
<h3 id="线索二叉树构造"><a href="#线索二叉树构造" class="headerlink" title="线索二叉树构造"></a>线索二叉树构造</h3><h4 id="中序线索二叉树的构造-代码"><a href="#中序线索二叉树的构造-代码" class="headerlink" title="中序线索二叉树的构造(代码)"></a>中序线索二叉树的构造(代码)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对结点进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadNode</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;rchild = pre;		<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        p-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild,pre);	<span class="comment">//递归，线索化左二叉树</span></span><br><span class="line">        ThreadNode(p,&amp;pre);</span><br><span class="line">        InThread(p-&gt;rchild,pre);	<span class="comment">//递归，线索化右二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;		<span class="comment">//非空二叉树、线索化</span></span><br><span class="line">        InThread(T,pre);		<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="comment">//处理遍历的最后的一个结点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	这里不需要判断是否该结点是否还有右孩子、因为该结点是遍历序列中的最后一位，因为中序遍历是左中右，</span></span><br><span class="line"><span class="comment">        	当该结点有右孩子时，按照中序遍历的规定，该结点就不是序列中的最后一位。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="先序线索二叉树的构造-代码"><a href="#先序线索二叉树的构造-代码" class="headerlink" title="先序线索二叉树的构造(代码)"></a>先序线索二叉树的构造(代码)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对结点进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadNode</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;rchild = pre;		<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        p-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        ThreadNode(p,&amp;pre);</span><br><span class="line">        <span class="comment">//**********</span></span><br><span class="line">        <span class="comment">//这里如果判断，可能出现死循环</span></span><br><span class="line">        <span class="comment">//当p的左孩子指针指向前驱的时候，我们再继续递归遍历，就有回到前驱结点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">        	PreThread(p-&gt;lchild,pre);	<span class="comment">//递归，线索化左二叉树</span></span><br><span class="line">        PreThread(p-&gt;rchild,pre);	<span class="comment">//递归，线索化右二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;		<span class="comment">//非空二叉树、线索化</span></span><br><span class="line">        PreThread(T,pre);		<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="comment">//处理遍历的最后的一个结点</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        	这里不需要判断是否该结点是否还有右孩子、因为该结点是遍历序列中的最后一位，因为先序遍历是中左右，</span></span><br><span class="line"><span class="comment">        	当该结点有右孩子时，按照先序遍历的规定，该结点就不是序列中的最后一位。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="后序线索二叉树的构造-代码"><a href="#后序线索二叉树的构造-代码" class="headerlink" title="后序线索二叉树的构造(代码)"></a>后序线索二叉树的构造(代码)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对结点进行线索化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadNode</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;	<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        p-&gt;lchild = pre;</span><br><span class="line">        p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        p-&gt;rchild = pre;		<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        p-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线索化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree p,ThreadTree &amp;pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        PostThread(p-&gt;lchild,pre);	<span class="comment">//递归，线索化左二叉树</span></span><br><span class="line">        PostThread(p-&gt;rchild,pre);	<span class="comment">//递归，线索化右二叉树</span></span><br><span class="line">        ThreadNode(p,&amp;pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;		<span class="comment">//非空二叉树、线索化</span></span><br><span class="line">        PostThread(T,pre);		<span class="comment">//线索化二叉树</span></span><br><span class="line">        <span class="comment">//处理遍历的最后的一个结点</span></span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;rchild = <span class="literal">NULL</span>;)</span><br><span class="line">        	pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h4><ul>
<li>最后一个结点rchild、rtag的处理</li>
<li>先序线索化中，注意处理死循环的问题，当ltag == 0时，才能最左子树先序线索化。</li>
</ul>
<h3 id="线索二叉树中查找前驱、后继"><a href="#线索二叉树中查找前驱、后继" class="headerlink" title="线索二叉树中查找前驱、后继"></a>线索二叉树中查找前驱、后继</h3><h4 id="中序二叉树"><a href="#中序二叉树" class="headerlink" title="中序二叉树"></a>中序二叉树</h4><h5 id="查找后继"><a href="#查找后继" class="headerlink" title="查找后继"></a>查找后继</h5><p>在中序线索二叉树中找到指定结点*p的中序后继 next</p>
<ul>
<li>若 p -&gt; rtag == 1,则 next = p -&gt;rchild</li>
<li>若 p -&gt; rtag == 0,则右子树中最左下的结点就是后继结点next</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rtag == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> Firstnode(p-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到以p为根的子树中，第一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Firstnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最左下结点(不一定是叶子结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag == <span class="number">0</span>)	p = p-&gt;lchile;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="查找前驱"><a href="#查找前驱" class="headerlink" title="查找前驱"></a>查找前驱</h5><p>在中序线索二叉树中找到指定结点*p的中序前驱 pre</p>
<ul>
<li>若 p -&gt; ltag == 1,则 next = p -&gt;lchild</li>
<li>若 p -&gt; ltag == 0,则左子树中最右下的结点就是前驱结点 pre</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> p-&gt;lchild;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> Lastnode(p-&gt;lchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到以p为根的子树中，最后一个被中序遍历的结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">Lastnode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="comment">//循环找到最右下结点(不一定是叶子结点)</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;rtag == <span class="number">0</span>)	p = p-&gt;rchile;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉排序树-BST"><a href="#二叉排序树-BST" class="headerlink" title="二叉排序树(BST)"></a>二叉排序树(BST)</h2><p><strong>定义</strong></p>
<p>一颗二叉树或者<strong>是空二叉树</strong>，或者<strong>是具有如下性质的二叉树</strong>：</p>
<ol>
<li><p>左子树所有的关键字均小于根结点的关键字</p>
</li>
<li><p>右子树所有的关键字均大于根结点的关键字</p>
</li>
<li><p>左子树和右子树又各是一棵二叉排序树</p>
<p><strong><font color='orange'>左子树结点值 &lt;  根结点值 &lt; 右子树结点值</font></strong></p>
</li>
</ol>
<p><strong>中序遍历序列，可以得到一个递增的有序序列</strong></p>
<h3 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二叉排序树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BSTNode,*BSTree</span><br></pre></td></tr></table></figure>

<p><strong>查找</strong></p>
<ul>
<li>规则<ol>
<li>若树非空，目标值与根节点的值比较</li>
<li>若相等，则查找成功</li>
<li>若小于根节点，则在左子树上查找，否则就在右子树上查找</li>
<li>查找成功，返回结点指针；失败返回NULL;</li>
</ol>
</li>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点(非递归实现)</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BST_Search</span><span class="params">(BSTree T,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(T != <span class="literal">NULL</span> &amp;&amp; key != T-&gt;key)&#123;	<span class="comment">//若树空或者等于根节点值，则结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; T-&gt;key)		<span class="comment">//小于，则在左子树上查找</span></span><br><span class="line">            T = T-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span>					<span class="comment">//大于，则在右子树上查找	</span></span><br><span class="line">            T = T-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏时间复杂度：O(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在二叉排序树中查找值为key的结点(递归实现)</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">BSTSearch</span><span class="params">(BSTree T,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">       <span class="keyword">return</span> T;		<span class="comment">//查找失败</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> T;		<span class="comment">//查找成功</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; T-&gt;key)</span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;lchild,key);	<span class="comment">//在左子树中找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(T-&gt;rchild,key);	<span class="comment">//在右子树中找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最坏时间复杂度：O(h)</span></span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<ul>
<li>规则<ol>
<li>若原二叉排序树为空，则直接插入结点。</li>
<li>若原二叉排序树中已经存在该值的结点，则不插入。</li>
<li>若关键字k小于根节点值，则插入到左子树。</li>
<li>若关键字k大于根节点值，则插入到右子树。</li>
</ol>
</li>
<li>代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在二叉排序树插入关键字为k的新节点(递归实现)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BST_Insert</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)&#123;		<span class="comment">//原树为空，新插入的结点为根节点</span></span><br><span class="line">    	T = (BSTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        T-&gt;key = k;</span><br><span class="line">        T-&gt;lchild = <span class="literal">NULL</span>; </span><br><span class="line">        T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;				<span class="comment">//返回1.则插入成功</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == T-&gt;key)&#123;		<span class="comment">//树中存在相同关键字的结点，插入失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &lt; T-&gt;key)&#123;		<span class="comment">//插入到T的左子树</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;lchild,k);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;						<span class="comment">//插入到T的右子树</span></span><br><span class="line">        <span class="keyword">return</span> BST_Insert(T-&gt;rchild,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Creat_BST</span><span class="params">(BSTree &amp;T,<span class="keyword">int</span> str[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    T = <span class="literal">NULL</span>;		<span class="comment">//初始化T为空树</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n)&#123;		<span class="comment">//依次将每个关键字插入到二叉排序树中</span></span><br><span class="line">        BST_Insert(T.str[i]);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同一组关键字的不同序列可能得到同款二叉排序树，也可能得到不同款二叉排序树</span></span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、被删结点为叶子，直接删除</span><br><span class="line">2、被删结点只有左或只有右子树，用其子树顶替其位置</span><br><span class="line">3、被删结点有左、右子树</span><br><span class="line">	A.可用其后继结点顶替，再删除后继结点</span><br><span class="line">		a.后继：右子树最左下的结点</span><br><span class="line">	B.可用其前驱节点顶替，再删除前驱结点</span><br><span class="line">		b.前驱：左子树中最右下的结点</span><br></pre></td></tr></table></figure>



<h3 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h3><p><strong>查找长度：</strong>在查找运算中，需要对比关键字的次数称为查找长度，反映了查找操作时间复杂度。</p>
<p>若树高h，找到最下层的一个结点需要对比h次。</p>
<ul>
<li><strong>最好情况：</strong>n各结点的二叉树最小高度为   <strong>{㏒(2)(n)}[向下取整]+1</strong></li>
<li><strong>最坏情况：</strong>每个结点只有一个分支，树高h=结点数n，平均查找高度 = O(n)</li>
</ul>
<p><strong>查找成功平均查找长度</strong></p>
<p><strong>查找失败平均查找长度</strong></p>
<h2 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>定义：</strong>简称平衡树(<strong>AVL树</strong>)，树上任一结点的左子树和右子树的高度之差不超过1.</p>
<p><strong><font color='red'>结点的平衡因子 </font>= 左子树高 - 右子树高。</strong></p>
<p>平衡二叉树的平衡因子的值 只可能是 ”-1“、”0“、”1“。</p>
<h3 id="如何保持平衡"><a href="#如何保持平衡" class="headerlink" title="如何保持平衡"></a>如何保持平衡</h3><p>在二叉排序树中插入新结点后，如何保持平衡</p>
<ul>
<li>从插入点往回找到第一个不平衡结点，调整以该结点为根的子树————<font color='red'>最小不平衡子树</font>。</li>
</ul>
<p><strong>目标</strong></p>
<ul>
<li>恢复平衡</li>
<li>保持二叉排序树特性<ul>
<li>左子树结点值 &lt; 根节点值 &lt; 右子树结点值</li>
</ul>
</li>
</ul>
<h4 id="调整最小不平衡子树"><a href="#调整最小不平衡子树" class="headerlink" title="调整最小不平衡子树"></a>调整最小不平衡子树</h4><ul>
<li><strong>只有左孩子才能右上旋</strong></li>
<li><strong>只有右孩子才能左上旋</strong></li>
</ul>
<h5 id="LL-在A的左孩子的左子树中插入导致不平衡"><a href="#LL-在A的左孩子的左子树中插入导致不平衡" class="headerlink" title="LL(在A的左孩子的左子树中插入导致不平衡)"></a>LL(在A的左孩子的左子树中插入导致不平衡)</h5><p>*<em>BL &lt; B &lt; BR &lt; A &lt; AR *</em></p>
<p><strong>操作(右单旋转)</strong>：由于在结点A的左孩子(L)的左子树(L)上插入了新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要一次向右的旋转操作。将A的左孩子<font color='orange'>B向右上旋转</font>代替A成为根节点，将<font color='orange'>A结点向右下旋</font>成为B的右孩子的根节点，<font color='red'>而B的<strong>原右</strong>子树则作为A结点的<strong>左</strong>子树。</font></p>
<h5 id="RR-在A的右孩子的右子树中插入导致不平衡"><a href="#RR-在A的右孩子的右子树中插入导致不平衡" class="headerlink" title="RR(在A的右孩子的右子树中插入导致不平衡)"></a>RR(在A的右孩子的右子树中插入导致不平衡)</h5><p>*<em>AL &lt; A &lt; BL &lt; B &lt; BR  *</em></p>
<p><strong>操作(左单旋转)</strong>：由于在结点A的右孩子(R)的左子树(R)上插入了新结点，A的平衡因子由-1增至-2，导致以A为根的子树失去平衡，需要一次向左的旋转操作。将A的右孩子<font color='orange'>B向左上旋转</font>代替A成为根节点，将<font color='orange'>A结点向左下旋</font>成为B的左孩子的根节点，而<font color='red'>B的<strong>原左</strong>子树则作为A结点的<strong>右</strong>子树</font>。</p>
<h5 id="LR-在A的左孩子的右子树中插入导致不平衡"><a href="#LR-在A的左孩子的右子树中插入导致不平衡" class="headerlink" title="LR(在A的左孩子的右子树中插入导致不平衡)"></a>LR(在A的左孩子的右子树中插入导致不平衡)</h5><p><strong>BL &lt; B &lt; CL &lt; C &lt; CR &lt; A &lt; AR</strong></p>
<p><strong>操作(先左后右双旋转)：</strong>由于在A的左孩子(L)的右孩子(R)上插入新结点，A的平衡因子由1增至2，导致以A为根的子树失去平衡，需要进行<font color='cornflowerblue'>两次旋转操作</font>，先左旋(C)后右旋转(C).先将A结点的左孩子(B)的右子树的<strong>根结点(C)向左上旋转</strong>提升到B结点的位置，然后再把<strong>该结点C向右上旋转</strong>提升到A结点的位置。</p>
<h5 id="RL-在A的右孩子的左子树中插入导致不平衡"><a href="#RL-在A的右孩子的左子树中插入导致不平衡" class="headerlink" title="RL(在A的右孩子的左子树中插入导致不平衡)"></a>RL(在A的右孩子的左子树中插入导致不平衡)</h5><p><strong>AL &lt; A &lt; CL &lt; C &lt; CR &lt; B &lt; BR</strong></p>
<p><strong>操作(先右后左双旋转)：</strong>由于在A的右孩子(R)的左子树(L)上插上新结点，A的平衡因子由-1到-2，导致以A为根的子树失去平衡，需要进行两次旋转操作，<font color='cornflowerblue'>先右旋转后左旋转</font>。先将A结点的右孩子B的左子树的根节点<strong><font color='orange'>C向右上旋转提升至B结点的位置</font></strong>,然后再把该<strong><font color='orange'>C结点想左上旋转提升到A结点的位置</font></strong></p>
<h3 id="基本操作-2"><a href="#基本操作-2" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>结构体定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//平衡二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;		<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">int</span> balance;		<span class="comment">//平衡因子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVLNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>		<span class="comment">//</span></span><br><span class="line">&#125;AVLNode,*AVLTree;</span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<h3 id="查找效率分析-1"><a href="#查找效率分析-1" class="headerlink" title="查找效率分析"></a>查找效率分析</h3><p>假设以n(h)表示深度h的平衡树中含有的<strong>最少结点</strong>数：</p>
<p>则有n(0) = 0，n(1) = 1 , n(2) = 2 ,并且有 <strong>n(h) = n(h-1) + n(h-2) +1</strong>  , </p>
<p>若结点数为n，则<strong>h(max) = O(㏒n);</strong></p>
<p>时间复杂度：<strong>O(㏒n);</strong></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>结点的<font color='orange'>权</font>：</strong>有某种现实含义的数值。</p>
<p><strong><font color='orange'>结点的带权路径长度</font>：</strong>从树的根到该结点的<strong>路径长度</strong>(经过的边数)与该结点上<strong>权值</strong>的<strong>乘积</strong>。</p>
<p><strong><font color='orange'>树的带权路径长度</font>：</strong>树中所有<strong><font color='red'>叶节点</font></strong>的带权路径长度之和。</p>
<p><strong>定义：</strong>在含有n个带权叶节点的二叉树中，其中<strong><font color='orange'>带权路径长度(WPL)最小的二叉树</font></strong>称为<strong><font color='red'>哈夫曼树</font></strong>，也称<strong><font color='red'>最优二叉树</font>。</strong></p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>对于给定n个权值分别为w(1),w(2),w(3),…,w(n)的结点，构造哈夫曼树的算法描述如下：</p>
<ol>
<li>将这n个结点分别作为n棵树仅含一个结点的二叉树，构造森林F。</li>
<li>构造一个新结点，从F中选取<strong>两颗根结点权值最小</strong>的树做为新结点的左、右子树，并将<strong>新结点的权值</strong>置为左、右子树上根结点的权值之和。</li>
<li>从F从删除刚才选出的两棵树，同时将新得到的树加入F中。</li>
<li>重复步骤2、3，直至F中只剩下一棵树为止。</li>
</ol>
<p><strong>性质</strong></p>
<ul>
<li>每个初始结点最终都成为叶节点，且权值越小的结点到根结点的路径长度越大。</li>
<li>哈夫曼树的结点总数为 <strong>2n-1</strong></li>
<li>哈夫曼树中<strong>不存在度为1</strong>的结点</li>
<li>哈夫曼树不唯一，但是<strong>最小带权长度唯一</strong>。</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4>]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/posts/ee040603/</url>
    <content><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><font color='red'>图G</font></strong>由<font color='red'>顶点集V</font>和<font color='red'>边集E</font>组成，记为G = ( V,E),其中V(G)表示图G中顶点的有限非空集；</p>
<p>E(G)表示图G中顶点之间的关系(边)集合。</p>
<p>若V = {v1,v2,v2…，vn}, 则用<strong><font color='red'>|V|</font></strong>表示图G中<font color='red'>顶点的个数</font>，也称为<strong><font color='red'>图G的阶</font>。</strong></p>
<p>E = {( u , v) | <strong><font color='orange'>u∈V，v∈V</font></strong>}，用<strong><font color='red'>|E|</font></strong>表示图G中<strong><font color='red'>边的条数</font></strong>.</p>
<p><strong>注意：线性表可以是空表，树可以是空树，但图不可以是空，即<font color='orange'>V一定的非空集</font>，但是边集E可以为空</strong></p>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><h4 id="特殊的几种图"><a href="#特殊的几种图" class="headerlink" title="特殊的几种图"></a>特殊的几种图</h4><h5 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h5><p>若E是<font color='red'>无向边</font>(简称<font color='red'>边</font>)的有限集合时，则图G为<font color='red'>无向图</font>。边是顶点的无序对，<font color='red'>记为(v,w)或者(w,v)</font>,因为<strong><font color='orange'>(v,w) = (w,v)</font></strong>，其中v、w是顶点。</p>
<p>可以说顶点w和顶点v互为邻接点。边(v，w)依附于顶点w和v，或者说边(v,w)和顶点v、w相关联。</p>
<h5 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h5><p>若E是<font color='red'>有向边</font>(简称<font color='red'>弧</font>)的有限集合时，则图G为<font color='red'>有向图</font>。弧是顶点的有序对，<font color='red'>记为&lt;v,w&gt;</font>，其中v、w是顶点，v称为<font color='red'>弧尾</font>，w称为<font color='red'>弧头</font>，&lt;v,w&gt;称为从顶点v到w的弧，也称v邻接到w，或者w邻接自v。<strong><font color='orange'>&lt;v,w&gt; ≠ &lt;w,v&gt;</font></strong></p>
<h5 id="简单图"><a href="#简单图" class="headerlink" title="简单图"></a>简单图</h5><ul>
<li>不存在重复边</li>
<li>不存在顶点到自身的边</li>
<li>也分为有向图和无向图</li>
</ul>
<h5 id="多重图"><a href="#多重图" class="headerlink" title="多重图"></a>多重图</h5><ul>
<li>存在某两个结点之间的边数多于一条</li>
<li>允许顶点通过同一条边和自己关联</li>
<li>也分为有向图和无向图</li>
<li>数据结构不考虑这种图。</li>
</ul>
<h5 id="无向完全图"><a href="#无向完全图" class="headerlink" title="无向完全图"></a>无向完全图</h5><ul>
<li>无向图中任意两个顶点之间都存在边</li>
<li><strong>边数：C(2)(n)</strong></li>
</ul>
<h5 id="有向完全图"><a href="#有向完全图" class="headerlink" title="有向完全图"></a>有向完全图</h5><ul>
<li>有向图中任意两个顶点之间都存在方向相反的两条弧</li>
<li><strong>边数：2C(2)(n)</strong></li>
</ul>
<h4 id="顶点的度、入度、出度"><a href="#顶点的度、入度、出度" class="headerlink" title="顶点的度、入度、出度"></a>顶点的度、入度、出度</h4><ul>
<li>对于<strong>无向图</strong><ul>
<li><font color='red'>顶点v的度</font>是指依附于该顶点的边的条数，记为TD(v);<ul>
<li><font color='red'>sum{TD(v)} = 2|E|</font></li>
</ul>
</li>
</ul>
</li>
<li>对于<strong>有向图</strong><ul>
<li><font color='red'>入度</font>是以顶点v为终点的有向边的数目，记为<font color='red'>ID(v).</font></li>
<li><font color='red'>出度</font>是以顶点v为起点的有向边的数目，记为<font color='red'>OD(v)</font></li>
<li><font color='red'>顶点v的度</font>等于其<font color='red'>入度和出度之和</font>，即 <font color='red'>TD(v) = ID(v) + OD(v)</font></li>
<li><font color='red'>sum{ID(v)} = sum{OD(v)}  = |E|</font></li>
</ul>
</li>
</ul>
<h4 id="顶点-顶点关系描述"><a href="#顶点-顶点关系描述" class="headerlink" title="顶点-顶点关系描述"></a>顶点-顶点关系描述</h4><ul>
<li><p><font color='red'>路径</font> ——顶点v 到 顶点 w之间有一条路径是指顶点序列：v ,a ,b ,c ….,m,w.</p>
</li>
<li><p><font color='red'>回路</font>—— 第一个顶点和最后一个顶点相同的路径称为<font color='red'>回路或者环</font>。</p>
</li>
<li><p><font color='red'>简单路径</font>—— 在路径序列中，<font color='red'>顶点不重复</font>的路径简称为简单路径。</p>
</li>
<li><p><font color='red'>简单回路</font>——除第一个顶点和最后一个顶点外，<font color='red'>其余顶点不重复</font>出现的回路称为简单回路。</p>
</li>
<li><p><font color='red'>路径长度</font>—— 路径上边的数目。</p>
</li>
<li><p>点到点的距离 ——从顶点u出发到顶点v的<strong><font color='orange'>最短路径</font></strong>若存在，则<strong><font color='orange'>此路径的长度称为从u到v的距离。</font></strong></p>
<p>若从u到v根本<strong><font color='orange'>不存在路径</font></strong>，则<strong><font color='orange'>记该距离为无穷（∞）</font></strong></p>
</li>
<li><p><font color='red'>无向图中</font>，若从顶点v到顶点w有路径存在，则称v和w是<font color='red'>连通</font>font&gt;的</p>
<ul>
<li>若图G中任意两个顶点都是连通的，则称G为<font color='red'>连通图</font>，否则就是<font color='red'>非连通图</font><ul>
<li>对于n个顶点的无向图G，要保证G是连通图，则<strong>最少</strong>有 <strong>n-1</strong>条边。</li>
<li>对于n个顶点的无向图G，要保证G是非连通图，则<strong>最多</strong>可能有 <strong>C(2)(n-1)</strong>条边。</li>
</ul>
</li>
<li>无向图中的极大连通子图称为<font color='red'>连通分量</font><ul>
<li><strong><font color='red'>极大连通子图：</font></strong>子图必须连续，且包含尽可能多的顶点和边</li>
</ul>
</li>
</ul>
</li>
<li><p><font color='red'>有向图中</font>，若从<font color='orange'>顶点v到顶点w</font>和从<font color='orange'>顶点w到顶点v</font>之间都有路径，则称这两个顶点是<font color='red'>强连通</font>的</p>
<ul>
<li>若图G中任意一对顶点都是强连通的，则称G为<font color='red'>强连通图</font><ul>
<li>对于n个顶点的有向图G，要保证G是强连通图，则<strong>最少</strong>有 <strong>n</strong>条边（<strong>形成回路</strong>）。</li>
</ul>
</li>
<li>有向图中的极大强连通子图称为<font color='red'>强连通分量</font><ul>
<li><strong><font color='red'>极大强连通子图：</font></strong>子图必须连续，且包含尽可能多的顶点和边</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="研究图的局部——子图"><a href="#研究图的局部——子图" class="headerlink" title="研究图的局部——子图"></a>研究图的局部——子图</h4><ul>
<li>设有两个图G = (V,E) 和 G’ = ( V’,E’),若V‘是V的子集，且E’是E的子集，则称G‘是G的<font color='red'>子图</font>.<ul>
<li><strong>注意：并未V、E的任何子集都能构成G的子图，因为这样子的子集可能不是图，即E的自己种的某些边关联的顶点可能不在这个V的子集中</strong></li>
</ul>
</li>
<li>若有满足V(G’) = V(G)的子图G’，则称其为G的<font color='red'>生成子图</font></li>
</ul>
<h4 id="生成树、生成森林"><a href="#生成树、生成森林" class="headerlink" title="生成树、生成森林"></a>生成树、生成森林</h4><ul>
<li><strong><font color='orange'>连通图</font></strong>的<font color='red'>生成树</font>是<strong><font color='orange'>包含一个图中全部顶点的一个极小连通子图</font></strong><ul>
<li>极小连通子图：边尽可能的少，但是要保持连通</li>
<li>若图中顶点数为n，则它的生成树含有 n-1条边。对生成树而言，若砍去它的一条边，则会变成非连通图，若加上一条边则可能会形成一个回路</li>
</ul>
</li>
<li><strong><font color='orange'>在非连通图</font></strong>中，<strong><font color='orange'>连通分量的生成树</font></strong>构成了非连通图的<font color='red'>生成森林</font>。</li>
</ul>
<h4 id="边的权、带权图-网"><a href="#边的权、带权图-网" class="headerlink" title="边的权、带权图/网"></a>边的权、带权图/网</h4><ul>
<li><font color='red'>边的权</font>——在一个图中，每条边都可以表上带有某种含义的数值，该数值称为该边的<font color='red'>权值</font></li>
<li><font color='red'>带权图/网</font>——边上带有权值的图称为<font color='red'>带权图</font>，也称<font color='red'>网</font></li>
<li><font color='red'>带权路径长度</font>——当图是带权图时，一条<font color='orange'>路径上所有边的权值之和</font>，称为该路径的<font color='red'>带权路径长度</font>.</li>
</ul>
<h3 id="常见考点"><a href="#常见考点" class="headerlink" title="常见考点"></a>常见考点</h3><h4 id="对于n个顶点的无向图G"><a href="#对于n个顶点的无向图G" class="headerlink" title="对于n个顶点的无向图G"></a>对于n个顶点的无向图G</h4><ul>
<li><p>所有顶点的度之和 = 2|E|</p>
</li>
<li><p>若G是连通图，则最少有n-1条边(数)</p>
<p>若 |E| &gt; n-1,则一定有回路</p>
</li>
<li><p>若G是非连通图，则最多可能有 C(2)(n-1)条边</p>
</li>
<li><p>无向完全图共有C(2)(n)条边</p>
</li>
</ul>
<h4 id="对于n个顶点的有向图G"><a href="#对于n个顶点的有向图G" class="headerlink" title="对于n个顶点的有向图G"></a>对于n个顶点的有向图G</h4><ul>
<li>所有顶点的出度之和 = 入度之和 = |E|</li>
<li>所有顶点的度之和 = 2|E|</li>
<li>若G是强连通图，则最少有n条边(形成回路)</li>
<li>有向完全图共有 2C(2)(n)条边</li>
</ul>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li>指用于一个一位数组存储图中顶点的信息，用一个二维数组存储图中边的信息(即各顶点之间的邻接关系)</li>
<li>若图G的邻接矩阵是A，则<ul>
<li>A[i] [j] = 1 ==&gt;(vi,vj)是E(G)中的边</li>
<li>A[i] [j] = 0 ==&gt;(vi,vj)不是E(G)中的边</li>
</ul>
</li>
</ul>
<h4 id="求顶点的度、出度、入度"><a href="#求顶点的度、出度、入度" class="headerlink" title="求顶点的度、出度、入度"></a>求顶点的度、出度、入度</h4><ul>
<li>无向图<ul>
<li><strong>第i个结点的<font color='red'>度</font> = <font color='red'>第i行(或者第i列)</font>的非零元素个数</strong></li>
</ul>
</li>
<li>有向图<ul>
<li><strong>第i个结点的<font color='red'>出度</font> = <font color='red'>第i行</font>的非零元素个数</strong></li>
<li><strong>第i个结点的<font color='red'>入度</font> = <font color='red'>第i列</font>的非零元素个数</strong></li>
<li><strong>第i个结点的<font color='red'>度</font> = <font color='red'>第i行(或者第i列)</font>的非零元素个数之和</strong></li>
</ul>
</li>
</ul>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxVertexNum 100		<span class="comment">//顶点数目的最大值</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;		<span class="comment">//顶点的数据类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> EdgeType;			<span class="comment">//带权图中边上权值的数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    VertexType Vex[MaxVertexNum];		<span class="comment">//顶点表</span></span><br><span class="line">    EdgeType Edge[MaxVertexNum][MaxVertexNum];		<span class="comment">//邻接矩阵 边表</span></span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;			<span class="comment">//图的当前顶点数和弧数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p><font color='red'>无向图</font>的邻接矩阵一定是一个<font color='orange'>对称矩阵</font>(并且<strong>唯一</strong>)。因此，在实际存储邻接矩阵时，只需要存储上(或下)三角矩阵的元素</p>
</li>
<li><p>对于<font color='red'>无向图</font>，邻接矩阵的第i行(或者第i列)非零元素(或非∞元素)的个数刚好是顶点i的度。</p>
</li>
<li><p>对于<font color='red'>有向图</font>，邻接矩阵的第i行非零元素(或非∞元素)的个数正好是顶点i的出度OD(v)；</p>
<p>第i列非零元素(或非∞元素)的个数正好是顶点i的入度ID(v)；</p>
</li>
<li><p>优点：容易确定任意两点之间是否有边相连</p>
<p>缺点：确定图中有多少边，时间复杂度较高，O(n²)；空间复杂度O(n²)</p>
</li>
<li><p><strong>适合稠密图存储</strong></p>
</li>
<li><p>设图G的邻接矩阵为A，则<strong>A∧n的元素A∧n[i] [j] 表示从由顶点i到顶点j的<font color='orange'>长度为n的路径</font>有<font color='red'>多少条</font></strong></p>
</li>
</ul>
<h3 id="邻接表-顺序-链表存储"><a href="#邻接表-顺序-链表存储" class="headerlink" title="邻接表(顺序+链表存储)"></a>邻接表(顺序+链表存储)</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//用邻接表存储的图</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum;</span><br><span class="line">&#125;ALGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>&#123;</span></span><br><span class="line">    VertexType data;		<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *first;			<span class="comment">//第一条边/弧</span></span><br><span class="line">&#125;VNode,AdjList[MaxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//边、弧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex;				<span class="comment">//边、弧指向向哪一个结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">next</span>;</span>		<span class="comment">//指向下一条弧的指针</span></span><br><span class="line">    <span class="comment">//InfoType info;			//边权值</span></span><br><span class="line">&#125;ArcNode;</span><br></pre></td></tr></table></figure>

<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li><p>若G为<font color='cornflowerblue'>无向图</font>，则所需要的存储空间为 O(|V| + 2|E|)</p>
<p>若G为<font color='cornflowerblue'>有向图</font>，则所需要的存储空间为 O(|V| + |E|)    </p>
</li>
<li><p>适合于<strong>稀疏图</strong></p>
</li>
<li><p>优点：对于给定一顶点，可以快速找到它的所有邻边。</p>
<p>缺点：确定两顶点直接是否存在边，需要扫描整个链表，时间复杂度高</p>
</li>
<li><p>对于<font color='cornflowerblue'>有向图</font>，计算<strong>出度只需要计算邻接表中的结点个数</strong>；</p>
<p>​                        计算<strong>入度需要扫描整个邻接表，效率低</strong></p>
</li>
<li><p>图的邻接表 表示<strong>不唯一</strong></p>
</li>
</ul>
<h3 id="十字链表-存储有向图"><a href="#十字链表-存储有向图" class="headerlink" title="十字链表(存储有向图)"></a>十字链表(存储有向图)</h3><h4 id="结构体定义-1"><a href="#结构体定义-1" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弧结点</span><br><span class="line">    * tailvex		弧尾顶点编号</span><br><span class="line">    * headvex		弧头顶点编号</span><br><span class="line">    * info			权值</span><br><span class="line">    * hlink		弧头相同的下一条弧</span><br><span class="line">    * tlink 		弧尾相同的下一条弧</span><br><span class="line"></span><br><span class="line">顶点结点：用数组顺序存储</span><br><span class="line">    * data		数据域</span><br><span class="line">    * firstin		该顶点作为弧头的第一条弧</span><br><span class="line">    * firstout		该顶点作为弧尾的第一条弧</span><br></pre></td></tr></table></figure>

<p><strong>图的十字链表表示是不唯一的，但一个十字链表表示一个确定的图</strong></p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><ul>
<li>空间复杂度：<strong>O(|V| + |E|)</strong></li>
</ul>
<h3 id="邻接多重表-存储无向图"><a href="#邻接多重表-存储无向图" class="headerlink" title="邻接多重表(存储无向图)"></a>邻接多重表(存储无向图)</h3><h4 id="结构体定义-2"><a href="#结构体定义-2" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">边结点</span><br><span class="line">	ivex	边的一个顶点编号 i</span><br><span class="line">	jvex	边的一个顶点编号 j</span><br><span class="line">	ilink	指向下一条依附于ivex的边</span><br><span class="line">	jlink	指向下一条依附于jvex的边</span><br><span class="line">	info	权值</span><br><span class="line">	</span><br><span class="line">顶点结点</span><br><span class="line">	data	数据域</span><br><span class="line">	firstedge	与该顶点相连的第一条边</span><br></pre></td></tr></table></figure>

<p><strong>图的邻接多重表表示是不唯一的，但一个邻接多重表表示一个确定的图</strong></p>
<h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><ul>
<li>空间复杂度：<strong>O(|V| + |E|)</strong></li>
</ul>
<h2 id="图的基本操作"><a href="#图的基本操作" class="headerlink" title="图的基本操作"></a>图的基本操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Adjacent(G,x,y);	判断图G是否存在边&lt;x,y&gt;或(x,y)</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)~O(|V|)</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)~O(|V|)</span><br><span class="line">Neighbors(G,x);		列出图中G中与结点x邻接的边</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(|V|);</span><br><span class="line">		*邻接表：O(1)~O(|V|)</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(|V|);</span><br><span class="line">		*邻接表：</span><br><span class="line">			出边：O(1)~O(|V|)</span><br><span class="line">			入边：O(|E|)</span><br><span class="line">InsertVertex(G,x);	在图中G插入顶点x</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)</span><br><span class="line">DeleteVertex(G,x);	在图中G删除顶点x</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(|V|);</span><br><span class="line">		*邻接表：O(1)~O(|E|)</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(|V|);</span><br><span class="line">		*邻接表：</span><br><span class="line">			删出边：O(1)~O(|V|)</span><br><span class="line">			删入边：O(|E|)</span><br><span class="line">AddEdge(G,x,y);		若无向边(x,y)或有向边&lt;x,y&gt;不存在时，则向图G中添加该边。</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)---头插法</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：</span><br><span class="line">			增出边：O(1)</span><br><span class="line">			增入边：O(1)</span><br><span class="line">RemoveEdge(G,x,y);	若无向边(x,y)或有向边&lt;x,y&gt;存在时，则向图G中删除该边。</span><br><span class="line">FirstNeighbor(G,x);	求图G中顶点的第一个邻接点，若有则返回顶点好，若x没有邻接点或者图中不存在x，则返回-1</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(1)~O(|V|);</span><br><span class="line">		*邻接表：O(1)</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(1)~O(|V|);</span><br><span class="line">		*邻接表：</span><br><span class="line">			找出边：O(1)</span><br><span class="line">			找入边：O(1)~O(|E|)</span><br><span class="line">NextNeightbor(G,x,y);	假设图G中顶点y是顶点x的第一个邻接点，返回除y外顶点x的下一个邻接点的顶点号，若y是x的最后一个的邻接点，则返回-1</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(1)~O(|V|);</span><br><span class="line">		*邻接表：O(1)</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(1)~O(|V|);</span><br><span class="line">		*邻接表：</span><br><span class="line">			找出边：O(1)</span><br><span class="line">			找入边：O(1)~O(|E|)</span><br><span class="line">Get_edge_value(G,x,y):	获取图G中边&lt;x,y&gt;或(x,y)对应的权值</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)~O(|V|)</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)~O(|V|)</span><br><span class="line">Set_edge_value(G,x,y,v):	设置图G中边&lt;x,y&gt;或(x,y)对应的权值v</span><br><span class="line">	无向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)~O(|V|)</span><br><span class="line">	有向图</span><br><span class="line">		*邻接矩阵：O(1);</span><br><span class="line">		*邻接表：O(1)~O(|V|)</span><br></pre></td></tr></table></figure>



<h2 id="图的遍历算法"><a href="#图的遍历算法" class="headerlink" title="图的遍历算法"></a>图的遍历算法</h2><h3 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历(BFS)"></a>广度优先遍历(BFS)</h3><h4 id="与树的广度优先遍历之间的联系"><a href="#与树的广度优先遍历之间的联系" class="headerlink" title="与树的广度优先遍历之间的联系"></a>与树的广度优先遍历之间的联系</h4><ul>
<li>树的广度优先遍历——<strong>层序遍历</strong></li>
</ul>
<p><strong>树vs图</strong></p>
<ul>
<li>树——<ul>
<li>不存在回路，在搜寻相邻的结点是，不可能搜到重复的结点</li>
<li>层须遍历——依靠队列</li>
</ul>
</li>
<li>图——<ul>
<li>搜索相邻的顶点时，有可能搜到已经访问过的结点了<ul>
<li>对每一个结点进行标记，访问过的结点进行标记，再次授勋时就跳过去</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>同一个图的<font color='red'>邻接矩阵</font>表示方式<font color='red'>唯一</font>，因此广度优先<font color='red'>遍历序列唯一</font></strong></p>
<p><strong>同一个图的<font color='red'>邻接表</font>表示方式<font color='red'>不唯一</font>，因此广度优先<font color='red'>遍历序列不唯一</font></strong></p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	步骤</span></span><br><span class="line"><span class="comment">        1. 找到与一个顶点相邻的所有顶点</span></span><br><span class="line"><span class="comment">           1. FirstNeighbor(G,x);</span></span><br><span class="line"><span class="comment">           2. NextNeightbor(G,x,y);</span></span><br><span class="line"><span class="comment">        2. 标记哪些顶点被访问过</span></span><br><span class="line"><span class="comment">        	bool visited[MAX_VERTEX_NUM];	访问标记数组</span></span><br><span class="line"><span class="comment">        3. 需要一个辅助队列</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];		<span class="comment">//访问标记数组，从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;		<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    visit(v);					<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;			<span class="comment">//对v做已访问标记</span></span><br><span class="line">    EnQueue(Q,v);			<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isQueue(Q))&#123;</span><br><span class="line">        DeQueue(Q,v);			<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G,v); w &gt; <span class="number">0</span>;w = NextNeighbor(Q,v,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;		<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">                visited(w);			<span class="comment">//访问顶点w</span></span><br><span class="line">                visitted[w] = <span class="literal">true</span>;		<span class="comment">//对w做以访问标记</span></span><br><span class="line">                EnQueue(Q,w);		<span class="comment">//对顶点入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ;i &lt;= G.vexnum;++i)	visited[i] = <span class="literal">false</span>;		<span class="comment">//访问标记数组进行初始化</span></span><br><span class="line">    InitQueue(Q);			<span class="comment">//队列初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;++i)		<span class="comment">//从1号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])		<span class="comment">//对每一个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);		<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于无向图，调用BFS函数的次数 = 连通分量数</span></span><br></pre></td></tr></table></figure>



<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>空间复杂度：<strong>辅助队列为O(|V|)</strong></li>
<li>时间复杂度：<ul>
<li>邻接矩阵：<strong>O(|V|²)</strong></li>
<li>邻接表：<strong>O(|V| + |E|)</strong></li>
</ul>
</li>
</ul>
<h4 id="广度优先生成树"><a href="#广度优先生成树" class="headerlink" title="广度优先生成树"></a>广度优先生成树</h4><p>在广度遍历的过程中，我们可以得到一个遍历树，称为<strong>广度优先生成树</strong></p>
<ul>
<li><strong>同一个图的<font color='red'>邻接矩阵</font>表示方式<font color='red'>唯一</font>，因此<font color='red'>广度优先生成树唯一</font></strong></li>
<li><strong>同一个图的<font color='red'>邻接表</font>表示方式<font color='red'>不唯一</font>，因此<font color='red'>广度优先生成树不唯一</font></strong></li>
</ul>
<p><strong>遍历非连通图可以得到广度优先生成森林</strong></p>
<h3 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历(DFS)"></a>深度优先遍历(DFS)</h3><h4 id="与树的深度优先遍历之间的联系"><a href="#与树的深度优先遍历之间的联系" class="headerlink" title="与树的深度优先遍历之间的联系"></a>与树的深度优先遍历之间的联系</h4><ul>
<li>先根遍历</li>
<li>后根遍历</li>
</ul>
<p><strong>图的深度优先遍历相似于先根遍历</strong></p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	步骤</span></span><br><span class="line"><span class="comment">        1. 找到与一个顶点相邻的所有顶点</span></span><br><span class="line"><span class="comment">           1. FirstNeighbor(G,x);</span></span><br><span class="line"><span class="comment">           2. NextNeightbor(G,x,y);</span></span><br><span class="line"><span class="comment">        2. 标记哪些顶点被访问过</span></span><br><span class="line"><span class="comment">        	bool visited[MAX_VERTEX_NUM];	访问标记数组</span></span><br><span class="line"><span class="comment">        3. 需要一个辅助队列</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];		<span class="comment">//访问标记数组，从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;		<span class="comment">//从顶点v出发，深度优先遍历图G</span></span><br><span class="line">   	visit(v);					<span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v] = <span class="literal">true</span>;			<span class="comment">//标记以访问的顶点</span></span><br><span class="line">    <span class="keyword">for</span>(w = FirstNeighbor(G,v); w &gt; <span class="number">0</span> ;w = NextNeighbor(G.v,w))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited(w))&#123;				<span class="comment">//当w是尚未访问的邻接顶点</span></span><br><span class="line">            DFS(G,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理非连通图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ;i &lt;= G.vexnum;++i)	visited[i] = <span class="literal">false</span>;		<span class="comment">//访问标记数组进行初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;++i)		<span class="comment">//从1号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])		<span class="comment">//对每一个连通分量调用一次DFS</span></span><br><span class="line">            DFS(G,i);		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul>
<li>空间复杂度：<strong>O(|V|)</strong></li>
<li>时间复杂度：=访问各个结点所需的时间+探索各条边所需时间<ul>
<li>邻接矩阵：<strong>O(|V|²)</strong></li>
<li>邻接表：<strong>O(|V| + |E|)</strong></li>
</ul>
</li>
</ul>
<h4 id="深度优先生成树"><a href="#深度优先生成树" class="headerlink" title="深度优先生成树"></a>深度优先生成树</h4><p>在深度遍历的过程中，我们可以得到一个遍历树，称为<strong>深度优先生成树</strong></p>
<ul>
<li><strong>同一个图的<font color='red'>邻接矩阵</font>表示方式<font color='red'>唯一</font>，因此<font color='red'>深度优先生成树唯一</font></strong></li>
<li><strong>同一个图的<font color='red'>邻接表</font>表示方式<font color='red'>不唯一</font>，因此<font color='red'>深度优先生成树不唯一</font></strong></li>
</ul>
<h4 id="图的遍历和图的连通性"><a href="#图的遍历和图的连通性" class="headerlink" title="图的遍历和图的连通性"></a>图的遍历和图的连通性</h4><p><strong>无向图</strong></p>
<ul>
<li>DFS/BFS函数调用次数 = 连通分量数</li>
</ul>
<p><strong>有向图</strong></p>
<ul>
<li>若从起始顶点到其他顶点都有路径，则只需调用一次DFS/BFS函数</li>
<li>对于强连通图，从任一顶点出发都只需调用1次DFS/BFS函数</li>
</ul>
<h2 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h2><h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>对于一个<font color='red'>带权<strong>连通</strong>无向图</font>G = (V，E),生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中<font color='red'>边的权值之和最小的生成树</font>，则T称为G的<font color='red'>最小生成树</font>。</p>
<ul>
<li>最小生成树可能有多个，但边的权值之和总是唯一且最小的。</li>
<li>最小生成树的边数 = 顶点数 — 1。减少一条则不连通，增加一条边则会出现回路。</li>
<li>如果一个连通图本身就是一棵树，则其最小生成树就是它本身。</li>
<li>只有连通图才有生成树，非连通图只有生成森林。</li>
</ul>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><h5 id="手算操作"><a href="#手算操作" class="headerlink" title="手算操作"></a>手算操作</h5><p>从某个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止。</p>
<h5 id="时间复杂度："><a href="#时间复杂度：" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p><strong>O(|V|²)，不依赖于|E|,</strong></p>
<p><strong>适合边稠密图</strong></p>
<h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><h5 id="手算操作-1"><a href="#手算操作-1" class="headerlink" title="手算操作"></a>手算操作</h5><p>每次选择一条权值最小的边（可能会出现多个连通分量），使这条边的两头变通（原本<strong>已经连通</strong>的就不选），直到所有结点都连通。</p>
<h5 id="时间复杂度：-1"><a href="#时间复杂度：-1" class="headerlink" title="时间复杂度："></a>时间复杂度：</h5><p><strong>O(|E|㏒|E|)，不依赖于|V|,</strong></p>
<p><strong>适合边稀疏顶点多图</strong></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="单源对段路径"><a href="#单源对段路径" class="headerlink" title="单源对段路径"></a>单源对段路径</h4><h5 id="BFS算法（无权图）"><a href="#BFS算法（无权图）" class="headerlink" title="BFS算法（无权图）"></a>BFS算法（无权图）</h5><h6 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> visited[MAX_VERTEX_NUM];		<span class="comment">//访问标记数组，从1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS_MIN_Distance</span><span class="params">(Graph G,<span class="keyword">int</span> v)</span></span>&#123;		<span class="comment">//从顶点v出发，广度优先遍历图G</span></span><br><span class="line">    <span class="comment">//d[i]表示从u到i结点的最短路径</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;G.vexnum;++i)&#123;</span><br><span class="line">        d[i] = ∞;		<span class="comment">//初始化路径长度</span></span><br><span class="line">        path[i] - <span class="number">-1</span>;		<span class="comment">//最短路径从那个顶点过来，也就上前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    d[v] = <span class="number">0</span>;		<span class="comment">//到达本身的长度为0;</span></span><br><span class="line">    </span><br><span class="line">    visited[v] = <span class="literal">true</span>;			<span class="comment">//对v做已访问标记</span></span><br><span class="line">    EnQueue(Q,v);			<span class="comment">//顶点v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span>(!isQueue(Q))&#123;			<span class="comment">//BFS算法的主过程</span></span><br><span class="line">        DeQueue(Q,v);			<span class="comment">//顶点v出队列</span></span><br><span class="line">        <span class="keyword">for</span>(w = FirstNeighbor(G,v); w &gt; <span class="number">0</span>;w = NextNeighbor(Q,v,w))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[w])&#123;		<span class="comment">//w为v的尚未访问的邻接顶点</span></span><br><span class="line">               	<span class="comment">//visit函数的内容</span></span><br><span class="line">               	d[w] = d[v] +<span class="number">1</span>;		<span class="comment">//路径长度加1</span></span><br><span class="line">                path[w] = w;		<span class="comment">//最短路径从v到w</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                visitted[w] = <span class="literal">true</span>;		<span class="comment">//对w做以访问标记</span></span><br><span class="line">                EnQueue(Q,w);		<span class="comment">//对顶点入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span> ;i &lt;= G.vexnum;++i)	visited[i] = <span class="literal">false</span>;		<span class="comment">//访问标记数组进行初始化</span></span><br><span class="line">    InitQueue(Q);			<span class="comment">//队列初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= G.vexnum;++i)		<span class="comment">//从1号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[i])		<span class="comment">//对每一个连通分量调用一次BFS</span></span><br><span class="line">            BFS(G,i);		<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Dijkstra算法（带权图、无权图）"><a href="#Dijkstra算法（带权图、无权图）" class="headerlink" title="Dijkstra算法（带权图、无权图）"></a>Dijkstra算法（带权图、无权图）</h5><ul>
<li>使用邻接矩阵表示时，时间复杂度：<strong>O(|v|²)</strong></li>
<li><strong>Dijkstra算法并<font color='red'>不</font>适用带负权值的图</strong></li>
<li>算法是基于<strong>贪心策略</strong>的。</li>
</ul>
<h4 id="各顶点之间的最短路径"><a href="#各顶点之间的最短路径" class="headerlink" title="各顶点之间的最短路径"></a>各顶点之间的最短路径</h4><h5 id="Floyd算法-带权图、无权图"><a href="#Floyd算法-带权图、无权图" class="headerlink" title="Floyd算法(带权图、无权图)"></a>Floyd算法(带权图、无权图)</h5><ul>
<li>Floyd算法基于<strong>动态规划</strong>的思想</li>
</ul>
<h6 id="算法文字过程"><a href="#算法文字过程" class="headerlink" title="算法文字过程"></a>算法文字过程</h6><p>将问题的求解分为多个阶段</p>
<p>​    对于n个顶点的图G，求任意一对顶点Vi —&gt; Vj之间的最短路径可分为如下几个阶段</p>
<ul>
<li><p>初始：不允许在其他顶点终端，最短路径是？</p>
</li>
<li><p>0：若允许在V0中转，最短路径是？</p>
</li>
<li><p>1：若允许在V0、V1中转，最短路径是？</p>
</li>
<li><p>2：若允许在V0、V1、V2中转，最短路径是？</p>
<p>…..</p>
</li>
<li><p>n-1：若允许在V0、V1…..V(n-1)中转，最短路径是？</p>
</li>
</ul>
<h6 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	A矩阵表示从Vi——&gt;Vj的最短路径</span></span><br><span class="line"><span class="comment">	path矩阵表示从Vi——&gt;Vj的最短路径需要那个中转点</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="comment">//....准备工作，根据图的信息初始化矩阵 A 和 path</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;			<span class="comment">//考虑以Vk作为中转点</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;		<span class="comment">//遍历整个矩阵，i为行号。j为列号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i][j] &gt; A[i][k] + A[k][j])&#123;		<span class="comment">//以Vk为中转点的路径最短</span></span><br><span class="line">                A[i][j] = A[i][k] + A[k][j];		<span class="comment">//更新最短路径长度</span></span><br><span class="line">                path[i][j] = k;			<span class="comment">//中转点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h6><p><strong>时间复杂度：O(|V|³)</strong></p>
<p><strong>空间复杂度：O(|V|²)</strong></p>
<p><strong>Floyd允许出现图中出现有带负权值的边，但是不允许有包含带负权值的边组成的回路</strong></p>
<h2 id="有向无环图应用"><a href="#有向无环图应用" class="headerlink" title="有向无环图应用"></a>有向无环图应用</h2><h3 id="有向无环图"><a href="#有向无环图" class="headerlink" title="有向无环图"></a>有向无环图</h3><p><strong>定义：</strong>若一个<font color='red'>有向图</font>中<font color='red'>不存在环</font>，则称为有向无环图，简称<font color='red'>DAG图</font></p>
<h3 id="DAG描述表达式"><a href="#DAG描述表达式" class="headerlink" title="DAG描述表达式"></a>DAG描述表达式</h3><p>有向无环图是描述<font color='red'>含有公共子式</font>的表达式的有效工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">	( (a+b) * ( b * ( c + d )) + ( c + d ) * e) * ((c+d) *e)</span><br><span class="line">	用二叉树来表示，在树中存在一些相同的子表达式。</span><br><span class="line">	使用有向无环图，可以将相同子树的父节点指向同一个子树，依次来实现对相同子式的共享，节省存储空间</span><br></pre></td></tr></table></figure>

<h4 id="解题方法"><a href="#解题方法" class="headerlink" title="解题方法"></a>解题方法</h4><p><strong>有向无环图中不存在相同的结点</strong></p>
<p><strong>步骤</strong></p>
<ol>
<li>把各个操作数不重复的排成一排。</li>
<li>标出各个运算符的生效顺序(先后顺序有点出入无所谓)，防止遗漏运算符。</li>
<li>按顺序加入运算符，注意“<strong><font color='red'>分层</font></strong>”。上层的运算需要以下层的运算结果来作为数值。</li>
<li>从底向上逐层检查<strong><font color='red'>同层</font></strong>的运算符是否可以合体（由于操作数各不相同，所以操作数不需要合并，只需要合并运算符）。</li>
</ol>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h4 id="AOV网"><a href="#AOV网" class="headerlink" title="AOV网"></a>AOV网</h4><p><strong>定义(用顶点表示活动的网):</strong><font color='red'>用DAG图(有向无环图)</font>表示一个工程。顶点表示活动，有向边&lt;Vi,Vj&gt;表示活动Vi必须先于活动Vj进行.</p>
<h4 id="拓扑排序定义"><a href="#拓扑排序定义" class="headerlink" title="拓扑排序定义"></a>拓扑排序定义</h4><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p><strong>手算步骤：</strong></p>
<ol>
<li>从AOV网中选择一个没有前驱(<strong><font color='red'>入度为0</font></strong>)的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为起点的有向边。</li>
<li>重复①和②直到当前的<strong><font color='red'>AOV网为空</font></strong>或当<strong><font color='red'>前网中不存在无前驱的顶点为止（说明有回路）</font></strong>。</li>
</ol>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><h4 id="逆拓扑排序"><a href="#逆拓扑排序" class="headerlink" title="逆拓扑排序"></a>逆拓扑排序</h4><p><strong>步骤：</strong></p>
<ol>
<li>从AOV网中选择一个没有后继(<strong><font color='red'>出度为0</font></strong>)的顶点并输出。</li>
<li>从网中删除该顶点和所有以它为终点的有向边。</li>
<li>重复①和②直到当前的<strong><font color='red'>AOV网为空</font></strong>或当<strong><font color='red'>前网中不存在无前驱的顶点为止（说明有回路）</font></strong>。</li>
</ol>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><h3 id="AOE网"><a href="#AOE网" class="headerlink" title="AOE网"></a>AOE网</h3><p><strong>定义：</strong>在带权有向图中，以<strong><font color='red'>顶点表示事件</font></strong>，以<strong><font color='red'>有向边表示活动</font></strong>，以<strong><font color='red'>边上的权值表示完成该活动的开销</font></strong>(如完成活动所需要的时间)，称之为用边表示活动的网络，简称<strong><font color='red'>AOE网</font></strong></p>
<p><strong>AOE网具有以下的两个性质:</strong></p>
<ol>
<li>只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始</li>
<li>只有在进入某顶点的各有向边所表示的活动都已结束时，该顶点所代表的事件才能发生。另外，<strong>有些活动是可以并行进行的</strong>。</li>
</ol>
<p>在AOE网中<strong><font color='red'>仅有一个</font></strong>入度为0的顶点，称为<strong><font color='red'>开始顶点（源点）</font></strong>，它表示整个工程的开始；</p>
<p>也<strong><font color='red'>仅有一个</font></strong>出度为0的顶点，称为<strong><font color='red'>结束顶点（汇点）</font></strong>，它表示整个工程的结束。</p>
<h3 id="关键路径概念"><a href="#关键路径概念" class="headerlink" title="关键路径概念"></a>关键路径概念</h3><p><strong>定义：</strong>从源点到汇点的有向路径可能有多条，所有路径中，具有最大路径长度的路径称为<font color='red'>关键路径</font>，而把关键路径上的活动称为<font color='red'>关键活动</font>。</p>
<p>完成整个工程的最短时间就是关键路径的长度；若关键活动不能按时完成，则整个工程的完成事件就会延长</p>
<p><strong>概念</strong></p>
<ul>
<li><p><font color='orange'>事件Vk的<strong>最早发生</strong>时间Ve(k) </font>——决定了所有从Vk开始的活动能够开工的最早时间。</p>
</li>
<li><p><font color='red'>活动ai的最早开始时间e(i) </font>——指该活动弧的起点所表示的事件的最早发生时间。</p>
</li>
<li><p><font color='orange'>事件Vk的<strong>最迟发生</strong>时间Vl(k)</font>——它是指在不推迟整个工程完成的前提下，该事件最迟必须发生的时间。</p>
</li>
<li><p><font color='red'>活动ai的<strong>最迟开始</strong>时间l(i) </font>——指该活动弧的终点点所表示的事件的最迟发生时间与该活动所需时间之差。</p>
</li>
<li><p><font color='red'>活动ai的<strong>时间余量d(i) = l(i) - e(i)</strong></font>,表示在不增加完成整个工程所需总时间的情况下，活动ai可以拖延的时间</p>
<p>若一个活动的时间余量为<strong>零</strong>，则说明该活动必须要如期完成，d(i) = 0或 l(i) = e(i) 的活动ai是<strong><font color='red'>关键活动</font></strong>。</p>
<p>由<strong><font color='red'>关键活动</font></strong>组成的路径叫做<strong><font color='red'>关键路径</font></strong></p>
</li>
</ul>
<h3 id="求关键路径的步骤"><a href="#求关键路径的步骤" class="headerlink" title="求关键路径的步骤"></a>求关键路径的步骤</h3><ol>
<li><p>求所有事件的最早发生事件ve();</p>
<p>按<strong><font color='red'>拓扑排序</font></strong>序列，依次求各个顶点的Ve(k)：</p>
<p>​    Ve(源点) = 0；</p>
<p>​    Ve(k) = Max{Ve(j) + Weight(Vj , Vk)}，Vj为Vk的任意前驱，Weight(Vj , Vk)表示从&lt;Vj , Vk&gt;的权值</p>
</li>
<li><p>求所有事件的最迟发生事件Vl();</p>
<p>按<strong><font color='red'>逆拓扑排序</font></strong>序列,依次求各个顶点的Vl(k):</p>
<p>​    Vl(汇点) = Ve(汇点)；</p>
<p>​    Vl(k) = Min{ Vl( j ) - Weight(Vj,Vk)} ，Vj为Vk的任意后继。</p>
</li>
<li><p>求所有活动的最早发生事件e();</p>
<p>e(i) = Ve(k);</p>
</li>
<li><p>求所有活动的最迟发生时间 l();</p>
<p>l(i) = Vl( i ) - Weight(Vk,Vj);</p>
</li>
<li><p>求所有活动的时间余量d();——<strong><font color='red'>d(i) = 0的活动就是关键路径，由关键活动可得到关键路径</font></strong>.</p>
<p>d( i ) = e( i ) - l( i );</p>
</li>
</ol>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>若关键活动耗时增加，则整个工程的工期将增长。</li>
<li>缩短关键活动的时间，可以缩短整个工程的工期。</li>
<li>当缩短到一定程度时，关键活动可能会变成非关键活动。</li>
<li>可能由多条关键路径，只提高一条关键路径上的关键活动并不能缩短整个工程的工期，只有<strong>加快那些包括在所有关键路径上的关键活动</strong>才能达到缩短工期的目的。</li>
</ul>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>二分</title>
    <url>/posts/9947c71c/</url>
    <content><![CDATA[<blockquote>
<p><strong>单调性的题目一定可以二分，可以的二分的题目不一定由单调性</strong></p>
<p>二分一定是有解的，如果出现无解的情况，一定是题目的问题，而不是模板的问题</p>
</blockquote>
<h3 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h3><p>思想：整个区间可以一分为二，一边区间都满足某一条件，另一区间都不满足某一条件，而新边界的选择</p>
<ul>
<li><font color='red'>新的边界可以设置为不满足条件区间的最大值（1）</font></li>
<li><font color='cornflowerblue'>新的边界设置设置为满足条件区间的最小值（2）</font></li>
</ul>
<p>两种情况对应两种不同的模板。</p>
<p><strong>模板的选择主要看check函数中ture&amp;false区间的划分，如果l=mid，就选择第一个模板，如果r=mid，就选择第二个模板</strong></p>
<h4 id="第一种模拟模板"><a href="#第一种模拟模板" class="headerlink" title="第一种模拟模板"></a><font color='red'>第一种模拟模板</font></h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol>
<li>mid = （l+r<strong>+1</strong>）/2</li>
<li>if(check(mid))<ol>
<li>true —&gt;[mid,r]</li>
<li>false –&gt;[l,mid-1]</li>
</ol>
</li>
</ol>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里为什么要mid算式中要加一</span><br><span class="line">例子：</span><br><span class="line">如果 </span><br><span class="line">	l&#x3D;r-1</span><br><span class="line">	初始化区间[l,r]</span><br><span class="line">	mid &#x3D; l</span><br><span class="line">	check(mid) ---&gt;true ---&gt; [l.r] ---&gt;死循环！！！</span><br></pre></td></tr></table></figure>

<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="第二种模拟模板"><a href="#第二种模拟模板" class="headerlink" title="第二种模拟模板"></a><strong><font color='cornflowerblue'>第二种模拟模板</font></strong></h4><h5 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a><strong>步骤</strong></h5><ol>
<li>mid = （l+r）/2</li>
<li>if(check(mid))<ol>
<li>true —&gt;[l,mid]</li>
<li>false –&gt;[mid+1,r]</li>
</ol>
</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;    <span class="comment">// check()判断mid是否满足性质</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="数的范围"><a href="#数的范围" class="headerlink" title="数的范围"></a><strong>数的范围</strong></h5><blockquote>
<p>给定一个按照升序排列的长度为 nn 的整数数组，以及 qq 个查询。</p>
<p>对于每个查询，返回一个元素 kk 的起始位置和终止位置（位置从 00 开始计数）。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 nn 和 qq，表示数组长度和询问个数。</p>
<p>第二行包含 nn 个整数（均在 1∼100001∼10000 范围内），表示完整数组。</p>
<p>接下来 qq 行，每行包含一个整数 kk，表示一个询问元素。</p>
<p><strong>输出格式</strong></p>
<p>共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤1000001≤n≤100000<br>1≤q≤100001≤q≤10000<br>1≤k≤100001≤k≤10000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;6 3</span><br><span class="line">&gt;1 2 2 3 3 4</span><br><span class="line">&gt;3</span><br><span class="line">&gt;4</span><br><span class="line">&gt;5</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;3 4</span><br><span class="line">&gt;5 5</span><br><span class="line">&gt;-1 -1</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>答案</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> n,m,num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l,r,mid;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;num);</span><br><span class="line">        l = <span class="number">0</span>,r = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= num) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l] != num) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1 -1\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,l);</span><br><span class="line">            l = mid,r = n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                mid = l+r+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= num) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d \n"</span>,l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h3><p>由于浮点数二分不存在边界问题，所以代码实现简单</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><h5 id="数的三次方根"><a href="#数的三次方根" class="headerlink" title="数的三次方根"></a>数的三次方根</h5><blockquote>
<p>给定一个浮点数 nn，求它的三次方根。</p>
<p><strong>输入格式</strong></p>
<p>共一行，包含一个浮点数 nn。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含一个浮点数，表示问题的解。</p>
<p>注意，结果保留 66 位小数。</p>
<p><strong>数据范围</strong></p>
<p>−10000≤n≤10000−10000≤n≤10000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;1000.00</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;10.000000</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>答案</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cube_root</span><span class="params">(<span class="keyword">double</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> l,r;</span><br><span class="line">    <span class="keyword">if</span>(num &gt;= <span class="number">1</span>)</span><br><span class="line">        l = <span class="number">0</span>,r = num;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//当num&lt;1时，我们要的答案就在num~1之间，而不是0~num</span></span><br><span class="line">        l = num,r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( r-l &gt; <span class="number">1e-8</span>)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( mid*mid*mid &gt; num) r =mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> num,result;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;num);</span><br><span class="line">    <span class="comment">//保证进入到cube_root的值非负数</span></span><br><span class="line">    <span class="keyword">if</span>(num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        result = cube_root(num);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf"</span>,result);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        result = cube_root(num * <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf"</span>,result*<span class="number">-1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-笔记 -算法</tag>
      </tags>
  </entry>
  <entry>
    <title>查找算法</title>
    <url>/posts/aad2137f/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul>
<li><font color='red'>查找</font>——在数据集合中寻早曼珠某种条件的数据元素的过程称为查找</li>
<li><font color='red'>查找表</font>(查找结构) —— 用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录)组成</li>
<li><font color='red'>关键字</font>——数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果因该是<strong>唯一</strong>的。</li>
</ul>
<h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><ul>
<li>查找符合条件的数据元素<ul>
<li><strong>静态查找表</strong><ul>
<li>仅仅关注查找速度即可</li>
</ul>
</li>
<li>查找表不会发生改变</li>
</ul>
</li>
<li>插入、删除某个数据元素<ul>
<li><strong>动态查找表</strong><ul>
<li>关注查找速度</li>
<li>关注删除、增加操作是否方便</li>
</ul>
</li>
<li>查找表会发生改变</li>
</ul>
</li>
</ul>
<h3 id="查找算法的评价指标"><a href="#查找算法的评价指标" class="headerlink" title="查找算法的评价指标"></a>查找算法的评价指标</h3><ul>
<li><strong>查找长度：</strong>——在查找运算中，需要对比关键字的次数称为查找长度</li>
<li><strong>平均查找长度（ASL）：</strong>——所有查找过程中进行关键字的比较次数的平均值</li>
</ul>
<p><strong>评价一个查找算法的效率时，通常考虑查找成功、查找失败两种情况的ASL。</strong></p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>定义：又名”线性查找“，通常用于<strong>线性表</strong></p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>遍历</strong></p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>					<span class="comment">//查找表的数据结构(顺序表)</span></span><br><span class="line">    ElemType *elem;				<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="keyword">int</span> TableLen;				<span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找（普通模式）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable st,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; st.TableLen ; ++i)&#123;</span><br><span class="line">        <span class="comment">//查找成功则返回元素下标</span></span><br><span class="line">        <span class="keyword">if</span>(St.elem[i] == key)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查找失败，返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序查找（哨兵模式）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Search_Seq</span><span class="params">(SSTable st,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数组的元素从1开始</span></span><br><span class="line">    <span class="keyword">int</span> st.elem[<span class="number">0</span>] = key;		<span class="comment">//哨兵</span></span><br><span class="line">    <span class="comment">//若数组中存在key则返回其下标，由于elem[0] = key，不存在则返回0；</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = TableLen;st.elem[i] != key ; --i);	</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优点：无需判断是否越界，效率更高</span></span><br></pre></td></tr></table></figure>

<h4 id="查找效率分析"><a href="#查找效率分析" class="headerlink" title="查找效率分析"></a>查找效率分析</h4><ul>
<li><p>ASL(成功) = （n+1）/ 2</p>
</li>
<li><p>ASL(失败) =    n+1</p>
</li>
</ul>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><h4 id="有序表的优化"><a href="#有序表的优化" class="headerlink" title="有序表的优化"></a>有序表的优化</h4><p>当发现数已经大于本身时，可以判定查找失败。</p>
<h5 id="用查找判定树分析ASL"><a href="#用查找判定树分析ASL" class="headerlink" title="用查找判定树分析ASL"></a>用查找判定树分析ASL</h5><ul>
<li>一个成功结点的查找长度 = 自身所在层数</li>
<li>一个失败结点的查找长度 = 其父节点所在层数</li>
<li>默认情况下，各种失败情况或者成功情况都等概率发生</li>
</ul>
<h4 id="被查概率不相等"><a href="#被查概率不相等" class="headerlink" title="被查概率不相等"></a>被查概率不相等</h4><p><strong>被查找概率打的放在靠前位置</strong></p>
<ul>
<li>提高查找成功的ASL</li>
<li>降低了查找失败的ASL</li>
</ul>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>适用于<strong>有序</strong>的<strong>顺序表</strong><ul>
<li>有序——为了判断目标值是在哪个区间</li>
<li>顺序表——为了随机访问</li>
</ul>
</li>
</ul>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>					<span class="comment">//查找表的数据结构(顺序表)</span></span><br><span class="line">    ElemType *elem;				<span class="comment">//动态数组基址</span></span><br><span class="line">    <span class="keyword">int</span> TableLen;				<span class="comment">//表的长度</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Binary_Search</span><span class="params">(SSTable L,ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>,high = L.TableLen - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;		<span class="comment">//取中间位置</span></span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;				<span class="comment">//查找成功则返回所在位置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid] &gt; key)</span><br><span class="line">            high = mid - <span class="number">1</span>;			<span class="comment">//从前半部分继续查找</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;			<span class="comment">//从后半部分继续查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;					<span class="comment">//查找失败，返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找判定树"><a href="#查找判定树" class="headerlink" title="查找判定树"></a>查找判定树</h3><h4 id="构造（-mid-low-high-2）"><a href="#构造（-mid-low-high-2）" class="headerlink" title="构造（ mid = (low + high) / 2）"></a>构造（ mid = (low + high) / 2）</h4><ul>
<li>如果当前low和high之间由<strong><font color='red'>奇数个</font></strong>元素，则mid分隔后，<strong><font color='red'>左右两部分元素个数相等</font></strong></li>
<li>如果当前low和high之间有<strong><font color='red'>偶数个</font></strong>元素，则mid分隔后，<strong><font color='red'>左半部分比右半部分少一个元素</font></strong></li>
</ul>
<p>折半查找的判定树中，若mid = { (low + high) / 2}(向下取整),则对于任何一个结点，必有：<strong><font color='red'>右子树结点数 — 左子树结点数 = 0或1</font></strong></p>
<ul>
<li><p>折半查找的判定树<strong><font color='red'>一定是平衡二叉树</font></strong></p>
</li>
<li><p>折半查找的判定树中，<strong><font color='red'>只有最下面一层是不满的</font></strong></p>
<p>因此，元素个数为n时<strong><font color='red'>树高h = { ㏒( n + 1)}(向上取整)</font></strong></p>
</li>
</ul>
<p><strong>注意：</strong>在折半查找判定树中的方形结点是虚构的，它并不计入比较的次数中</p>
<h3 id="折半查找效率"><a href="#折半查找效率" class="headerlink" title="折半查找效率"></a>折半查找效率</h3><p><strong>时间复杂度：O(㏒n)</strong></p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>特点：块内无序，块间有序</li>
<li>索引表中保存每个分块的最大关键字和分块存储区间</li>
</ul>
<p><strong><font color='red'>分块查找</font></strong>，又称<strong><font color='red'>索引顺序查找</font></strong>，算法过程如下：</p>
<ol>
<li>在索引表中确定带查找记录所属分块(可顺序，可折半)</li>
<li>在块内顺序查找</li>
</ol>
<p>若索引表中不包含目标关键字，则折半查找索引表最终停在low&gt;high,要<strong><font color='red'>在low所指分块中查找</font></strong></p>
<ul>
<li>low&gt;high退一步——》low == high == mid<ul>
<li>elem[mid] &gt; key ====&gt; high = mid -1; (也就是low = mid &gt; high)</li>
<li>elem[mid] &lt; key ====&gt; low = mid +1;( 也就是low = mid +1 &gt; mid = high)</li>
</ul>
</li>
</ul>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//索引表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType MaxValue;		<span class="comment">//块内最大值	</span></span><br><span class="line">    <span class="keyword">int</span> low,high;			<span class="comment">//块区间的头尾下标</span></span><br><span class="line">&#125;Index;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表存储实际元素</span></span><br><span class="line">ElemType List[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>



<h3 id="查找效率分析ASL"><a href="#查找效率分析ASL" class="headerlink" title="查找效率分析ASL"></a>查找效率分析ASL</h3><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="5叉查找树"><a href="#5叉查找树" class="headerlink" title="5叉查找树"></a>5叉查找树</h3><p><strong>结点定义</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5叉排序树的结点定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    ElemType keys[<span class="number">4</span>];			<span class="comment">//最多4个关键字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">child</span>[5];</span>			<span class="comment">//最多五个孩子</span></span><br><span class="line">    <span class="keyword">int</span> num;			<span class="comment">//结点中有几个关键字</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>结点最少一个关键字，2个分叉</p>
<p>最多4个关键字，5个分叉</p>
<p>结点内关键字有序</p>
</li>
</ul>
<h3 id="B树基本概念"><a href="#B树基本概念" class="headerlink" title="B树基本概念"></a>B树基本概念</h3><p><strong>定义：</strong><font color='red'>B树</font>，又称<font color='red'>多路平衡(所有子树的高度都要相同)查找树</font>，B树中所有结点的<font color='red'>孩子个数的最大值称为B树的阶</font>，通常用m表示。一颗<font color='red'>m阶B树</font>或为空树，或为满足如下特性的m叉树：</p>
<ol>
<li>树中每个结点至多有m棵子树，即至多含有m-1个关键字</li>
<li>若根结点不是终端结点，则至少有两棵子树</li>
<li><font color='red'>除根结点外</font>的所有非叶节点至少有<font color='red'>{m / 2}(向上取整) 棵子树</font>，即至少含有 <font color='red'>{ m / 2 }(向上取整) - 1个关键字</font>。</li>
<li>所有的<font color='cornflowerblue'>叶结点</font>都出现在同一层次上，并且不带有信息(可以视为外部节点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空)</li>
</ol>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><strong>核心要求：</strong></p>
<ol>
<li>对m阶B树——除根结点外，结点关键字数<font color='red'>⌈m / 2⌉ — 1 ≤ n ≤ m - 1</font></li>
<li>子树0 &lt; 关键字1 &lt; 子树1 &lt; 关键字2 &lt; …</li>
</ol>
<p><strong>插入过程：</strong></p>
<ul>
<li>新元素一定是插入到最底层”终端节点”，用<strong>“查找”来确定插入位置</strong></li>
<li>在插入key后，若导致原结点关键字超过上限，则从中间位置( <font color='red'>⌈m / 2⌉</font> )将其中的关键字<font color='red'>分为两部分</font>，左部分包含的关键放在原结点，右部分包含的关键字放在新结点中，中间位置( <font color='red'>⌈m / 2⌉</font> )的结点插入原结点的父节点。==分裂操作</li>
<li>若此时导致<font color='red'>其父结点的关键字</font>个数也<font color='red'>超过</font>了<font color='red'>上限</font>，则<font color='red'>继续</font>进行这种<font color='red'>分裂</font>操作，直至这个过程传到根结点为止，<font color='red'>进而导致B树高度增1</font></li>
</ul>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>删除非终端结点：</strong></p>
<p>若被删除关键字在<font color='red'>非终端结点</font>，则用<font color='red'>直接前驱或直接后继来替代被删除的关键字</font>；</p>
<ul>
<li><font color='red'>直接前驱</font>：当前关键字<font color='red'>左侧指针所指子树中“最右下”的元素</font></li>
<li><font color='red'>直接后继</font>：当前关键字<font color='red'>右侧指针所指子树中“最左下”的元素</font></li>
</ul>
<p><strong><font color='red'>对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作</font></strong></p>
<p><strong>删除终端结点</strong>：</p>
<ul>
<li><p>若删除终端结点的某一关键字后，关键字数量没有低于下限，则直接删除，否则</p>
</li>
<li><p><font color='red'>兄弟够借</font>。若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左）兄弟结点的关键字个数该很充裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点(父子换位法)</p>
</li>
<li><p><font color='red'>兄弟不够借</font>。若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均为 ⌈m / 2⌉—1，则将关键字删除后<font color='red'>与左(或右)兄弟结点</font>及<font color='red'>双亲结点中的关键字</font>进行合并。</p>
<p>在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0（根结点关键字个数为1时，有两颗子树），则直接将根结点删除，合并后的新结点为根；若双亲结点不是根结点，且关键字个数减少到⌈m / 2⌉—2，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。</p>
</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p><strong>定义：</strong>一棵m阶的B+树需满足下列条件：</p>
<ol>
<li>每个分支结点最多有m棵子树</li>
<li><font color='red'>非叶根点至少有两棵子树</font>，其余每个分支结点至少有⌈m / 2⌉ 棵子树。</li>
<li><font color='red'>结点的子树个数与关键字个数相等</font>。</li>
<li>所有<font color='red'>叶结点包含全部关键字及指向相应记录的指针</font>，叶结点中将关键字按大小顺序排列，并且<font color='red'>相邻叶结点按大小顺序相互连接起来</font>.</li>
<li>所有分支结点(可视为索引的索引)中<font color='red'>仅</font>包含<font color='red'>它的各个子结点(即下一级的索引块)中关键字的最大值</font>及<font color='red'>指向其子节点的指针</font>。</li>
</ol>
<p><strong>B+树，在查找过程中，非叶结点上的关键字值等于给定值时并不终止，而是继续向下查找，直到叶结点上的关键字为止。所以<font color='red'>在B+树上查找时，无论查找成功与否，每次查找都是一条从根结点到叶结点的路径</font></strong>。</p>
<h3 id="B树与B-树的差异"><a href="#B树与B-树的差异" class="headerlink" title="B树与B+树的差异"></a>B树与B+树的差异</h3><ul>
<li><p>子树个数</p>
<ul>
<li>在B+树中，具有n个关键字的结点只<font color='red'>含有<strong>n</strong>棵子树</font>，即每个关键字对应一颗子树</li>
<li>在B树中，具有n个关键字的结点<font color='red'>含有<strong>n+1</strong>棵子树</font>。</li>
</ul>
</li>
<li><p>关键字个数</p>
<ul>
<li>在B+树中，每个结点(非根内部结点)的关键字个数n的范围是<font color='red'>⌈m / 2⌉  ≤ n ≤ m</font>(根结点：1 ≤ n ≤ m)；</li>
<li>在B树中，每个结点(非根内部结点)的关键字个数n的范围是<font color='red'>⌈m / 2⌉  ≤ n ≤ m-1</font>(根结点：1 ≤ n ≤ m-1)；</li>
</ul>
</li>
<li><p>叶结点与非叶结点包含的信息</p>
<ul>
<li>在B+树中，<font color='red'>叶结点包含信息，所有非叶节点仅其索引作用</font>，非叶结点的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。</li>
</ul>
</li>
<li><p>在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中,<font color='red'>重复的</font></p>
<p>在B树中，叶结点(最外层内部结点)包含的关键字和其他结点包含的关键字是<font color='red'>不重复的</font>.</p>
</li>
</ul>
<h2 id="散列查找"><a href="#散列查找" class="headerlink" title="散列查找"></a>散列查找</h2><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p><strong>定义：</strong>又称<font color='red'>哈希表</font>，是一种数据结构，特点是：数据元素的<font color='red'>关键字</font>与其<font color='red'>存储地址直接相关</font>.</p>
<ul>
<li>通过<font color='red'>“散列函数(哈希函数)</font>：Addr = H(key)”来建立关键字与存储地址的联系</li>
</ul>
<p><strong>术语</strong></p>
<ul>
<li><font color='red'>同义词</font>：不同的关键字通过散列函数映射到同一个值</li>
<li><font color='red'>冲突</font>：通过散列函数确定的为止已经存放了其他元素</li>
<li><strong><font color='red'>装填因子α  =  表中记录数 / 散列表长度</font></strong><ul>
<li>装填因子会直接影响散列表的查找效率</li>
</ul>
</li>
</ul>
<h3 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a><strong>处理冲突的方法</strong></h3><h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h4><ul>
<li>把所有“同义词”存储到一个链表中。</li>
</ul>
<h4 id="开发定址法"><a href="#开发定址法" class="headerlink" title="开发定址法"></a>开发定址法</h4><p><strong>定义</strong>：指可存放心表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放，</p>
<p><strong>数学递推公式： H(i) = ( H(key) + d( i )) % m</strong></p>
<ul>
<li>m表示散列表的表长</li>
<li>d(i) 为增量序列</li>
<li>i 表示第i次发生冲突</li>
</ul>
<p><strong>增量序列的取定</strong></p>
<ul>
<li><p>线性探测法</p>
<ul>
<li><p>d(i) = 0，1，2，3，4… m-1；即发生冲突时，每次往后探测相邻的下一个单元是否为空。</p>
</li>
<li><p>缺点：这种方法会造成<font color='red'>同义词、非同义词在相邻的散列地址上“聚集</font>”起来，大大降低查找效率。</p>
<p><strong><font color='red'>越早遇到空位置，就可以越早确定查找失败，提高效率</font></strong></p>
</li>
</ul>
</li>
<li><p>平方探测法</p>
<ul>
<li>d(i) = 0²，1²，-1²，2²，-2²，3²，-3²，4²,-4²… k², -k²；(k ≤ m/2)</li>
<li><strong>m必须是一个可以表示称<font color='red'> 4j + 3的素数</font>{7,11…..}，才能探测到所有的为止</strong></li>
</ul>
</li>
<li><p>伪随机序列法</p>
<ul>
<li>d(i)是一个伪随机序列，如d(i) = 0,1,4,7,12…</li>
</ul>
</li>
</ul>
<p><strong>开放地址法在删除结点时，不能简单的将被删除的空间置为空，否则将<font color='red'>截断在它之后填入散列表的同义词结点的查找路径</font>，可以<font color='red'>做一个”删除标记”，进行逻辑删除</font>。</strong></p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><ul>
<li>除留余数法——H(key)  =  key % p<ul>
<li>散列表长度为m，取一个不大于但最接近或等于m的<font color='red'>质数</font>p<ul>
<li>质数取模，分布跟均匀，冲突更少</li>
</ul>
</li>
</ul>
</li>
<li>直接定址法——H(key)  = key 或 H(key) = a * key + b<ul>
<li>a和b是常数。这种方法计算最简单，且<strong><font color='red'>不会产生冲突</font></strong>，<font color='red'>它适合关键字的分布基本连续的情况</font>，若关键字分布不连续，空位较多，则会造成存储空间的浪费.</li>
</ul>
</li>
<li>数字分析法——选取数码分布较为均匀的若干位作为散列地址。<ul>
<li><strong><font color='red'>适合已知的关键字集合。</font></strong></li>
<li>设关键字是r进制数，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某集中数码经常出现，此时应该<font color='red'>选取数码分布较为均匀的若干位作为散列地址</font>。</li>
</ul>
</li>
<li>平方取中法——去关键字的平方值的中间几位作为散列地址。<ul>
<li>这种方法取关键字的平方值的中间极为作为散列地址</li>
<li><font color='red'>得到的散列地址与关键字的每位都有关系</font></li>
</ul>
</li>
</ul>
<p><strong>散列查找是典型“<font color='red'>用空间换时间</font>”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率就越低</strong></p>
]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>排序</title>
    <url>/posts/a444b428/</url>
    <content><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="主要思想-分治"><a href="#主要思想-分治" class="headerlink" title="主要思想:分治"></a>主要思想:分治</h4><p><strong>特点</strong></p>
<ul>
<li>是不稳定的</li>
<li><strong>时间复杂度：nlogn</strong></li>
</ul>
<p><strong>实现步骤：</strong></p>
<ol>
<li>确定分界点x，x可以取以下四类值<ol>
<li>q[l]</li>
<li>q[(l+r)/2]</li>
<li>q[r]</li>
<li>随机</li>
</ol>
</li>
<li><strong>调整区间</strong>：第一个区间的数都小于等于x，第二个区间的数都大于等于x；</li>
<li>递归处理左右两个区间</li>
</ol>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断边界，当数组内没有值或者只有一个值时，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//分界点：x取中间值,保证不能取到q[r]</span></span><br><span class="line">    x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//i，j取两侧值，当指针调整的时候，方便循环</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i指针往后移动，找到数组中大于x的值，停止</span></span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="comment">//找到数组中小于x的值，停止</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="comment">//如果两个指针还没有相遇，就交换值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归处理左右两端</span></span><br><span class="line">    </span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    quick_sort(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断边界，当数组内没有值或者只有一个值时，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//分界点：x取中间值，这里需要向上取整，否则会出现死循环</span></span><br><span class="line">     x = q[l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>];<span class="comment">//或者x = q[r];</span></span><br><span class="line">    <span class="comment">//i，j取两侧值，当指针调整的时候，方便循环</span></span><br><span class="line">    <span class="keyword">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i指针往后移动，找到数组中大于x的值，停止</span></span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="comment">//找到数组中小于x的值，停止</span></span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="comment">//如果两个指针还没有相遇，就交换值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归处理左右两端</span></span><br><span class="line">    </span><br><span class="line">    quick_sort(q, l, i<span class="number">-1</span>);</span><br><span class="line">    quick_sort(q, i, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	例如q【1，2】</span></span><br><span class="line"><span class="comment">	x=1，</span></span><br><span class="line"><span class="comment">	初始：quick_sort(q, 0,1);</span></span><br><span class="line"><span class="comment">	第一步： q[i] = 1，q[j]=2;这里q[i]&lt;x,i不移动，q[j]&gt;x,j向左移动一位</span></span><br><span class="line"><span class="comment">	（i=0，j=0）</span></span><br><span class="line"><span class="comment">	左边：quick_sort(q, 0, -1);结束</span></span><br><span class="line"><span class="comment">	右边：quick_sort(q, 0,1);死循环</span></span><br><span class="line"><span class="comment">	第二步：</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>给定一个长度为 nn 的整数数列，以及一个整数 kk，请用快速选择算法求出数列从小到大排序后的第 kk 个数。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含两个整数 nn 和 kk。</p>
<p>第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整数数列。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示数列的第 kk 小数。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤1000001≤n≤100000,<br>1≤k≤n1≤k≤n</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;5 3</span><br><span class="line">&gt;2 4 1 5 3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;3</span><br></pre></td></tr></table></figure>

<p><strong>答案</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">int</span> n,k;</span><br><span class="line">&gt;<span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[],<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> i = l<span class="number">-1</span>,j = r + <span class="number">1</span>,num = q[(l+r)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">       <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; num);</span><br><span class="line">       <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; num);</span><br><span class="line">       <span class="keyword">if</span>(i&lt;j) swap(q[i],q[j]);</span><br><span class="line">   &#125;</span><br><span class="line">   quick_sort(q,l,j),quick_sort(q,j+<span class="number">1</span>,r);</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;k);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;q[i]);</span><br><span class="line">   quick_sort(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d"</span>,q[k<span class="number">-1</span>]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="主要思想：分治"><a href="#主要思想：分治" class="headerlink" title="主要思想：分治"></a>主要思想：分治</h4><p><strong>特点</strong>：</p>
<ul>
<li>稳定的</li>
<li><strong>时间复杂度：nlogn</strong></li>
</ul>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>确定分界点，mid = （l+r）/ 2</li>
<li>递归排序left，right</li>
<li><strong>归并—-合二为一</strong><ol>
<li>两个数组都是排好序的</li>
<li>两个指针指向左右两数组的第一个值，两值进行比较，小的值填入新数组的第一个值同时该指针往后移动（当两值相等时，往往把第一数组的值放在新数组中）</li>
<li>两值继续进行比较，小的值填入新数组的第二个值同时该指针往后移动，递归</li>
<li>直到某一个数组结束，另一个数组还没有结束，我们把这个数组余下的值继续填入。</li>
</ol>
</li>
</ol>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断边界，当数组内没有值或者只有一个值时，直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//确定中点</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//递归排序</span></span><br><span class="line">    merge_sort(q, l, mid);</span><br><span class="line">    merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line">	<span class="comment">// tmp--》辅助数组</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">        <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">	<span class="comment">//将剩余值填入</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">	<span class="comment">//将辅助数组的数复制到原数组中</span></span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><blockquote>
<p>给定一个长度为 nn 的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 ii 个和第 jj 个元素，如果满足 i&lt;ji&lt;j 且 a[i]&gt;a[j]a[i]&gt;a[j]，则其为一个逆序对；否则不是。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含整数 nn，表示数列的长度。</p>
<p>第二行包含 nn 个整数，表示整个数列。</p>
<p><strong>输出格式</strong></p>
<p>输出一个整数，表示逆序对的个数。</p>
<p><strong>数据范围</strong></p>
<p>1≤n≤1000001≤n≤100000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;6</span><br><span class="line">&gt;2 3 4 5 6 1</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;5</span><br></pre></td></tr></table></figure>



<p><strong><font color='red'>答案</font></strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">&gt;<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">&gt;<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line">&gt;<span class="keyword">int</span> arr[N];</span><br><span class="line">&gt;<span class="keyword">int</span> temp[N];</span><br><span class="line">&gt;<span class="keyword">int</span> n;</span><br><span class="line">&gt;<span class="keyword">unsigned</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">&gt;</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">   <span class="keyword">int</span> mid = ( l + r  ) / <span class="number">2</span>;</span><br><span class="line">   merge_sort(arr, l, mid);</span><br><span class="line">   merge_sort(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">int</span> k=<span class="number">0</span>,i=l,j=mid+<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(arr[i] &lt;= arr[j])</span><br><span class="line">       &#123;</span><br><span class="line">           temp[k++] = arr[i++];</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           temp[k++] = arr[j++];</span><br><span class="line">           num += (mid - i + <span class="number">1</span>);<span class="comment">//注意这里，是直接加的，后面的不需要比较了。</span></span><br><span class="line">       &#125; </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">while</span> ( i &lt;= mid )</span><br><span class="line">   &#123;</span><br><span class="line">       temp[k++] = arr[i++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> ( j &lt;= r )</span><br><span class="line">   &#123;</span><br><span class="line">       temp[k++] = arr[j++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++)</span><br><span class="line">   &#123;</span><br><span class="line">       arr[i] = temp[j];</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   merge_sort(arr, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%ld"</span>,num);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-笔记 -算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/posts/735e5788/</url>
    <content><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>每次将一个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，直到全部记录插入完成</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(ElemType A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="comment">//依次将2~N的数据插入到前面已排序序列（数据下标从1开始，同时A[1]是已经排序完成的）</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; j &lt;= n; i++)&#123;		</span><br><span class="line">        <span class="keyword">if</span>(A[i] &lt; A[i<span class="number">-1</span>])&#123;		<span class="comment">//若A[i]关键字小于其前驱（前面排序序列的最大值），就将A[i]插入有序表</span></span><br><span class="line">            A[<span class="number">0</span>] = A[i];		<span class="comment">//复制为哨兵，A[0]充当哨兵</span></span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">1</span>; A[<span class="number">0</span>] &lt; A[j];--j)			<span class="comment">//从后往前查找带插入的位置</span></span><br><span class="line">                A[j+<span class="number">1</span>] = A[j];			<span class="comment">//向后挪位</span></span><br><span class="line">            A[j+<span class="number">1</span>] = A[<span class="number">0</span>];		<span class="comment">//复制到插入位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li><strong>空间复杂度：O(1)</strong></li>
<li><strong>时间复杂度：O(n²)</strong></li>
</ul>
<p><strong>算法稳定性：稳定</strong></p>
<h3 id="折半插入排序（优化）"><a href="#折半插入排序（优化）" class="headerlink" title="折半插入排序（优化）"></a>折半插入排序（优化）</h3><p>由于是顺序存储的线性表，且前面序列是已经排好序的序列，我们在查找某个元素的插入位置的时候，可以<strong>使用折半查找来确定待插入位置</strong>，确定插入位置后，在统一的向后移动位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//折半插入查找</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,low,high,mid;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">2</span>; i &lt;= n; i++)&#123;		<span class="comment">//依次将A[2]~A[n]插入前面的已排序序列</span></span><br><span class="line">        A[<span class="number">0</span>] = A[i];		<span class="comment">//将A[i]暂存到A[0]</span></span><br><span class="line">        low == <span class="number">1</span>;high = i<span class="number">-1</span>;		<span class="comment">//设置折半查找的范围</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;			<span class="comment">//找到插入的位置。low</span></span><br><span class="line">            mid = (low + high) &gt;&gt; <span class="number">1</span>;	<span class="comment">//取中间值</span></span><br><span class="line">            <span class="keyword">if</span>(A[mid] &gt; A[<span class="number">0</span>])			<span class="comment">//当A[mid] == A[0]时，为了稳定性，我们继续往右找一个位置。</span></span><br><span class="line">                high = mid - <span class="number">1</span>;			<span class="comment">//查找左半子表</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;		<span class="comment">//查找右半子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//low = high +1</span></span><br><span class="line">        <span class="keyword">for</span>(j = i<span class="number">-1</span>; j &gt;= low; --j)</span><br><span class="line">            A[j+<span class="number">1</span>] = A[j];			<span class="comment">//统一后移元素，空出插入位置</span></span><br><span class="line">        A[low] = A[<span class="number">0</span>];		<span class="comment">//插入操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>节省了比较的次数，但是没有节省移动的时间——<strong>时间复杂度：O(n²)</strong></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>先将待排序表分割成若干形如L[i , i+d, i+2d, i+3d,….. i+kd]的“特殊“子表，对各个子表分别进行直接插入排序，缩小<font color='red'>增量d</font>,重复上述过程，直到d为1为止。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d,i,j;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元，不是哨兵，当j&lt;=0时，插入位置已经到了</span></span><br><span class="line">    <span class="keyword">for</span>(d = n/<span class="number">2</span> ; d &gt;= <span class="number">1</span> ; d = d/<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = d+<span class="number">1</span>; i&lt;=n;i++)&#123;		<span class="comment">//步长变化</span></span><br><span class="line">            <span class="keyword">if</span>(A[i] &lt; A[i-d])&#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[i];		<span class="comment">//暂存A[0]</span></span><br><span class="line">                <span class="keyword">for</span>(j = i-d; j&gt;<span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j]; j = j-d)&#123;</span><br><span class="line">                    A[j+d] = A[j];			<span class="comment">//记录后移动，查找插入的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                A[j+d] = A[<span class="number">0</span>];		<span class="comment">//插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li><strong>空间复杂度：O(1)</strong></li>
<li><strong>时间复杂度：O(n²)</strong></li>
</ul>
<p><strong>希尔排序仅仅适用于顺序表，不适用于链表</strong></p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>从后往前(或者从前往后)两两比较相邻元素的值，若为逆序(即A[i-1] &gt; A[i])，则交换它们，直到序列比较完，称这样过程为”一趟“冒泡排序</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;				<span class="comment">//表示本趟冒泡是否发生交换的标志</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j &gt; i;j++)&#123;	<span class="comment">//一趟冒泡排序</span></span><br><span class="line">            <span class="keyword">if</span>(A[j<span class="number">-1</span>] &gt; A[j])&#123;			<span class="comment">//若为逆序</span></span><br><span class="line">                swap(A[j<span class="number">-1</span>],A[j]);		<span class="comment">//交换</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span>;			<span class="comment">//如果在一趟遍历后，没有发生任何交换，说明表已经有序了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li><strong>空间复杂度：O(1)</strong></li>
<li><strong>时间复杂度：O(n²)</strong></li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>在待排序表L[1 , 2… n]中任取一个元素pivot作为<font color='red'>基准（通常取首元素）</font>，通过一趟排序将待排序表划分为独立的两部分L[1,… k-1]和L[k+1,…n]，使得L[1,… k-1]中的所有元素小于pivot，L[k+1,…n]中的所有元素大于等于pivot，则pivot放在了其最终位置L[k]上，这个过程称为一次“划分”，然后分别<font color='red'>递归</font>地对两个子表重复上述过程，直至每部分内只有一个元素或者空为止，即所有元素放在了最终位置上。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &gt;= high) <span class="keyword">return</span>;				<span class="comment">//当子表中存在一个或者没有元素时，不进行操作</span></span><br><span class="line">    <span class="keyword">int</span> pivotpos = Partition(A,low,high);		<span class="comment">//划分</span></span><br><span class="line">    QuickSort(A,low,pivotpos<span class="number">-1</span>);			<span class="comment">//划分左子表</span></span><br><span class="line">    QuickSort(A,pivotpos+<span class="number">1</span>,high);			<span class="comment">//划分右子表</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用第一个元素将待排序序列分成左右两个部分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = A[low];		<span class="comment">//用第一个元素作为枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;			<span class="comment">//用low、high搜索枢轴的最终位置</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[high]&gt;=pivot) --high;			<span class="comment">//从右往左找到比枢轴小的元素的下标</span></span><br><span class="line">        A[low] = A[high];			<span class="comment">//比枢轴小的元素移动到左端</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt; pivot) ++low;			<span class="comment">//从左往右找到比枢轴大的元素的下标</span></span><br><span class="line">        A[high] = A[low];			<span class="comment">//比枢轴大的元素移动到右端</span></span><br><span class="line">    &#125;</span><br><span class="line">    A[low] = pivot;				<span class="comment">//枢轴元素存放的最终位置	</span></span><br><span class="line">    <span class="keyword">return</span> low;				<span class="comment">//返回存放枢轴的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="算法效率分析"><a href="#算法效率分析" class="headerlink" title="算法效率分析"></a>算法效率分析</h3><ul>
<li><strong>时间复杂度：O(n*递归层数)</strong><ul>
<li>最好：O(n㏒n)</li>
<li>最坏：O(n²)            <strong>{原本逆序或者顺序}</strong></li>
</ul>
</li>
<li><strong>空间复杂度：O(递归层数)</strong><ul>
<li>最好：O(㏒n)</li>
<li>最坏：O(n)            <strong>{原本逆序或者顺序}</strong></li>
</ul>
</li>
</ul>
<p><strong>n个元素组织成二叉树，二叉树的层数就算递归调用的层数：最小高度 = ⌊ ㏒ n⌋ + 1,最大高度 = n；</strong></p>
<p><strong><font color='red'>快速排序是所有内部排序算法中平均性能最优的排序算法</font></strong></p>
<p><strong>快速排序是不稳定的</strong></p>
<h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><p><strong>每一趟在待排序元素中选取关键字最小的元素加入有序子序列</strong></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n<span class="number">-1</span>; i++)&#123;			<span class="comment">//一共进行n-1趟</span></span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">min</span> = i;				<span class="comment">//记录最小元素位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)&#123;		<span class="comment">//在A[i... n-1]中选择最小的元素</span></span><br><span class="line">            <span class="keyword">if</span>(A[j] &lt; A[<span class="built_in">min</span>]) <span class="built_in">min</span> = j;		<span class="comment">//更新最小元素的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">min</span> != <span class="number">1</span>) swap(A[i],A[<span class="built_in">min</span>])		<span class="comment">//封装的swap()函数共移动元素3次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度-3"><a href="#复杂度-3" class="headerlink" title="复杂度"></a>复杂度</h3><ul>
<li>时间复杂度：O(n²)</li>
<li>空间复杂度：O(1);</li>
</ul>
<p><strong>简单选择排序是不稳定的</strong></p>
<p><strong>既可以使用在顺序表，也可以是链表</strong></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong>定义：</strong>若关键字序列L[1…n]满足下面某条性质，则称为<font color='red'>堆(Heap)</font></p>
<ol>
<li>若满足：L(i) ≥ L(2i) 且 L(i) ≥ L(2i+1) (1 ≤ i ≤ n/2)     —— <strong><font color='red'>大根堆 (大顶堆)</font></strong></li>
<li>若满足：L(i) ≤ L(2i) 且 L(i) ≤ L(2i+1) (1 ≥ i ≥ n/2)     —— <strong><font color='red'>小根堆 (小顶堆)</font></strong></li>
</ol>
<p>大根堆：完全二叉树中，<font color='red'>根 ≥ 左、右</font></p>
<p>小根堆：完全二叉树中，<font color='red'>根 ≤ 左、右</font></p>
<p><strong>完全二叉树中：</strong></p>
<ul>
<li><strong>i的左孩子 ——2i</strong></li>
<li><strong>i的右孩子 —— 2i+1</strong></li>
<li><strong>i的父节点 ——⌊ i/2 ⌋</strong></li>
</ul>
<h3 id="建立大根堆"><a href="#建立大根堆" class="headerlink" title="建立大根堆"></a>建立大根堆</h3><ul>
<li><font color='red'>根 ≥ 左、右</font></li>
</ul>
<h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><p><strong>把所有非终端结点都检查一边，是否满足大根堆的要求，如果不满足，则进行调整。</strong></p>
<ul>
<li>检查当前结点是否满足 <font color='red'>根 ≥ 左、右</font>，<strong><font color='red'>若不满足，将当前结点与更大的一个孩子互换</font></strong></li>
<li>若元素互换破坏了下一级的堆，则采用相同的办法继续往下调整(<font color='red'>小元素不断”下坠“</font>)</li>
</ul>
<p>{在顺序存储的完全二叉树中，非终端结点编号 <font color='red'>i ≤ ⌊ n/2 ⌋</font>}</p>
<h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        HeadAdjust(A,j,len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    A[<span class="number">0</span>] = A[k];			<span class="comment">//A[0]暂存子树的根结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> * k;i &lt; len; i *= <span class="number">2</span>)&#123;		<span class="comment">//沿key较大的子节点向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="number">1</span>])</span><br><span class="line">            i++;				<span class="comment">//取key较大的子结点的下标，</span></span><br><span class="line">        <span class="keyword">if</span>(A[<span class="number">0</span>] &gt;= A[i])	<span class="keyword">break</span>;		<span class="comment">//筛选结束</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            A[k] = A[i];			<span class="comment">//A[i]调整到双亲结点上</span></span><br><span class="line">            k = i;					<span class="comment">//修改k值，以便继续向下筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    A[k] = A[<span class="number">0</span>];				<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="复杂度-4"><a href="#复杂度-4" class="headerlink" title="复杂度"></a>复杂度</h4><ul>
<li><p><strong>时间复杂度：O(n)</strong></p>
<p>关键字比较总次数不超过4n</p>
</li>
</ul>
<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p><strong>定义：</strong>每一趟将堆顶元素加入有序子序列(与待排序序列中的最后一个元素交换)。并将待排序元素序列再次调整为大根堆（小元素不断“下坠”）同时len-1。</p>
<h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//将以k为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序的完整逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    BuildMaxHeap(A,len):			<span class="comment">//初始建堆 O(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len; i &gt; <span class="number">1</span>; --i)&#123;			<span class="comment">//n-1趟的交换和建堆过程 	</span></span><br><span class="line">        swap(A[i],A[<span class="number">1</span>]);			<span class="comment">//堆顶元素和堆底元素交换</span></span><br><span class="line">        HeadAdjust(A,<span class="number">1</span>,i<span class="number">-1</span>);		<span class="comment">//把剩余的待排序元素整理成堆</span></span><br><span class="line">    &#125;		<span class="comment">//一趟：O(h) = O(⌊ ㏒n ⌋ + 1),总的时间复杂度是O( n㏒n )</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color='red'>获得是递增序列</font></strong></p>
<h4 id="复杂度-5"><a href="#复杂度-5" class="headerlink" title="复杂度"></a>复杂度</h4><ul>
<li>时间复杂度：O(n㏒n)</li>
<li>空间复杂度：O(1)</li>
</ul>
<p><strong>堆排序是不稳定的</strong></p>
<h3 id="堆的插入和删除-以小根堆为例"><a href="#堆的插入和删除-以小根堆为例" class="headerlink" title="堆的插入和删除(以小根堆为例)"></a>堆的插入和删除(以小根堆为例)</h3><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>对于小根堆，新元素放到表尾，与父结点对比，若<font color='red'>新元素</font>比父节点<font color='red'>更小</font>，则将二者互换。新元素就这样子一路“<font color='red'>上升</font>”，直到无法继续上升为止。</p>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>被删除的元素用<font color='red'>堆底元素替代</font>，然后让该元素不断“<font color='red'>下坠</font>”，直到无法下坠为止。</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法思想-5"><a href="#算法思想-5" class="headerlink" title="算法思想"></a>算法思想</h3><p>归并：把两个或多个已经有序的序列合并成一个。</p>
<p>2路归并：把两个已经有序的序列合并成一个。</p>
<h3 id="手动模拟排序"><a href="#手动模拟排序" class="headerlink" title="手动模拟排序"></a>手动模拟排序</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">初始序列：        49 38 65 97 76 13 27</span><br><span class="line">                [49 38] [65 97] [76 13] [27]</span><br><span class="line">第一趟归并排序：   38 49  65 97 13 76 27</span><br><span class="line">				[38 49  65 97] [13 76 27]</span><br><span class="line">第二趟归并排序:    38 49  65 97 13 76 27</span><br><span class="line">				[38 49  65 97 13 76 27]</span><br><span class="line">第二趟归并排序:	13 27 38 49 65 76 97</span><br></pre></td></tr></table></figure>

<p><strong>核心操作：把数组内的两个有序序列归并为一个</strong></p>
<h3 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> *B = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));		<span class="comment">//辅助数组B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//A[low....mid]和A[mid+1 ... high]各自有序，将两个部分合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(k = low; k &lt;= high; k++)&#123;</span><br><span class="line">        B[k] = A[k];		<span class="comment">//将A中所有元素复制到B中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = low,j = mid + <span class="number">1</span>,k = i; i&lt;= mid &amp;&amp; j &lt;= high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(B[i] &lt;= B[j])		<span class="comment">//将较小值复制到A中。(这里等号可以保证算法的稳定性)</span></span><br><span class="line">            A[k] = B[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) A[k++] = B[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> low,<span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low+high)&gt;&gt;<span class="number">1</span>;		<span class="comment">//从中间划分</span></span><br><span class="line">        MergeSort(A,low,mid);			<span class="comment">//对左部分归并排序</span></span><br><span class="line">        MergeSort(A,mid+<span class="number">1</span>,high);		<span class="comment">//对右半部分归并排序</span></span><br><span class="line">        Merge(A,low,mid,high);			<span class="comment">//归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度："><a href="#复杂度：" class="headerlink" title="复杂度："></a>复杂度：</h3><p><strong>空间复杂度：O(n);</strong></p>
<p><strong>时间复杂度：O(n㏒n)；</strong></p>
<p>​    每一趟归并的时间复杂度是O(n),共需要进行⌈ ㏒n ⌉。</p>
<p> <strong>归并排序是稳定的</strong></p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="擅长解决的问题"><a href="#擅长解决的问题" class="headerlink" title="擅长解决的问题"></a>擅长解决的问题</h3><ol>
<li>数据元素的关键字可以方便地拆分为d组，且d较小</li>
<li>每组关键字的取值范围不大，即r较小</li>
<li>数据元素个数n较大。</li>
</ol>
<h2 id="内部排序算法的比较"><a href="#内部排序算法的比较" class="headerlink" title="内部排序算法的比较"></a>内部排序算法的比较</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均时间复杂度<strong>O(n²)：</strong>简单选择排序、直接插入排序、冒泡排序</p>
<p>最好时间复杂度<strong>O(n)：</strong>直接插入排序、冒泡排序。</p>
<p>最坏时间复杂度<strong>O(n²)</strong>：快速排序</p>
<p>平均时间复杂度<strong>O(n㏒n)</strong>：快速排序</p>
<p><strong>归并排序最好、最坏、平均的时间复杂度：O(n㏒n)</strong></p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><strong>O(1):</strong>      简单选择排序、插入排序、冒泡排序、希尔排序、堆排序</p>
<p><strong>O(㏒n)：</strong>快速排序(平均);</p>
<p><strong>O(n)：</strong>归并排序、快速排序(<strong>最坏是O(n)</strong>);</p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>稳定：</strong>插入排序、冒泡排序、归并排序、基数排序</p>
<p><strong>不稳定：</strong>简单选择排序、快速排序、希尔排序、堆排序</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul>
<li><p><strong>数据量较小时</strong>，采用直接插入排序或者简单选择排序。</p>
</li>
<li><p><strong>基本有序</strong>，采用直接插入或者冒泡排序</p>
</li>
<li><p><strong>数据量较大时</strong>，采快速排序、归并排序、堆排序</p>
<p>数据随机分布：快速排序</p>
<p>辅助空间少：堆排序</p>
<p>算法稳定：归并排序</p>
</li>
</ul>
<h2 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h2><h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2>]]></content>
      <categories>
        <category>考研</category>
      </categories>
      <tags>
        <tag>-笔记 -数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度运算</title>
    <url>/posts/7de295bc/</url>
    <content><![CDATA[<h3 id="大整数相加"><a href="#大整数相加" class="headerlink" title="大整数相加"></a>大整数相加</h3><h4 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h4><h5 id="如何存储"><a href="#如何存储" class="headerlink" title="如何存储"></a>如何存储</h5><p>例如存储123456789，我们把每一位都存在数组中,这里我们数组中的第0位存数字9，这是因为两数相加可能会出现进位的现象，倒过来存储方便于加一位。</p>
<h5 id="运算：模拟人工加法"><a href="#运算：模拟人工加法" class="headerlink" title="运算：模拟人工加法"></a>运算：模拟人工加法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1 2 3</span><br><span class="line">    +   8 9 </span><br><span class="line">    --------</span><br><span class="line">      2 1 2</span><br><span class="line">&#x2F;**</span><br><span class="line">  1、3 + 9 &#x3D; 12 》10.所以进一位</span><br><span class="line">  2、2 + 8 +1 &#x3D; 11 &gt; 10,所以进一位</span><br><span class="line">  3、1 + 1 &#x3D; 2 &lt; 10,所以不进位</span><br><span class="line">**&#x2F;</span><br><span class="line">注意：这里有进位</span><br></pre></td></tr></table></figure>



<h4 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>() ; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><h5 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a><strong>高精度加法</strong></h5><blockquote>
<p>给定两个正整数，计算它们的和。</p>
<p><strong>输入格式</strong></p>
<p>共两行，每行包含一个整数。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含所求的和。</p>
<p><strong>数据范围</strong></p>
<p>1≤整数长度≤1000001≤整数长度≤100000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;12</span><br><span class="line">&gt;23</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;35</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>解答代码</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">//这里用于存储进位</span></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++)&#123;</span><br><span class="line">        <span class="comment">//每一次计算的结果都是 A[i]+B[i]+t</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里全部都算完后，t！=0时，我们还需要把t放入到最前面</span></span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">     <span class="comment">//反向存储</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span> ;i &gt;= <span class="number">0</span>; i --) A.push_back(a[i] -<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span> ;i &gt;= <span class="number">0</span>; i --) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="built_in">vector</span> C = add(A,B);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="大数相减"><a href="#大数相减" class="headerlink" title="大数相减"></a>大数相减</h3><h4 id="运算：模拟人工减法"><a href="#运算：模拟人工减法" class="headerlink" title="运算：模拟人工减法"></a>运算：模拟人工减法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1 2 3</span><br><span class="line">    -   8 9 </span><br><span class="line">    --------</span><br><span class="line">        3 4</span><br><span class="line">&#x2F;**</span><br><span class="line">  1、3&lt;9,所以需要向上借位</span><br><span class="line">  2、2 - 1 &lt; 8,所以需要向上借位</span><br><span class="line">  3、1 - 1 ≥ 0,所以不需要向上借位</span><br><span class="line">**&#x2F;</span><br><span class="line">注意：这里有借位</span><br></pre></td></tr></table></figure>

<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><ol>
<li>为了计算A-B，我们先判断出A，B哪一个数值大，方便计算，并且最高位一定不需要向上借位，这样子就减少了边界情况<ol>
<li>如果 A &gt; B ，我们就直接A-B</li>
<li>如果 A &lt; B , 我们就计算 —(A - B);</li>
</ol>
</li>
<li>如果 A[i] - B[i] -t 是否大于等于0<ol>
<li>大于等于0；就不需要向上借位，直接计算</li>
<li>小于0，就需要上借位，计算A[i] + 10 - B[i] -t，并且设置 t=0; </li>
</ol>
</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><h5 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h5><blockquote>
<p>给定两个正整数，计算它们的差，计算结果可能为负数。</p>
<p><strong>输入格式</strong></p>
<p>共两行，每行包含一个整数。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含所求的差。</p>
<p><strong>数据范围</strong></p>
<p>1≤整数长度≤1051≤整数长度≤105</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;32</span><br><span class="line">&gt;11</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;21</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>答案</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较 A &gt; B的大小</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">com</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span> ;i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">//t表示是否借位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>; i &lt; len;i++)&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t = t - B[i];</span><br><span class="line">        C.push_back( (t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除去前导零</span></span><br><span class="line">    <span class="keyword">while</span>( C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span> ) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--) B.push_back(b[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">bool</span> T = com(A,B);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">if</span>(com(A,B))&#123;</span><br><span class="line">        C = sub(A,B);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        C = sub(B,A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="大数乘以小数"><a href="#大数乘以小数" class="headerlink" title="大数乘以小数"></a>大数乘以小数</h3><h4 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h4><p>这里我们把小数看成一个整体，而不是一位一位乘，这样就不需要考虑加法的运算</p>
<h4 id="运算：模拟人工乘法"><a href="#运算：模拟人工乘法" class="headerlink" title="运算：模拟人工乘法"></a>运算：模拟人工乘法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      1 2 3</span><br><span class="line">    *   1 2 </span><br><span class="line">    --------</span><br><span class="line">         </span><br><span class="line">&#x2F;**</span><br><span class="line">	1、(3 * 12) % 10 &#x3D; 6</span><br><span class="line">    	t &#x3D; (3 * 12) &#x2F;10 &#x3D; 3</span><br><span class="line">    2、(2 * 12 + t) % 10 &#x3D; 7</span><br><span class="line">    	t &#x3D; (2 * 12 + t) &#x2F; 10 &#x3D; 2</span><br><span class="line">    3、(1 * 12 + t) % 10 &#x3D; 4</span><br><span class="line">    	t &#x3D; (1 * 12 + t) &#x2F; 10 &#x3D; 1</span><br><span class="line">**&#x2F;</span><br><span class="line">注意：这里有进位</span><br></pre></td></tr></table></figure>

<h4 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//除去前导0</span></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><h5 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h5><blockquote>
<p>给定两个正整数 AA 和 BB，请你计算 A×BA×B 的值。</p>
<p><strong>输入格式</strong></p>
<p>共两行，第一行包含整数 AA，第二行包含整数 BB。</p>
<p><strong>输出格式</strong></p>
<p>共一行，包含 A×BA×B 的值。</p>
<p><strong>数据范围</strong></p>
<p>1≤A的长度≤1000001≤A的长度≤100000,<br>0≤B≤100000≤B≤10000</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;2</span><br><span class="line">&gt;3</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;6</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>答案</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="comment">//这里是防止出现前导0，如果b=0，那就答案可能出现0000……，我们需要情况讨论，或者在后面处理以下前导0</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)&#123;</span><br><span class="line">        C.push_back(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">        t = A[i] * b + t;</span><br><span class="line">        C.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t = t/<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里不能这样写，如果b = 50，A[i] = 9,那这里的t = 45，如果这样子输入，就只能输入4，而不是全部输入，所以我们需要把t循环输入</span></span><br><span class="line">    <span class="comment">//if(t != 0) C.push_back(t%10);</span></span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        C.push_back(t%<span class="number">10</span>);</span><br><span class="line">        t = t/<span class="number">10</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = mul(A,b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- ) <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="大数除以小数"><a href="#大数除以小数" class="headerlink" title="大数除以小数"></a>大数除以小数</h3><h4 id="运算：模拟人工除法"><a href="#运算：模拟人工除法" class="headerlink" title="运算：模拟人工除法"></a>运算：模拟人工除法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     0 1 1 2	</span><br><span class="line">    --------</span><br><span class="line"> 11√ 1 2 3 5</span><br><span class="line">     1</span><br><span class="line">    --------</span><br><span class="line">     1 2</span><br><span class="line">     1 1</span><br><span class="line">     --------</span><br><span class="line">       1 3</span><br><span class="line">       1 1</span><br><span class="line">      -------</span><br><span class="line">         2 5</span><br><span class="line">         2 2</span><br><span class="line">         -----</span><br><span class="line">           3</span><br><span class="line">&#x2F;**</span><br><span class="line">	1、r &#x3D; 0 </span><br><span class="line">	   (r * 10 +1) &#x2F; 10 &#x3D; 0</span><br><span class="line">       r &#x3D; (r * 10 +1) % 10 &#x3D; 1</span><br><span class="line">    2、(r * 10 +1) &#x2F; 10 &#x3D; 1</span><br><span class="line">       r &#x3D; (r * 10 +1) % 10 &#x3D; 1</span><br><span class="line">    3、(r * 10 +1) &#x2F; 10 &#x3D; 1</span><br><span class="line">       r &#x3D; (r * 10 +1) % 10 &#x3D; 2</span><br><span class="line">    4、(r * 10 +1) &#x2F; 10 &#x3D; 2</span><br><span class="line">       r &#x3D; (r * 10 +1) % 10 &#x3D; 3</span><br><span class="line"> ——————————————————————————————————————————</span><br><span class="line"> 所以答案是 0112，余数为3</span><br></pre></td></tr></table></figure>

<h4 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><h5 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h5><blockquote>
<p>给定两个非负整数 A，BA，B，请你计算 A/BA/B 的商和余数。</p>
<p><strong>输入格式</strong></p>
<p>共两行，第一行包含整数 AA，第二行包含整数 BB。</p>
<p><strong>输出格式</strong></p>
<p>共两行，第一行输出所求的商，第二行输出所求余数。</p>
<p><strong>数据范围</strong></p>
<p>1≤A的长度≤1000001≤A的长度≤100000,<br>1≤B≤100001≤B≤10000,<br>BB 一定不为 00</p>
<p><strong>输入样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;7</span><br><span class="line">&gt;2</span><br></pre></td></tr></table></figure>

<p><strong>输出样例：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;3</span><br><span class="line">&gt;1</span><br></pre></td></tr></table></figure>


</blockquote>
<p><strong>解答</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> b,<span class="keyword">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">   r = <span class="number">0</span>;</span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">       r = r*<span class="number">10</span>+A[i];</span><br><span class="line">       C.push_back(r/b);</span><br><span class="line">       r = r%b;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   由于下面输入方式是从后往前面输出，而这里我们得到的真正的数值，如 0001111类型的，所以我们需要反转vector</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   reverse(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());</span><br><span class="line">   <span class="comment">//除去前导零</span></span><br><span class="line">   <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">   <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- ) A.push_back(a[i] - <span class="string">'0'</span>);</span><br><span class="line">    <span class="comment">//r为余数</span></span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = div(A,b,r);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-- ) <span class="built_in">printf</span>(<span class="string">"%d"</span>,C[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%d"</span>,r);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>-笔记 -算法</tag>
      </tags>
  </entry>
</search>
